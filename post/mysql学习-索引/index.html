<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>mysql学习-索引 - vgmdj&#39;s blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="VGMDJ" />
  <meta name="description" content="索引 索引是存储引擎找到记录的一种数据结构，而索引优化是对查询性能优化最有效的手段。其类似于一本书的目录部分，如果想在一本书中找到某个特定主题，一般会先看书中的“索引部分”，找到对应的页码。
在MySQL中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。
索引可以包含一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。

" />

  <meta name="keywords" content="vgmdj, blog, it" />






<meta name="generator" content="Hugo 0.48" />


<link rel="canonical" href="https://blog.vgmdj.cn/post/mysql%E5%AD%A6%E4%B9%A0-%E7%B4%A2%E5%BC%95/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<link href="/dist/even.min.css?v=3.2.0" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="mysql学习-索引" />
<meta property="og:description" content="索引

索引是存储引擎找到记录的一种数据结构，而索引优化是对查询性能优化最有效的手段。其类似于一本书的目录部分，如果想在一本书中找到某个特定主题，一般会先看书中的“索引部分”，找到对应的页码。

在MySQL中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。

索引可以包含一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.vgmdj.cn/post/mysql%E5%AD%A6%E4%B9%A0-%E7%B4%A2%E5%BC%95/" /><meta property="article:published_time" content="2018-04-06T10:00:49&#43;00:00"/>
<meta property="article:modified_time" content="2018-04-17T17:45:31&#43;00:00"/>
<meta itemprop="name" content="mysql学习-索引">
<meta itemprop="description" content="索引

索引是存储引擎找到记录的一种数据结构，而索引优化是对查询性能优化最有效的手段。其类似于一本书的目录部分，如果想在一本书中找到某个特定主题，一般会先看书中的“索引部分”，找到对应的页码。

在MySQL中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。

索引可以包含一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。

">


<meta itemprop="datePublished" content="2018-04-06T10:00:49&#43;00:00" />
<meta itemprop="dateModified" content="2018-04-06T10:00:49&#43;00:00" />
<meta itemprop="wordCount" content="4918">



<meta itemprop="keywords" content="database,mysql," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="mysql学习-索引"/>
<meta name="twitter:description" content="索引

索引是存储引擎找到记录的一种数据结构，而索引优化是对查询性能优化最有效的手段。其类似于一本书的目录部分，如果想在一本书中找到某个特定主题，一般会先看书中的“索引部分”，找到对应的页码。

在MySQL中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。

索引可以包含一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。

"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">keep thinking</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/messages/">
        <li class="mobile-menu-item">Messages</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">keep thinking</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/messages/">Messages</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">mysql学习-索引</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-04-06 10:00:49 </span>
        <div class="post-category">
            
              <a href="/categories/database/"> database </a>
            
          </div>
        <span class="more-meta"> 约 4918 字 </span>
        <span class="more-meta"> 预计阅读 10 分钟 </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次阅读 </span>
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li><a href="#索引">索引</a></li>
<li><a href="#索引类型">索引类型</a>
<ul>
<li><a href="#根据功能划分">根据功能划分</a></li>
<li><a href="#根据数据结构划分">根据数据结构划分</a></li>
<li><a href="#b-tree索引-和-hash索引对比">B-Tree索引 和 Hash索引对比</a></li>
<li><a href="#b-tree-和-b-tree-比较">B-Tree 和 B+Tree 比较</a></li>
</ul></li>
<li><a href="#索引的优缺点">索引的优缺点</a>
<ul>
<li><a href="#优点">优点</a></li>
<li><a href="#缺点">缺点</a></li>
</ul></li>
<li><a href="#索引的适用范围及限制-b-tree索引">索引的适用范围及限制（B-Tree索引）</a>
<ul>
<li><a href="#有效范围">有效范围</a></li>
<li><a href="#使用限制">使用限制</a></li>
<li><a href="#设计索引原则">设计索引原则</a></li>
</ul></li>
<li><a href="#索引策略">索引策略</a>
<ul>
<li><a href="#使用独立的列">使用独立的列</a></li>
<li><a href="#前缀索引和索引选择性">前缀索引和索引选择性</a>
<ul>
<li><a href="#优缺点">优缺点</a></li>
<li><a href="#prefix-length确定">prefix_length确定</a></li>
<li><a href="#适用场景">适用场景</a></li>
</ul></li>
<li><a href="#多列索引">多列索引</a></li>
<li><a href="#选择合适的顺序-b-tree">选择合适的顺序（B-Tree）</a></li>
<li><a href="#聚簇索引">聚簇索引</a></li>
<li><a href="#覆盖索引-innodb">覆盖索引（innoDB）</a></li>
<li><a href="#使用索引扫描来做排序">使用索引扫描来做排序</a></li>
<li><a href="#删除低质量的索引">删除低质量的索引</a></li>
</ul></li>
<li><a href="#参考内容">参考内容</a></li>
</ul>
</nav>
  </div>
</div>

    
    

    
    <div class="post-content">
      <h1 id="索引">索引</h1>

<p>索引是存储引擎找到记录的一种数据结构，而索引优化是对查询性能优化最有效的手段。其类似于一本书的目录部分，如果想在一本书中找到某个特定主题，一般会先看书中的“索引部分”，找到对应的页码。</p>

<p>在MySQL中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。</p>

<p>索引可以包含一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。</p>

<p></p>

<h1 id="索引类型">索引类型</h1>

<h2 id="根据功能划分">根据功能划分</h2>

<ul>
<li><p>UNIQUE
唯一索引，不可以出现相同值，但是可以有NULL值</p></li>

<li><p>INDEX
普通索引，可以出现相同值</p></li>

<li><p>PRIMARY KEY
主键索引，不允许出现相同的值,且不能为NULL值,一个表只能有一个primary_key索引</p></li>

<li><p>FULLTEXT INDEX
全文索引，可以针对值中的某个单词设置索引,但是只有myisam以及英文支持,并且效率不高，特殊场景下使用</p></li>
</ul>

<h2 id="根据数据结构划分">根据数据结构划分</h2>

<ul>
<li><p>B-Tree索引
一般来说， B-Tree 索引的物理文件大多都是以 Balance Tree 的结构来存储的，也就是所有实际需要的数据都存放于 Tree 的 Leaf Node ，而且到任何一个 Leaf Node 的最短路径的长度都是完全相同的，在CREATE TABLE和其他语句中都会使用到该关键字，所以我们大家都称之为 B-Tree 索引。当然，各种存储引擎的底层存储结构可能存在不同，如大多数引擎包括MySQL使用的是B+Tree， NDB集群存储引擎内部使用的是T-TREE结构，但它们都是BTREE。
可以在 <a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a> 上看到B-Tree的可视化操作过程</p></li>

<li><p>Hash索引
基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个hash code，这是一个较小的值，并且不同键值的行计算出的hash code也不一样。哈希索引将所有的hash code存储在索引中，同时在哈希表中保存指向每个数据行的指针。
在MySQL中，只有Memory引擎支持Hash索引，同时Hash索引也是Memory引擎的默认索引类型。</p></li>
</ul>

<h2 id="b-tree索引-和-hash索引对比">B-Tree索引 和 Hash索引对比</h2>

<ul>
<li>如果是等值查询，那么哈希索引明显有绝对优势，因为Hash表查找是O(1)的时间复杂度；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</li>
<li>如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</li>
<li>同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</li>
<li>哈希索引也不支持多列联合索引的最左匹配规则；</li>
<li>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</li>
</ul>

<h2 id="b-tree-和-b-tree-比较">B-Tree 和 B+Tree 比较</h2>

<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>

<h1 id="索引的优缺点">索引的优缺点</h1>

<h2 id="优点">优点</h2>

<ul>
<li>索引大大减少了服务器需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变为顺序I/O</li>
</ul>

<h2 id="缺点">缺点</h2>

<ul>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</li>
</ul>

<h1 id="索引的适用范围及限制-b-tree索引">索引的适用范围及限制（B-Tree索引）</h1>

<h2 id="有效范围">有效范围</h2>

<ul>
<li>全值匹配</li>
<li>匹配最左前缀</li>
<li>匹配列前缀</li>
<li>匹配范围值</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>只访问索引的查询</li>
<li>空值查询，使用<strong>is null</strong>可以使用到索引</li>
</ul>

<h2 id="使用限制">使用限制</h2>

<ul>
<li>如果MySQL估计使用索引比全表扫描慢，则不使用

<ul>
<li>value 均匀分布在1-100,查询 &lsquo;where value &gt; 1 and value &lt; 100&rsquo;时，不使用索引反而更好</li>
</ul></li>
<li>like 模糊查找有一定限制

<ul>
<li>like &lsquo;%3&rsquo; 不会使用索引</li>
<li>like &lsquo;3%&rsquo; 会使用索引</li>
</ul></li>
<li>对于MEMORY/HEAP表，where条件中不使用“=”进行索引列，那么不会用到索引</li>
</ul>

<h2 id="设计索引原则">设计索引原则</h2>

<ul>
<li>尽量使用选择性高的列，即在重复度高的列上建立索引，不要在重复度低的列上建立索引</li>
<li>利用最左前缀，多个列的独立索引相比联合索引会带来更多的空间和计算资源上的消耗，所以如果能匹配上最左前缀，就使用多列索引，而不要使用多个列索引</li>
<li>利用很少的列尽量不要建立索引，因为虽然索引可以带来搜索效率上的提升，但同时需要占用额外的空间，以及修改时的额外开销</li>
<li>主键尽量使用较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存效果</li>
</ul>

<h1 id="索引策略">索引策略</h1>

<h2 id="使用独立的列">使用独立的列</h2>

<p>独立的列是指索引列不能是表达式的一部分，也不能是函数的参数</p>

<ul>
<li>下列查询无法使用索引actor_id</li>
</ul>

<pre><code>SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;

</code></pre>

<p>应改为</p>

<pre><code>SELECT actor_id FROM sakila.actor WHERE actor_id = 4;

如果一定要用表达式，也应该是：
SELECT actor_id FROM sakila.actor WHERE actor_id = 5-1;
</code></pre>

<ul>
<li>常见错误</li>
</ul>

<pre><code>SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) &lt;= 10;
</code></pre>

<h2 id="前缀索引和索引选择性">前缀索引和索引选择性</h2>

<p>如果要索引一个很长的字符列，这会让索引变得大且慢。一种方案是使用hash索引，但hash索引有时候还不够，这个时候就可以考虑使用前缀索引。</p>

<h3 id="优缺点">优缺点</h3>

<p>使用前缀索引，可以大大节约索引空间，从而提高索引效率，但同时也会降低索引的选择性，同时不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引。</p>

<h3 id="prefix-length确定">prefix_length确定</h3>

<p>使用前缀索引的关键在于选择合知的prefix_length，从而尽可能提高索引选择性，即假如对于字符长度10的一半就可以唯一确定这个字符，那么使用前缀索引，prefix_length=5,就可以达到使用索引的应有效果，可以大大节约空间和提高效率
前缀长度的确定方式，就是计算完整列的选择性，并使前缀的选择性接近于完整的选择性。</p>

<ul>
<li>完整列的选择性：</li>
</ul>

<pre><code>select count(distinct city)/count(*) from sakila.city_demo;

</code></pre>

<ul>
<li>不同前缀长度下的选择性：</li>
</ul>

<pre><code>select count(distinct left(city,3))/count(*) as sel3,
  count(distinct left(city,4))/count(*) as sel4,
  count(distinct left(city,5))/count(*) as sel5,
  count(distinct left(city,6))/count(*) as sel6,
  count(distinct left(city,7))/count(*) as sel7
from sakila.city_demo;

</code></pre>

<ul>
<li>比较结果，选择长度和选择性都比较合适的情况建立前缀索引</li>
</ul>

<h3 id="适用场景">适用场景</h3>

<ul>
<li>字符串列(varchar,char,text等)，需要进行全字段匹配</li>
<li>字符串本身可能比较长，而且前几个字符就开始不相同。比如我们对中国人的姓名使用前缀索引就没啥意义，因为中国人名字都很短，另外对收件地址使用前缀索引也不是很实用，因为一方面收件地址一般都是以XX省开头，也就是说前几个字符都是差不多的，而且收件地址进行检索一般都是like ’%xxx%’，不会用到前匹配。相反对外国人的姓名可以使用前缀索引，因为其字符较长，而且前几个字符的选择性比较高。同样电子邮件也是一个可以使用前缀索引的字段。</li>
<li>前一半字符的索引选择性就已经接近于全字段的索引选择性。如果整个字段的长度为20，索引选择性为0.9，而我们对前10个字符建立前缀索引其选择性也只有0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，没有太大的建前缀索引的必要了。</li>
</ul>

<h2 id="多列索引">多列索引</h2>

<p>所谓的多列索引，并不是指为多个列建立独立的索引，而是建立一个包含相关列的多列索引（联合索引）。
在一次查询中，MySQL只能使用一个索引，同时，若表中索引过多，会影响INSERT及UPDATE性能，简单说就是会影响数据写入性能。因为更新数据的同时，也要同时更新索引。
再者，建立多个独立单列索引，在进行查询时，数据库通常会进行索引合并（index merge）操作，这会耗费大量的计算资源，更优的做法是尽量去除索引合并，改为使用多列索引</p>

<h2 id="选择合适的顺序-b-tree">选择合适的顺序（B-Tree）</h2>

<p>使用多列索引时，也要注意索引的顺序问题，即需要注意最左匹配原则。
那么如何选取一个索引顺序，下面列举出所有可能有影响的条件：</p>

<ul>
<li>列的选择性</li>
<li>列的长度</li>
<li>排序和分组情况</li>
</ul>

<p>选取 <a href="https://segmentfault.com/q/1010000000342176">https://segmentfault.com/q/1010000000342176</a> 中的例子：</p>

<pre><code>对于联合索引（a,b,c)

优: select * from test where a=10 and b&gt;50 差: select * from test where
a50

优: select * from test order by a 差: select * from test order by b 差:
select * from test order by c

优: select * from test where a=10 order by a 优: select * from test
where a=10 order by b 差: select * from test where a=10 order by c

优: select * from test where a&gt;10 order by a 差: select * from test
where a&gt;10 order by b 差: select * from test where a&gt;10 order by c

优: select * from test where a=10 and b=10 order by a 优: select * from
test where a=10 and b=10 order by b 优: select * from test where a=10
and b=10 order by c

优: select * from test where a=10 and b=10 order by a 优: select * from
test where a=10 and b&gt;10 order by b 差: select * from test where a=10
and b&gt;10 order by c

</code></pre>

<h2 id="聚簇索引">聚簇索引</h2>

<p>聚簇索引并不是一种单独的索引类型，而是一种数据的存储方式，它的数据行实际上存放在索引的叶子页（leaf page）中，术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引，除此之外的表上的每个非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）。</p>

<pre><code>以InnoDB来说，每个InnoDB表具有一个特殊的索引称为聚集索引。如果您的表上定义有主键，该主键索引是聚集索引。
如果你不定义为您的表的主键时，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚集索引。
如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。
</code></pre>

<p>聚簇索引的使用优点：</p>

<ul>
<li>可以把相关数据保存在一起。因为数据和索引存放在一起，所以在读取时，只用读取少量的数据页就能获取某个用户的全部邮件</li>
<li>数据的访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点</li>
</ul>

<p>聚簇索引的使用缺点：</p>

<ul>
<li>聚簇索引最大限度提高了 I/O 密集型应用的性能，但是如果数据全部放在内存，就没必要用聚簇索引</li>
<li>插入速度严重依赖于插入顺序，按主键的顺序插入是最快的</li>
<li>更新操作代价很高，因为每个被更新的行都会移动到新的位置</li>
<li>当插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，页分裂会导致表占用更多的磁盘空间</li>
<li>如果行比较稀疏，或者由于页分裂导致数据存储不连续时，聚簇索引可能导致全表扫描速度变慢</li>
</ul>

<h2 id="覆盖索引-innodb">覆盖索引（innoDB）</h2>

<p>通常索引的添加方式，都是根据WHERE条件来进行创建合适的索引，不过这只是索引优化的一个方面，设计优秀的索引要考虑的方面要更多，对于其中的一个场景，如果索引的叶子节点中已经包含要查询的数据，那么还有什么必要再回表查询呢？
覆盖索引的定义，如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”
对于InnoDB而言，其二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询</p>

<pre><code>select * 不好的地方就在于，
一方面一般情况下不会用到所有的字段，会造成资源的浪费
另一方面去除了本可以使用覆盖索引大大提升效率的情况
</code></pre>

<h2 id="使用索引扫描来做排序">使用索引扫描来做排序</h2>

<p>MySQL有两种方式可以生成有序的结果： 通过排序操作，或者是通过索引顺序扫描</p>

<ul>
<li>只有当索引的列顺序和ORDER BY子句完全一致，并且所有列的排序方向（正序或倒序）都一样时，MySQL才能够使用索引来对结果做排序</li>
<li>如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序</li>
<li>ORDER BY子句和查找型查询的限制是一样的，需要满足索引的最左前缀的要求</li>
<li>前导列为常量的时候，即WHERE或JOIN子句中对这些列指定了常量，就可以“弥补”索引的不足</li>
</ul>

<pre><code>表结构：
CREATE TABLE rental{
    ...
    PRIMARY KEY(rental_id),
    UNIQUE KEY rental_date(rental_date, inventory_id, customer_id),
    KEY idx_fk_inventory_id(inventory_id),
    KEY idx_fk_customer_id(customer_id),
    KEY idx_fk_staff_id(staff_id),
    ...
};

查询语句：
EXPLAIN SELECT rental_id, staff_id FROM sakila.rental
-&gt; WHERE rental_date = '2005-05-5'
-&gt; ORDER BY inventory_id, customer_id

结果：
         type: ref
possible_keys: rental_date
          key: rental_date
         rows: 1
        extra: using where

</code></pre>

<h2 id="删除低质量的索引">删除低质量的索引</h2>

<p>所谓的低质量索引，是指那些冗余、重复、未使用的索引</p>

<ul>
<li>冗余的情况是指，如果已经有了联合索引（a，b），再建立独立索引a，索引a则是冗余的情况</li>
<li>重复的索引是指建立主键索引、唯一索引、普通索引里的两个或三个，实际MySQL里的唯一限制和主键限制都是依靠索引实现的，因此，再此基础上，再加索引，就会造成索引重复</li>
<li>未使用的索引可以通过两个工具来定位。一是打开Percona Server或MariaDB中的userstates服务器变量，运行一段时间后，再查询INFORMATION_SCHEMA.INDEX_STATISTICS追查每个索引的使用频率;二是通过Percona Toolkit中的pt-index-usage，该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操作，然后打印出关于索引和查询的报告</li>
</ul>

<h1 id="参考内容">参考内容</h1>

<ul>
<li>《高性能MySQL》</li>
<li>《深入浅出MySQL》</li>
<li><a href="https://blog.csdn.net/oChangWen/article/details/54024063">hash索引和B-Tree索引的区别</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/">https://dev.mysql.com/doc/refman/5.7/en/</a></li>
<li><a href="http://www.cnblogs.com/studyzy/p/4310653.html">http://www.cnblogs.com/studyzy/p/4310653.html</a></li>
<li><a href="https://tech.meituan.com/mysql-index.html">https://tech.meituan.com/mysql-index.html</a></li>
</ul>
    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">VGMDJ</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">2018-04-17 17:45:31</span>
  </p>
  
  
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/database/">database</a>
          
          <a href="/tags/mysql/">mysql</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/post/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">微信开发问题小结</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        
          <a class="next" href="/post/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF-%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/">
            <span class="next-text nav-default">程序员进化之路-技术提升</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'blog-vgmdj-cn';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:vgmdj.wr@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/vgmdj" class="iconfont icon-github" title="github"></a>
  <a href="https://blog.vgmdj.cn/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> 本站总访问量 <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 次 </span>
    <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> 本站总访客数 <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> 人 </span>
  </div>

  <span class="copyright-year">
    &copy; 
    
      2017 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">vgmdj</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>


<script type="text/javascript" src="/dist/even.min.js?v=3.2.0"></script>

<script id="baidu_analytics">
  var _hmt = _hmt || [];
  (function() {
    if (window.location.hostname === 'localhost') return;
    var hm = document.createElement("script"); hm.async = true;
    hm.src = "https://hm.baidu.com/hm.js?54c4a1219b45b912e867a23f5d8b675e";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

<script id="baidu_push">
  (function(){
    if (window.location.hostname === 'localhost') return;
    var bp = document.createElement('script'); bp.async = true;
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
      bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
      bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
  })();
</script>




</body>
</html>
