<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>设计模式 on vgmdj&#39;s blog</title>
    <link>https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
    <description>Recent content in 设计模式 on vgmdj&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <copyright>vgmdj</copyright>
    <lastBuildDate>Mon, 24 Sep 2018 16:29:48 +0000</lastBuildDate>
    
	<atom:link href="https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>设计模式学习-代理模式</title>
      <link>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 24 Sep 2018 16:29:48 +0000</pubDate>
      
      <guid>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;代理模式-proxy&#34;&gt;代理模式(Proxy)&lt;/h2&gt;

&lt;p&gt;代理模式，为其他对象提供一种代理以控制对这个对象的访问。&lt;/p&gt;

&lt;h2 id=&#34;主要类&#34;&gt;主要类&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;subjuct - interface 主体接口&lt;/li&gt;
&lt;li&gt;concreteSubject - 具体实现的主体&lt;/li&gt;
&lt;li&gt;proxy - 实现主体的代理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习-原型模式</title>
      <link>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 24 Sep 2018 16:29:48 +0000</pubDate>
      
      <guid>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;原型模式-prototype&#34;&gt;原型模式(Prototype)&lt;/h2&gt;

&lt;p&gt;原型模式，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
原型模式其实就是从一个对象再创建另一个可定制的对象，而且不需知道任何创建的细节。
需要注意的点是深拷贝和浅拷贝。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习-建造者模式</title>
      <link>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 20 Aug 2018 16:29:48 +0000</pubDate>
      
      <guid>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;建造者模式-builder&#34;&gt;建造者模式(Builder)&lt;/h2&gt;

&lt;p&gt;建造者模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;

&lt;h2 id=&#34;主要类&#34;&gt;主要类&lt;/h2&gt;

&lt;p&gt;builder - 对构建过程进行抽象的接口
director- 实际构建一个使用builder接口的对象&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习-装饰模式</title>
      <link>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 26 Jul 2018 18:03:47 +0000</pubDate>
      
      <guid>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;装饰模式-decorator&#34;&gt;装饰模式(Decorator)&lt;/h2&gt;

&lt;p&gt;装饰模式，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。
装饰模式是为已有功能动态地添加更多功能的一种方式。当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为，在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度，而这些新加往后东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。
装饰模式为此提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习-观察者模式</title>
      <link>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 24 Jul 2018 13:44:23 +0000</pubDate>
      
      <guid>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;观察者模式-observer&#34;&gt;观察者模式(Observer)&lt;/h2&gt;

&lt;p&gt;将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性，我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。
观察者模式所做的工作其实就是在解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体，从而使得各自的变化都不会影响另一边的变化。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Subject(主题)
观察者感兴趣的抽象主题，条件达成后，可对所属主题的观察者进行通知。需要提供注册、删除、通知观察者的接口&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ConcreSubject(具体主题)
用于存放各ConcreObserver对象&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Observer(观察者)
为那些在目标发生改时需获得通知的对象定义一个更新接口。当它的状态发生改变时，向它的各个观察者发出通知&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ConcreObserver(具体观察者)
维护一个指向ConcreSubject对象的引用。存储有关状态，这些状态应与目标的状态保持一致。实现Observer的更新接口以使自身的状态与目标的状态保持一致&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习-单例模式</title>
      <link>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Wed, 05 Jul 2017 16:25:23 +0000</pubDate>
      
      <guid>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;单例模式-singleton&#34;&gt;单例模式(Singleton)&lt;/h2&gt;

&lt;p&gt;保证同一个类全局只有一个实例对象
在第一次实例化后会使用静态变量保存实例，后续全局使用此静态变量
在多线程时应该考虑并发问题，防止两次调用都被判定为实例未初始化而重复初始化对象&lt;/p&gt;

&lt;p&gt;PS： 虽然单例简单，我们还是不能任性的用，因为这样做实例会一直存在内存中，一些我们用的不是那么频繁的东西使用了单例是不是就造成了内存的浪费？大家在用单例的时候还是要多思考思考，这个模块适不适合用单例！&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习-策略模式</title>
      <link>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Tue, 04 Jul 2017 16:25:23 +0000</pubDate>
      
      <guid>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;策略模式-strategy&#34;&gt;策略模式(Strategy)&lt;/h2&gt;

&lt;p&gt;策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习-抽象工厂模式</title>
      <link>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 03 Jul 2017 16:25:23 +0000</pubDate>
      
      <guid>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;抽象工厂模式-abstract-factory&#34;&gt;抽象工厂模式(Abstract Factory)&lt;/h2&gt;

&lt;p&gt;工厂模式是对象的生产器，解耦用户对具体对象的依赖。
提供一个创建一系列相关或相互依赖的接口，而无需指定它们具体的类&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习-工厂方法模式</title>
      <link>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sun, 02 Jul 2017 16:25:23 +0000</pubDate>
      
      <guid>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;工厂方法模式-factory-method&#34;&gt;工厂方法模式(Factory Method)&lt;/h2&gt;

&lt;p&gt;工厂模式是对象的生产器，解耦用户对具体对象的依赖。
定义了一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。&lt;/p&gt;

&lt;h2 id=&#34;资料推荐&#34;&gt;资料推荐&lt;/h2&gt;

&lt;p&gt;书籍：《大话设计模式》，《设计模式之禅》
golang相关实现例子:  &lt;a href=&#34;https://github.com/vgmdj/go_practice/tree/master/design_pattern&#34;&gt;https://github.com/vgmdj/go_practice/tree/master/design_pattern&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习-简单工厂模式</title>
      <link>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Sat, 01 Jul 2017 18:39:52 +0000</pubDate>
      
      <guid>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>&lt;h2 id=&#34;简单工厂模式-simple-factory&#34;&gt;简单工厂模式(Simple Factory)&lt;/h2&gt;

&lt;p&gt;工厂模式是对象的生产器，解耦用户对具体对象的依赖。
通过封闭、继承、多态把程序的耦合度降低，使程序更加的灵活，容易修改，并易于复用。
简单工厂模式中，各种运算方法类实现了运算接口，在业务上如果想添加一种运算方法，只需要增加一个实现运算接口的类，并且在工厂类中添加一个类型判断。
这种设计适合于业务类型并不是很多的情况，如果业务类型非常多，那么在工作类中就会有一个很长的switch&amp;hellip;case结构，这时候使用工厂方法模式会比较合适。&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习-设计原则</title>
      <link>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</link>
      <pubDate>Sat, 01 Jul 2017 14:50:28 +0000</pubDate>
      
      <guid>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</guid>
      <description>&lt;h1 id=&#34;设计模式原则&#34;&gt;设计模式原则&lt;/h1&gt;

&lt;p&gt;每个设计模式的都是为了解决一些实际开发中的问题而被设计出来，在设计的过程中，一般都会遵循以下这些原则&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>设计模式学习-总览</title>
      <link>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E8%A7%88/</link>
      <pubDate>Sat, 01 Jul 2017 14:39:52 +0000</pubDate>
      
      <guid>https://blog.vgmdj.cn/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E8%A7%88/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;

&lt;p&gt;本文主要是将书中资源整理总结，用于分享和回顾复习，如有错误或更好见解，请留言&lt;/p&gt;

&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://blog.vgmdj.cn/tags/设计模式/&#34;&gt;https://blog.vgmdj.cn/tags/设计模式/&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;资料推荐&#34;&gt;资料推荐&lt;/h2&gt;

&lt;p&gt;书籍：《大话设计模式》，《设计模式之禅》
golang相关实现例子:  &lt;a href=&#34;https://github.com/vgmdj/go_practice/tree/master/design_pattern&#34;&gt;https://github.com/vgmdj/go_practice/tree/master/design_pattern&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>