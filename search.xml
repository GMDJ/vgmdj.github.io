<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>程序员进化之路-技术提升</title>
      <link href="/2018/03/31/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF-%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>要想快速进步，一个明确的大目标和一个个细化的小目标是必不可少的，经历了一段时间的探索，目前来讲，职业发展的规划很简单，紧抱google大腿，以go为开发语言，在后端领域扑腾。<br>那么要提升的东西也就很明确了<br><a id="more"></a></p><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="数据结构-算法"><a href="#数据结构-算法" class="headerlink" title="数据结构 + 算法"></a>数据结构 + 算法</h3><ul><li>leetcode</li><li>lintcode</li><li>poj</li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>书籍：<ul><li>《鸟哥的linux私房菜》</li></ul></li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li>书籍：<ul><li>《计算机网络-自顶向下》</li><li>《http权威指南》</li></ul></li></ul><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><h3 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h3><ul><li>书籍：<ul><li>《go语言学习笔记》</li><li>《go并发编程实战》</li></ul></li></ul><h3 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h3><ul><li>并发处理模型</li><li>gc原理</li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="基本设计"><a href="#基本设计" class="headerlink" title="基本设计"></a>基本设计</h3><h3 id="性能优化-分库分表"><a href="#性能优化-分库分表" class="headerlink" title="性能优化 + 分库分表"></a>性能优化 + 分库分表</h3><h3 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h3><h3 id="基本操作-mysql-redis-mongodb"><a href="#基本操作-mysql-redis-mongodb" class="headerlink" title="基本操作 mysql + redis/mongodb"></a>基本操作 mysql + redis/mongodb</h3><ul><li>书籍：<ul><li>高性能mysql</li><li>redis blog</li></ul></li></ul><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><ul><li>rabbitmq</li><li>zookper</li></ul><h2 id="架构能力"><a href="#架构能力" class="headerlink" title="架构能力"></a>架构能力</h2><h3 id="soa架构"><a href="#soa架构" class="headerlink" title="soa架构"></a>soa架构</h3><h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><h3 id="高并发问题处理"><a href="#高并发问题处理" class="headerlink" title="高并发问题处理"></a>高并发问题处理</h3><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul><li>书籍：<ul><li>《大话设计模式》</li><li>《设计模式之禅》</li></ul></li></ul><h2 id="基础工具"><a href="#基础工具" class="headerlink" title="基础工具"></a>基础工具</h2><h3 id="git"><a href="#git" class="headerlink" title="git"></a>git</h3><ul><li><a href="https://github.com/livoras/blog/issues/7#issue-105082853" target="_blank" rel="noopener">https://github.com/livoras/blog/issues/7#issue-105082853</a></li></ul>]]></content>
      
      <categories>
          
          <category> 职业发展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职业发展 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go语言学习-map</title>
      <link href="/2018/03/30/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-map/"/>
      <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>go版本 1.10<br><a id="more"></a></p><h2 id="HashMap和HashTable"><a href="#HashMap和HashTable" class="headerlink" title="HashMap和HashTable"></a>HashMap和HashTable</h2><p>线性表中，数组查询方便，链表插入、删除方便，而HashTable则是结合了两者的优点，使得在所有操作上都是 O(1) 的时间复杂度，效率非常高<br>HashMap是基于HashTable的 Map 接口的实现，其去掉了线程同步的操作，因而效率要更高一些，所以说HashTable是线程安全的，而HashMap则非线程安全。<br>go语言中的map类型就是使用的HashMap,即go中的map非线程安全，不能放在多个goroutine中，只能自己维护线程安全<br><!--more--></p><h2 id="go-map一般操作"><a href="#go-map一般操作" class="headerlink" title="go map一般操作"></a>go map一般操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建map</span><br><span class="line">a := make(map[string]string)</span><br><span class="line">//存入</span><br><span class="line">a[&quot;first&quot;] = &quot;first&quot;</span><br><span class="line">//读取</span><br><span class="line">fmt.Println(a[&quot;first&quot;])</span><br></pre></td></tr></table></figure><p>需要注意的是，并不是所有的类型都可以作为key值，在Go的语言规范中已精确定义，只有能比较是否相等的类型才可以作为key值，key的类型可以是：</p><ul><li>布尔值</li><li>数字</li><li>字符串</li><li>指针</li><li>通道</li><li>接口类型</li><li>结构体</li></ul><p>只包含上述类型的数组。<br>不能是：</p><ul><li>slice</li><li>map</li><li>function<br>Key类型只要能支持==和!=操作符，即可以做为Key，当两个值==时，则认为是同一个Key。</li></ul><h2 id="go-map并发线程操作"><a href="#go-map并发线程操作" class="headerlink" title="go map并发线程操作"></a>go map并发线程操作</h2><ul><li><p>结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var counter = struct&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m map[string]int</span><br><span class="line">&#125;&#123;m: make(map[string]int)&#125;</span><br></pre></td></tr></table></figure></li><li><p>读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">counter.RLock()</span><br><span class="line">n := counter.m[&quot;some_key&quot;]</span><br><span class="line">counter.RUnlock()</span><br><span class="line">fmt.Println(&quot;some_key:&quot;, n)</span><br></pre></td></tr></table></figure></li><li><p>写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">counter.Lock()</span><br><span class="line">counter.m[&quot;some_key&quot;]++</span><br><span class="line">counter.Unlock()</span><br></pre></td></tr></table></figure></li></ul><h2 id="go-map的遍历"><a href="#go-map的遍历" class="headerlink" title="go map的遍历"></a>go map的遍历</h2><p>go语言中map存放是无序的，即如果对一个map进行输出，其并不会按照输入的顺序，而是随机的<br>那么如果想要实现map的一个有序的输出，就需要指定一组确立顺序的key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &quot;sort&quot;</span><br><span class="line"></span><br><span class="line">var m map[int]string</span><br><span class="line">var keys []int</span><br><span class="line">for k := range m &#123;</span><br><span class="line">    keys = append(keys, k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Ints(keys)</span><br><span class="line">for _, k := range keys &#123;</span><br><span class="line">    fmt.Println(&quot;Key:&quot;, k, &quot;Value:&quot;, m[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="go-map结构"><a href="#go-map结构" class="headerlink" title="go map结构"></a>go map结构</h2><p>map实现可在/runtime/hashmap.go里查看</p><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// A header for a Go map.</span><br><span class="line">type hmap struct &#123;</span><br><span class="line">// Note: the format of the Hmap is encoded in ../../cmd/internal/gc/reflect.go and</span><br><span class="line">// ../reflect/type.go. Don&apos;t change this structure without also changing that code!</span><br><span class="line">count     int // # live cells == size of map.  Must be first (used by len() builtin)</span><br><span class="line">flags     uint8</span><br><span class="line">B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span><br><span class="line">noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details</span><br><span class="line">hash0     uint32 // hash seed</span><br><span class="line"></span><br><span class="line">buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.</span><br><span class="line">oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing</span><br><span class="line">nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)</span><br><span class="line"></span><br><span class="line">extra *mapextra // optional fields</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>count 提供给len()使用，用来记录map的大小，可以统计kv对的个数</li><li>B map的容量，表示当前可以放入 loadFactor * 2^B 个item，2^B 即为buckets的数量</li><li>buckets 桶，指向实际存储空间</li><li>oldbuckets 只有在扩容时使用，其余情况下为空。如果当前哈希表正在扩容中，则oldbuckets不为空，并且buckets大小是oldbuckets大小的两倍。</li><li>noverflow 溢出桶的大小</li></ul><p>由注释我们可以看到，这是Go map的header，map类型就是一个hash表的结构，数据被发放进buckets数组中，每个bucket包含有8个键值对，当溢出时，将再生成一个bucket，并将之链接到之前的bucket上</p><h3 id="bucket"><a href="#bucket" class="headerlink" title="bucket"></a>bucket</h3><p>这里是map中每个bucket的结构，可以看出，是一个 8个单位长度的uint8数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// A bucket for a Go map.</span><br><span class="line">type bmap struct &#123;</span><br><span class="line">// tophash generally contains the top byte of the hash value</span><br><span class="line">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span><br><span class="line">// tophash[0] is a bucket evacuation state instead.</span><br><span class="line">tophash [bucketCnt]uint8</span><br><span class="line">// Followed by bucketCnt keys and then bucketCnt values.</span><br><span class="line">// NOTE: packing all the keys together and then all the values together makes the</span><br><span class="line">// code a bit more complicated than alternating key/value/key/value/... but it allows</span><br><span class="line">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span><br><span class="line">// Followed by an overflow pointer.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>bucketCnt 定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const(</span><br><span class="line">  // Maximum number of key/value pairs a bucket can hold.</span><br><span class="line">  bucketCntBits = 3</span><br><span class="line">  bucketCnt     = 1 &lt;&lt; bucketCntBits</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>可以从tophash的注释中看出，这里的key value存入顺序，不是key/value/key/value/… ， 而是key/key/key/key/value/value/value/value，这是因为考虑到map[int64]int8这种情况，存在64和8两种大小，考虑到字节对齐，会浪费很多存储空间</p><h2 id="map-操作解析"><a href="#map-操作解析" class="headerlink" title="map 操作解析"></a>map 操作解析</h2><h3 id="确定buckets"><a href="#确定buckets" class="headerlink" title="确定buckets"></a>确定buckets</h3><p>hash表的bucket确定方式，一般为key值求hash后，用hash值对总的buckets数取余，即hash mod (2^B)，可优化为以下操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// bucketShift returns 1&lt;&lt;b, optimized for code generation.</span><br><span class="line">func bucketShift(b uint8) uintptr &#123;</span><br><span class="line">if sys.GoarchAmd64|sys.GoarchAmd64p32|sys.Goarch386 != 0 &#123;</span><br><span class="line">b &amp;= sys.PtrSize*8 - 1 // help x86 archs remove shift overflow checks</span><br><span class="line">&#125;</span><br><span class="line">return uintptr(1) &lt;&lt; b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bucketMask returns 1&lt;&lt;b - 1, optimized for code generation.</span><br><span class="line">func bucketMask(b uint8) uintptr &#123;</span><br><span class="line">return bucketShift(b) - 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h *hmap</span><br><span class="line">hash % (1 &lt;&lt; h.B)</span><br><span class="line">=&gt; hash &amp; bucketMask(h.B)</span><br></pre></td></tr></table></figure></p><h3 id="增量扩容"><a href="#增量扩容" class="headerlink" title="增量扩容"></a>增量扩容</h3><p>为什么会增量扩容呢？主要是缩短map容器的响应时间。假如我们直接将map用作某个响应实时性要求非常高的web应用存储，如果不采用增量扩容，当map里面存储的元素很多之后，扩容时系统就会卡往，导致较长一段时间内无法响应请求。不过增量扩容本质上还是将总的扩容时间分摊到了每一次哈希操作上面。<br>扩容会建立一个大小是原来2倍的新的表，将旧的bucket搬到新的表中之后，并不会将旧的bucket从oldbucket中删除，而是加上一个已删除的标记。<br>正是由于这个工作是逐渐完成的，这样就会导致一部分数据在old table中，一部分在new table中， 所以对于hash table的insert, remove, lookup操作的处理逻辑产生影响。只有当所有的bucket都从旧表移到新表之后，才会将oldbucket释放掉。<br>扩容的填充因子是多少呢？如果grow的太频繁，会造成空间的利用率很低， 如果很久才grow，会形成很多的overflow buckets，查找的效率也会下降。 这个平衡点如何选取呢(在go中，这个平衡点是有一个宏控制的(#define LOAD 6.5), 它的意思是这样的，如果table中元素的个数大于table中能容纳的元素的个数， 那么就触发一次grow动作。那么这个6.5是怎么得到的呢？原来这个值来源于作者的一个测试程序，遗憾的是没能找到相关的源码，不过作者给出了测试的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Maximum average load of a bucket that triggers growth is 6.5.</span><br><span class="line">// Represent as loadFactorNum/loadFactDen, to allow integer math.</span><br><span class="line">loadFactorNum = 13</span><br><span class="line">loadFactorDen = 2</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Picking loadFactor: too large and we have lots of overflow</span><br><span class="line">buckets, too small and we waste a lot of space. I wrote</span><br><span class="line">a simple program to check some stats for different loads:</span><br><span class="line">(64-bit, 8 byte keys and values)</span><br><span class="line">loadFactor    %overflow  bytes/entry     hitprobe    missprobe</span><br><span class="line">      4.00         2.13        20.77         3.00         4.00</span><br><span class="line">      4.50         4.05        17.30         3.25         4.50</span><br><span class="line">      5.00         6.85        14.77         3.50         5.00</span><br><span class="line">      5.50        10.55        12.94         3.75         5.50</span><br><span class="line">      6.00        15.27        11.67         4.00         6.00</span><br><span class="line">      6.50        20.90        10.79         4.25         6.50</span><br><span class="line">      7.00        27.14        10.15         4.50         7.00</span><br><span class="line">      7.50        34.03         9.73         4.75         7.50</span><br><span class="line">      8.00        41.10         9.40         5.00         8.00</span><br><span class="line"></span><br><span class="line">%overflow   = percentage of buckets which have an overflow bucket</span><br><span class="line">bytes/entry = overhead bytes used per key/value pair</span><br><span class="line">hitprobe    = # of entries to check when looking up a present key</span><br><span class="line">missprobe   = # of entries to check when looking up an absent key</span><br><span class="line"></span><br><span class="line">Keep in mind this data is for maximally loaded tables, i.e. just</span><br><span class="line">before the table grows. Typical tables will be somewhat less loaded.</span><br></pre></td></tr></table></figure><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">未完待续</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器安全防护</title>
      <link href="/2018/03/27/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4/"/>
      <content type="html"><![CDATA[<h2 id="服务器安全"><a href="#服务器安全" class="headerlink" title="服务器安全"></a>服务器安全</h2><p>一段时间没去打理我的服务器，只是搭个ss，当科学工具用，今天忽然收到服务商的电话，说是服务器上存在不合法行为，还吓我一跳，觉着现在都查这么严格了吗，实际后面上管理平台一看，才知道是服务器被当成肉鸡，不停的攻击别的机器，总计被监测到400多万次行为，看来当真是有挺长一段时间没管理了。。。<br><a id="more"></a></p><h2 id="主要被攻击方式"><a href="#主要被攻击方式" class="headerlink" title="主要被攻击方式"></a>主要被攻击方式</h2><p>从日志中可以看到，应该主要是扫描加暴力破解的方式，所以理所当然的应对手段就是，开启防火墙，改ssh端口，改mysql端口，开启安全组，之前是觉着被攻击的机率太低了，现在看来，再低机率也不应该懈怠<br><!--more--></p><h2 id="开启防火墙"><a href="#开启防火墙" class="headerlink" title="开启防火墙"></a>开启防火墙</h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>防火墙开启后，应该先打开相应端口</li><li>一旦出现问题，可以使用页面版的远程登录，进行逆操作恢复<!--more--></li></ul><h3 id="ubuntu默认支持ufw防火墙"><a href="#ubuntu默认支持ufw防火墙" class="headerlink" title="ubuntu默认支持ufw防火墙"></a>ubuntu默认支持ufw防火墙</h3><ul><li><p>开关服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw enable</span><br><span class="line"></span><br><span class="line">关闭命令</span><br><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure></li><li><p>开关端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启 8080端口</span><br><span class="line">sudo ufw allow 53</span><br><span class="line"></span><br><span class="line">关闭 8080端口</span><br><span class="line">sudo ufw deny 8080</span><br></pre></td></tr></table></figure></li></ul><h3 id="CentOS-7-0默认使用的是firewall作为防火墙"><a href="#CentOS-7-0默认使用的是firewall作为防火墙" class="headerlink" title="CentOS 7.0默认使用的是firewall作为防火墙"></a>CentOS 7.0默认使用的是firewall作为防火墙</h3><ul><li><p>开关服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开启</span><br><span class="line">sudo systemctl start firewalld.service</span><br><span class="line"></span><br><span class="line">关闭</span><br><span class="line">sudo systemctl stop firewalld.service</span><br><span class="line"></span><br><span class="line">禁用</span><br><span class="line">sudo systemctl disable firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>开关端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看状态</span><br><span class="line">sudo firewall-cmd --state</span><br><span class="line"></span><br><span class="line">查看端口</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"></span><br><span class="line">开放端口</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line">删除端口</span><br><span class="line">firewall-cmd --zone= public --remove-port=80/tcp --permanent</span><br></pre></td></tr></table></figure></li><li><p>更新状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure></li></ul><h3 id="如果想使用iptables作为防火墙，需要配置一下"><a href="#如果想使用iptables作为防火墙，需要配置一下" class="headerlink" title="如果想使用iptables作为防火墙，需要配置一下"></a>如果想使用iptables作为防火墙，需要配置一下</h3><ul><li>服务切换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service #停止firewall</span><br><span class="line"></span><br><span class="line">systemctl disable firewalld.service #禁止firewall开机启动</span><br><span class="line"></span><br><span class="line">systemctl restart iptables.service #重启防火墙使配置生效</span><br><span class="line"></span><br><span class="line">systemctl enable iptables.service #设置防火墙开机启动</span><br><span class="line"></span><br><span class="line">最后重启系统使设置生效即可</span><br></pre></td></tr></table></figure><ul><li><p>服务开关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启</span><br><span class="line">service iptables start</span><br><span class="line"></span><br><span class="line">关闭</span><br><span class="line">service iptables stop</span><br></pre></td></tr></table></figure></li><li><p>永久开关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">永久关闭防火墙:</span><br><span class="line"></span><br><span class="line">chkconfig iptables off</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">永久关闭后启用:</span><br><span class="line">chkconfig iptables on</span><br></pre></td></tr></table></figure></li></ul><h2 id="修改ssh端口号"><a href="#修改ssh端口号" class="headerlink" title="修改ssh端口号"></a>修改ssh端口号</h2><ul><li><p>修改/etc/ssh/sshd_config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">去掉端口注释，并添加新端口</span><br><span class="line"># Port 22</span><br><span class="line">Port 222</span><br></pre></td></tr></table></figure></li><li><p>重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/sshd restart</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 222 ip</span><br></pre></td></tr></table></figure></li></ul><h2 id="修改mqsql端口"><a href="#修改mqsql端口" class="headerlink" title="修改mqsql端口"></a>修改mqsql端口</h2><p>docker run 时-p 映射时改一下</p><h2 id="修改安全组策略"><a href="#修改安全组策略" class="headerlink" title="修改安全组策略"></a>修改安全组策略</h2><p>可根据服务商进行选择</p>]]></content>
      
      <categories>
          
          <category> 站点建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql学习-事务</title>
      <link href="/2018/03/22/mysql%E5%AD%A6%E4%B9%A0-%E4%BA%8B%E5%8A%A1/"/>
      <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>事务(transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。同时，事务也是恢复和并发控制的基本单位。<br><a id="more"></a></p><h2 id="事务的四大特性-acid"><a href="#事务的四大特性-acid" class="headerlink" title="事务的四大特性(acid)"></a>事务的四大特性(acid)</h2><ul><li><p>原子性(atomicity)<br>　原子性是指事务包含的所有操作要么全部操作，要么全部不做，事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p></li><li><p>一致性(consistency)<br>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性</p></li><li><p>隔离性(isolation)<br>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p></li><li><p>持久性(durability)<br>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><!--more--></li></ul><h2 id="区分数据库的原子性和一致性"><a href="#区分数据库的原子性和一致性" class="headerlink" title="区分数据库的原子性和一致性"></a>区分数据库的原子性和一致性</h2><p>如果从逻辑设计上，A转账给B 1000元，那么A扣1000,B加1000，这个转账操作起码要有两个事务：<br>1、查A现有账户，然后扣1000,更新A账户（A=A-1000）<br>2、查B现有账户，然后加1000,更新B账户 (B=B+1000)</p><p>原子性是说，如果提交时，1,2都操作了，要么成功，要么失败回滚<br>一致性是说，如果操作了，但没有提交时系统崩溃，此时原子性满足了，但处于不一致的状态（只有事务的开始，没有事务的结束），所以要进行回滚，回退到上一个一致性的状态</p><!--more--><h2 id="并发下事务可能出现的问题"><a href="#并发下事务可能出现的问题" class="headerlink" title="并发下事务可能出现的问题"></a>并发下事务可能出现的问题</h2><p>在多个事务并发做数据库操作的时候，如果没有有效的避免机制，就会出现种种问题。</p><ul><li><p>1、丢失更新<br>两个不同事务同时获得相同数据，然后在各自事务中同时修改了该数据，那么先提交的事务更新会被后提交事务的更新给覆盖掉，那么先提交的更新就会被丢失掉</p></li><li><p>2、脏读（未提交读）<br>事务A读取了未提交的数据，事务B的回滚，导致了事务A的数据不一致，导致了事务A的脏读</p></li><li><p>3、不可重复读<br>一个事务在自己没有更新数据库数据的情况，同一个查询操作执行两次或多次的结果应该是一致的；如果不一致，就说明为不可重复读。<br>如果事务A读取第一次后，事务B对数据进行修改并提交，事务A再次读取后，数据就会不一致</p></li><li><p>4 幻读（Phantom Read）<br>事务A读的时候读出了15条记录，事务B在事务A执行的过程中增加了1条，事务A再读的时候就变成了16条，这种情况就叫做幻影读。<br>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p></li></ul><h2 id="事务的四大隔离等级"><a href="#事务的四大隔离等级" class="headerlink" title="事务的四大隔离等级"></a>事务的四大隔离等级</h2><ul><li><p>Read uncommitted (未提交读)：最低级别，任何情况都无法保证<br>如果一个事务已经开始写数据，则另外一个事务不能同时进行写操作，但允许其他事务读此行数据。即事务中的修改，即使没有提交，对其他事务也都是可见的。<br>这样就避免了更新丢失，却可能出现脏读，因为修改的事务也许在提交前还会有其他的很多修改，所以另一个事务的数据读取会错乱。<br>从性能上讲，read uncommitted并没有比其他的三个级别好太多，但却缺少其他隔离级别带来的好处，所以除非是有真的要使用的理由，在实际应用中一般不使用。</p></li><li><p>Read committed (提交读)：可避免脏读的发生<br>一个事务开始时，只能读到已经提交的事务所做的修改。即，一个事务在开始到提前之前所做的修改，对其他事务而言，都是不可见的。<br>该隔离级别避免了脏读，但是却可能出现不可重复读，即两个事务同时开启，事务A读取数据后，事务B对数据进行修改后提交，事务A再次读取，会发现跟前一次读取的内容不一样了<br>read committed, 也被称为 unrepeatable read是大多数数据库默认的隔离级别</p></li><li><p>Repeatable read (可重复读)：可避免脏读、不可重复读的发生<br>同一个事务多次读取的同一个记录，结果是一样的。这时读取的应该是一开始保留下来的快照。<br>读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。这样避免了不可重复读取和脏读，但是有时可能出现幻象读。<br>repeatable read 是mysql的默认隔离级别</p></li><li><p>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生<br>两个事务完全独立，其中一个事务做的操作，对于另外一个事务不产生任何影响<br>数据库事务加了锁，所有事务串行执行，避免了上述所有问题，但是性能上影响很大</p></li></ul><h2 id="隔离级别的例子"><a href="#隔离级别的例子" class="headerlink" title="隔离级别的例子"></a>隔离级别的例子</h2><p>现在有一个数据项X，执行以下操作<br>1、事务B一直对其进行读操作<br>2、事务A将其从1依次改到10<br>3、事务C将其从10依次改到20<br>4、事务B结束读操作</p><p>那么不同隔离级别下，去除重复值后，B所能看到的为：</p><ul><li>read uncommitted下： 1～20</li><li>read committed下: 1,10,20</li><li>repeatable read下： 1</li><li>serializable下： 因B操作未提交，所以无法按照以上顺序执行</li></ul><p>总的来说，事务隔离级别越高，越能保证数据的完整性和一致性，但是付出的代价却是并发的性能</p><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>被加锁的对象可以被持锁事务读取，但是不能被修改，其他事务也可以在上面再加共享锁。</p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>被加锁的对象只能被持有锁的事务读取和修改，其他事务无法在该对象上加其他锁，也不能读取和修改该对象</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>应用层面的并发控制方式<br>每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>应用层面的并发控制方式<br>每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁</p><p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适</p><h2 id="mvcc"><a href="#mvcc" class="headerlink" title="mvcc"></a>mvcc</h2><p>Multiversion concurrency control 即多版本并发控制，乐观锁的一种实现，一般使用时间戳或版本号来标识一次修改，在修改时，验证之前是否已有其他修改提交</p><table><thead><tr><th>事务A</th><th style="text-align:center">事务B</th><th style="text-align:right">备注</th></tr></thead><tbody><tr><td>start transaction;</td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td>select a,version from test where id=1;</td><td style="text-align:center"></td><td style="text-align:right">a=0, version=0</td></tr><tr><td></td><td style="text-align:center">update test set a=1, version=1 where id=1;</td><td style="text-align:right">a=1, version=1</td></tr><tr><td>update test set a=2 where version=0;</td><td style="text-align:center"></td><td style="text-align:right">发现冲突，更新失败</td></tr><tr><td>rollback</td><td style="text-align:center"></td><td style="text-align:right"></td></tr></tbody></table><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个事务需求的资源被对方所持有，进入了相互等待状态</p><ul><li>T1时 事务A锁定a，事务B锁定b</li><li>T2时 事务A执行锁定b，但被事务B持有，进入等待<pre><code>事务B执行锁定a，但被事务A持有，进入等待</code></pre></li><li>形成死锁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">事务A</span><br><span class="line">start transaction</span><br><span class="line">update a</span><br><span class="line">update b</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">事务B</span><br><span class="line">start transaction</span><br><span class="line">update b</span><br><span class="line">update a</span><br><span class="line">commit</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql学习-总览</title>
      <link href="/2018/03/21/mysql%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/"/>
      <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数据库(Database,简称DB): 长期存储在计算机内、有组织的、可共享的大量数据的集合<br>数据库管理系统(Database Management System，简称DBMS)： 位于用户与操作系统之间的一层数据管理软件，是一个大型复杂的软件系统，mysql就是一个开源的RDBMS<br><a id="more"></a></p><h2 id="书籍推荐："><a href="#书籍推荐：" class="headerlink" title="书籍推荐："></a>书籍推荐：</h2><p>《高性能mysql》、《mongodb大数据处理权威指南》<br><!--more--></p><h2 id="分类与区别"><a href="#分类与区别" class="headerlink" title="分类与区别"></a>分类与区别</h2><h3 id="关系型数据库优缺点"><a href="#关系型数据库优缺点" class="headerlink" title="关系型数据库优缺点"></a>关系型数据库优缺点</h3><p>采用关系模型来组织数据的数据库<br>优点：</p><ul><li>可以通过事务来保证数据的一致性，对于安全性能很高的数据访问要求得以实现</li><li>通过sql语句，可以方便的在一个或多个表之间作复杂的数据查询</li></ul><p>缺点：</p><ul><li>与非关系型数据库相比，读写性能较差</li><li>难以进行水平扩展<!--more--></li></ul><h3 id="非关系型数据库优缺点"><a href="#非关系型数据库优缺点" class="headerlink" title="非关系型数据库优缺点"></a>非关系型数据库优缺点</h3><p>优点：</p><ul><li>基于键值对，不需要sql的筛选，读写性能很高</li><li>因基于键值对，数据之间没有耦合性，易于水平扩展</li></ul><p>缺点：</p><ul><li>不支持事务，无法保证数据的一致性</li><li>难以应对关系复杂的情况</li></ul><h2 id="go的orm"><a href="#go的orm" class="headerlink" title="go的orm"></a>go的orm</h2><ul><li>xorm<ul><li>源码地址： <a href="https://github.com/jinzhu/gorm" target="_blank" rel="noopener">https://github.com/jinzhu/gorm</a></li><li>首页地址： <a href="http://gorm.io/" target="_blank" rel="noopener">http://gorm.io/</a></li></ul></li><li>gorm<ul><li>源码地址： <a href="https://github.com/go-xorm/xorm" target="_blank" rel="noopener">https://github.com/go-xorm/xorm</a></li><li>首页地址： <a href="http://xorm.io/" target="_blank" rel="noopener">http://xorm.io/</a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络学习(四)-页面的请求过程</title>
      <link href="/2018/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
      <content type="html"><![CDATA[<p>我们在学校上网时一次网页请求的过程是什么呢?<br><a id="more"></a></p><p>首先将电脑用一条以太网网线连到以太网交换机, 这个交换机连到学校的路由器,该路由器再连到ISP(Internet Service Provider), 就是电信等公司, 电信会提供DNS域名解析服务.<br><!--more--></p><p>当电脑刚刚连上网络的时候, 需要运行DHCP协议从本地的DHCP服务器来得到一个IP地址。<br><!--more--></p><p>电脑创建一个DHCP request message, 放到一个UDP段里面, 这个段还包含目标端口(DHCP server)和来源端口(DHCP client). 这个UDP段会放到一个IP数据报里面, 这个包的目标IP地址是广播地址(255.255.255.255), 来源地址是0.0.0.0.<br><!--more--></p><p>IP数据报放在一个Ethernet frame里, 这个以太网帧的目标地址是FF:FF:FF:FF:FF:FF所以该帧会被广播到所有连接在该交换机的设备,该帧的来源MAC地址是电脑的物理地址.</p><p>当DHCP服务器收到这个IP数据报后,就会分配一个IP地址. 创建一个包含该IP地址和DNS地址的DHCP ACK message, 发回到我们的电脑.</p><p>有了IP地址后就可以上网了。在浏览器上输入URL <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>, 浏览器会首先创建一个TCP socket, 然后通过TCP socket发送HTTP请求。 为了创建TCP socket我们首先要知道 <a href="http://www.google.com的IP地址，" target="_blank" rel="noopener">www.google.com的IP地址，</a> 该地址由DNS协议得到。</p><p>操作系统创建了一个DNS query message, 放进一个目标端口为53（DNS服务器）的UDP段里面， 这个UDP段放进以DNS server IP的为目标的IP数据报里。</p><p>包含该IP数据报的Ethernet frame会发往学校的网关路由器。尽管我们的电脑知道学校网关的IP地址，但是它不知道网关路由器的MAC地址， 这个时候就需要用到 ARP 协议。</p><p>电脑创建一个包含网关IP地址的ARP query message， 把它放进目标地址为广播地址FF:FF:FF:FF:FF:FF的以太网帧里面。 交换机会把这个帧发送到所有连接的设备，包括网关路由器。</p><p>网关路由器发现这个DNS query message的目标IP是自己，则创建一个ARP reply, 把自己的MAC地址发送回去。 操作系统得到网关的MAC地址后， 就可以发送DNS query了。</p><p>网关路由器拿到DNS query, 查看它的目标地址，根据forwading table决定传递到哪一个路由器去。IP数据报被放进链接层的帧里面。</p><p>拿到该链接层帧的路由器再根据它的forwading table转发，该forwarding table由Internet’s intera-domain protocal(如 RIP, OSPF, IS-IS, BGP)维护。</p><p>最后DNS server查询DNS query里的网址，得到对应的IP， 发送回我们的电脑。</p><p>得到<a href="http://www.google.com的IP地址后，我们就可以创建TCP" target="_blank" rel="noopener">www.google.com的IP地址后，我们就可以创建TCP</a> socket了。 首先TCP要进行三次握手连接到80端口， 然后发送HTTP GET。</p><p>Google的服务器读取HTTP GET讯息，返回包含网页内容的HTTP response. 我们的电脑就可以展示其中的内容了。</p>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络学习(三)-socket套接字分析</title>
      <link href="/2018/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E4%B8%89-socket%E5%A5%97%E6%8E%A5%E5%AD%97%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="TCP实验："><a href="#TCP实验：" class="headerlink" title="TCP实验："></a>TCP实验：</h2><h3 id="TCP客户端套接字程序"><a href="#TCP客户端套接字程序" class="headerlink" title="TCP客户端套接字程序"></a>TCP客户端套接字程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">class TCPClient&#123;</span><br><span class="line">  public static void main(String argv[]) throws Exception</span><br><span class="line">  &#123;</span><br><span class="line">     String sentence;</span><br><span class="line">     String modifiedSentence;</span><br><span class="line">     BufferedReader inFromUser =</span><br><span class="line">        new BufferedReader(</span><br><span class="line">              new InputStreamReader(System.in));</span><br><span class="line">     Socket ClientSocket = new Socket(&quot;222.194.1.36&quot;,6789);</span><br><span class="line">     DataOutputStream outToServer =</span><br><span class="line">        new DataOutputStream(</span><br><span class="line">              ClientSocket.getOutputStream());</span><br><span class="line">     BufferedReader inFromServer =</span><br><span class="line">        new BufferedReader(new InputStreamReader(</span><br><span class="line">               ClientSocket.getInputStream()));</span><br><span class="line">     sentence =inFromUser.readLine();</span><br><span class="line">     outToServer.writeBytes(sentence + &apos;\n&apos;);</span><br><span class="line">     modifiedSentence = inFromServer.readLine();</span><br><span class="line">     System.out.println(&quot;FROM SERVER:&quot;+</span><br><span class="line">                           modifiedSentence);</span><br><span class="line">     ClientSocket.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="TCP服务器端套接字程序"><a href="#TCP服务器端套接字程序" class="headerlink" title="TCP服务器端套接字程序"></a>TCP服务器端套接字程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">class TCPServer&#123;</span><br><span class="line">  public static void main(String argv[]) throws Exception</span><br><span class="line">  &#123;</span><br><span class="line">     String ClientSentence;</span><br><span class="line">     String capitalizedSentence;</span><br><span class="line">     ServerSocket welcomeSocket = new ServerSocket(6789);</span><br><span class="line"> </span><br><span class="line">     while(true)&#123;</span><br><span class="line">        Socket connectionSocket = welcomeSocket.accept();</span><br><span class="line">        BufferedReader inFromClient =</span><br><span class="line">          new BufferedReader(new InputStreamReader(</span><br><span class="line">              connectionSocket.getInputStream()));</span><br><span class="line">        DataOutputStream outToClient =</span><br><span class="line">          new DataOutputStream(</span><br><span class="line">              connectionSocket.getOutputStream());</span><br><span class="line">        ClientSentence = inFromClient.readLine();</span><br><span class="line">        capitalizedSentence =</span><br><span class="line">              ClientSentence.toUpperCase() + &apos;\n&apos;;</span><br><span class="line">     outToClient.writeBytes(capitalizedSentence);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--more--><p><img src="/2018/03/08/计算机网络学习-三-socket套接字分析/tcp1.png" alt="tcp"><br><img src="/2018/03/08/计算机网络学习-三-socket套接字分析/tcp2.png" alt="tcp"></p><h3 id="TCP连接分析："><a href="#TCP连接分析：" class="headerlink" title="TCP连接分析："></a>TCP连接分析：</h3><ul><li><p>1、 客户端：握手请求seq=0,len=0，syn=1<br>syn=1，标志着这是一次握手请求，且客户端设置初始seq=0，发送数据len=0</p></li><li><p>2、 服务器端：握手应答 seq=0 ,ack =1, len=0，syn=1<br>syn=1，这是属于握手应答，且服务端初始seq=0，ack=（客户端的）seq+len+1，发送数据len=0</p></li><li><p>3、 客户端：接收到应答 seq =1, ack =1, len=0<br>seq=（客户端上次的）seq+len+1, ack=（服务端的）seq+len+1</p></li><li><p>4、 客户端：发送数据请求 seq =1 ,ack = 1 ,len =1</p></li><li>5、 服务器端：接收请求 seq =1 ,ack =2 ,len =0</li><li>6、 客户端：发送数据 seq =2, ack =1, len =14</li><li>7、 服务器端:接收数据并请求发送数据 seq =1 ,ack =16 ,len =1</li><li>8、 客户端:接收请求 seq =16 , ack =2 , len=0</li><li>9、 服务器端：发送数据 seq =2 ,ack =16 ,len =14</li><li>10、客户端:接收数据并请求关闭连接 seq = 16 ,ack = 16 ,len =0</li><li>11、服务器端:接收请求 seq = 16 ,ack =17 ,len =0</li></ul><p>客户端关闭连接，但服务器端仍保持监听，则服务器端没有进行请求关闭连接的请求。</p><h2 id="UDP实验："><a href="#UDP实验：" class="headerlink" title="UDP实验："></a>UDP实验：</h2><h3 id="UDP客户端套接字程序"><a href="#UDP客户端套接字程序" class="headerlink" title="UDP客户端套接字程序"></a>UDP客户端套接字程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">class UDPClient &#123;</span><br><span class="line">  public static void main(String args[]) throws Exception</span><br><span class="line">  &#123;</span><br><span class="line">     BufferedReader inFromUser =</span><br><span class="line">        new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">     DatagramSocket clientSocket = new DatagramSocket();</span><br><span class="line">     InetAddress IPAddress = InetAddress.getByName(&quot;222.194.1.36&quot;);</span><br><span class="line">     byte[] sendData = new byte[1024];</span><br><span class="line">byte[] receiveData = new byte[1024];</span><br><span class="line">String sentence = inFromUser.readLine();</span><br><span class="line">sendData = sentence.getBytes();</span><br><span class="line">DatagramPacket sendPacket =</span><br><span class="line">   new DatagramPacket(sendData, sendData.length,</span><br><span class="line">IPAddress,9876);</span><br><span class="line">clientSocket.send(sendPacket);</span><br><span class="line">DatagramPacket receivePacket =</span><br><span class="line">   new DatagramPacket(receiveData, receiveData.length);</span><br><span class="line">clientSocket.receive(receivePacket);</span><br><span class="line">String modifiedSentence=</span><br><span class="line">   new String(receivePacket.getData());</span><br><span class="line">System.out.println(&quot;FROM SERVER:&quot; + modifiedSentence);</span><br><span class="line">clientSocket.close();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP服务器端套接字程序"><a href="#UDP服务器端套接字程序" class="headerlink" title="UDP服务器端套接字程序"></a>UDP服务器端套接字程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">class UDPServer &#123;</span><br><span class="line">  public static void main(String args[]) throws Exception</span><br><span class="line">  &#123;</span><br><span class="line">    DatagramSocket serverSocket = new DatagramSocket(9876);</span><br><span class="line">     byte[] receiveData = new byte[1024];</span><br><span class="line">     byte[] sendData = new byte[1024];</span><br><span class="line">     while(true)</span><br><span class="line">      &#123;</span><br><span class="line">  DatagramPacket receivePacket =</span><br><span class="line">   new DatagramPacket(receiveData, receiveData.length);</span><br><span class="line">  serverSocket.receive(receivePacket);</span><br><span class="line">       String sentence = new String(receivePacket.getData());</span><br><span class="line">       InetAddress IPAddress = receivePacket.getAddress();</span><br><span class="line">       int port = receivePacket.getPort();</span><br><span class="line">       String capitalizedSentence = sentence.toUpperCase();</span><br><span class="line">       sendData = capitalizedSentence.getBytes();</span><br><span class="line">  DatagramPacket sendPacket =</span><br><span class="line">new DatagramPacket(sendData, sendData.length,</span><br><span class="line">IPAddress,port);</span><br><span class="line">      serverSocket.send(sendPacket);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/03/08/计算机网络学习-三-socket套接字分析/udp1.png" alt="udp"><br><img src="/2018/03/08/计算机网络学习-三-socket套接字分析/udp2.png" alt="udp"></p><h3 id="UDP连接分析："><a href="#UDP连接分析：" class="headerlink" title="UDP连接分析："></a>UDP连接分析：</h3><p>1、客户端：向服务器端发送长度为60的数据段<br>2、服务器端 :向客户端发送长度为1066的数据段</p><h2 id="总结：与TCP连接相比，UDP显然更快捷，它不需要进行握手请求，也不用进行关闭请求。但是，很明显的是，少了这些以后，没法保证数据是否正常的传输到目的地，没法保证数据传输的可靠性。"><a href="#总结：与TCP连接相比，UDP显然更快捷，它不需要进行握手请求，也不用进行关闭请求。但是，很明显的是，少了这些以后，没法保证数据是否正常的传输到目的地，没法保证数据传输的可靠性。" class="headerlink" title="总结：与TCP连接相比，UDP显然更快捷，它不需要进行握手请求，也不用进行关闭请求。但是，很明显的是，少了这些以后，没法保证数据是否正常的传输到目的地，没法保证数据传输的可靠性。"></a>总结：与TCP连接相比，UDP显然更快捷，它不需要进行握手请求，也不用进行关闭请求。但是，很明显的是，少了这些以后，没法保证数据是否正常的传输到目的地，没法保证数据传输的可靠性。</h2>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络学习(二)-协议分析</title>
      <link href="/2018/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>互联网协议分为五层，各层的所有协议被称为协议栈。一般采用自顶向下的方法，首先处理应用层，然后向下进行处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应用层</span><br><span class="line">运输层</span><br><span class="line">网络层</span><br><span class="line">链路层</span><br><span class="line">物理层</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>国际标准化组织（ISO）提出了计算机网络的七层模型，即开放式互连模型（OSI），并未被使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用层</span><br><span class="line">表示层</span><br><span class="line">会话层</span><br><span class="line">运输层</span><br><span class="line">网络层</span><br><span class="line">链路层</span><br><span class="line">物理层</span><br></pre></td></tr></table></figure></p><!--more--><h2 id="传输层协议分析"><a href="#传输层协议分析" class="headerlink" title="传输层协议分析"></a>传输层协议分析</h2><p><a href="http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html" target="_blank" rel="noopener">socket可参考文章</a><br><a href="https://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">tcp可参考文章</a><br><!--more--></p><h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><p><img src="/2018/03/08/计算机网络学习-二-协议分析/tcp.jpg" alt="tcp报文结构"><br>6位标志域。表示为：紧急标志、有意义的应答标志、推、重置连接标志、同步序列号标志、完成发送数据标志。按照顺序排列是：URG、ACK、PSH、RST、SYN、FIN。<br>tcp的具体分析可见下篇，<a href="/2018/03/08/计算机网络学习-三-socket套接字分析/">socket套接字分析</a><br><!--more--></p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul><li>客户端向服务器发送一个SEQ J,SYN 1</li><li>服务器向客户端响应一个SEQ K，SYN 1, 并进行确认ACK J+1</li><li>客户端再想服务器发一个确认ACK K+1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A: 请求连接</span><br><span class="line">B：好，收到了，可以连了</span><br><span class="line">A：好，我知道你准备好了</span><br></pre></td></tr></table></figure><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul><li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li><li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li><li>接收到这个FIN的源发送端TCP对它进行确认。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: 请求关闭</span><br><span class="line">B：好，我知道了，正在关闭</span><br><span class="line">B: 好了，我处理完了，可以关闭连接了</span><br><span class="line">A：好，那就关闭吧</span><br></pre></td></tr></table></figure><h3 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h3><p><img src="/2018/03/08/计算机网络学习-二-协议分析/udp.jpg" alt="udp报文结构"></p><h3 id="对传输层协议TCP-UDP进行捕包分析"><a href="#对传输层协议TCP-UDP进行捕包分析" class="headerlink" title="对传输层协议TCP/UDP进行捕包分析"></a>对传输层协议TCP/UDP进行捕包分析</h3><p><img src="/2018/03/08/计算机网络学习-二-协议分析/tcp2.jpg" alt="tcp包分析"></p><p>(1) 向gaia.cs.umass.edu服务器传送文件的客户端主机的IP地址和TCP端口号是多少？<br>答：IP地址是：128.119.245.12<br>    端口号是：80<br>(1) 客户服务器之间用于初始化TCP连接的TCP SYN报文段的序号（sequence number）是多少？在该报文段中，是用什么来标示该报文段是SYN报文段的？<br>    答：seq为0， 用flags相应位置1来标示SYN报文段</p><p>TCP第二次握手协议图如下：<br><img src="/2018/03/08/计算机网络学习-二-协议分析/tcp3.jpg" alt="tcp包分析"></p><p>(1) 服务器向客户端发送的SYNACK报文段序号是多少？该报文段中，ACKnowledgement字段的值是多少？Gaia.cs.umass.edu服务器是如何决定此值的？在该报文段中，是用什么来标示该报文段是SYNACK报文段的？<br>答：SYNACK报文段的seq = 0 ， ACK = 1, 服务器计算方法是ACK = seq(SYN的) + 1， 在这个报文段中，用flags = 0x012来标示<br>(1) 前六个TCP报文段的长度各是多少？<br>答：由图可知，前六个TCP报文段长度为66 bytes、66 bytes、54 bytes、1462 bytes、1462 bytes、1462 bytes<br>(1) 在跟踪文件中是否有重传的报文段？进行判断的依据是什么？<br>答：没有重传的报文段，判断的依据是，如果有重传的报文段的话，那么服务器端向客户端 发送的TCP报文段里，就会出现大量的重复ACK。<br><img src="/2018/03/08/计算机网络学习-二-协议分析/tcp4.jpg" alt="tcp包分析"></p><h2 id="应用层协议分析"><a href="#应用层协议分析" class="headerlink" title="应用层协议分析"></a>应用层协议分析</h2><h3 id="dns分析"><a href="#dns分析" class="headerlink" title="dns分析"></a>dns分析</h3><p>DNS（域名系统）：Domain Name System  因特网的目录服务<br>DNS协议属于应用层协议<br>DNS通常是由其它应用层协议来使用的。<br>DNS是一个在因特网上实现分布式数据库的精彩范例。</p><p>DNS服务器的种类：</p><ul><li>根DNS服务器：用来引导查询获取顶级域名称服务器的域名及对应的顶级域服务器的IP地址。</li><li>顶级域（DNS）服务器：负责顶级域名如：com、org、net、edu、gov，以及所有国家的顶级域名如uk、fr、ca、jp等。</li><li>权威DNS服务器：在因特网上具有公共可访问主机的每个组织机构都必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。权威名称服务器对这些DNS记录进行收藏。</li><li>本地DNS服务器：不属于服务器的层次结构，但对DNS层次结构非常重要。</li></ul><p><img src="/2018/03/08/计算机网络学习-二-协议分析/dns.png" alt="dns分类"></p><h3 id="http分析"><a href="#http分析" class="headerlink" title="http分析"></a>http分析</h3><p>HTTP（超文本传输协议）：Hyper Text Transfer Protocol<br>HTTP协议永远都是客户端发起请求，服务器回送响应。<br>HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。</p><h4 id="http-header"><a href="#http-header" class="headerlink" title="http header"></a>http header</h4><ul><li><p>Host<br>指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含host，否则系统会以400状态码返回。</p></li><li><p>Range<br>Range头域可以请求实体的一个或者多个子范围。<br>一般用于<a href="http://blog.csdn.net/lv18092081172/article/details/51457525" target="_blank" rel="noopener">断点续传</a></p></li><li><p>User-Agent<br>包含发出请求的用户信息，可根据此来判断浏览器类型或爬虫类型。<br>github page 就是根据此屏蔽百度爬虫</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)</span><br></pre></td></tr></table></figure></li><li><p>Cache-Control<br>指定请求和响应遵循的缓存机制,请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。<br>性能提升相关</p></li></ul><h4 id="http长连接"><a href="#http长连接" class="headerlink" title="http长连接"></a>http长连接</h4><p>实际就是保持用于传输http数据的tcp连接保持不断开，使得客户端下一次访问服务端，还可以使用同一个tcp连接，从而避免了建立tcp连接的消耗。<br>对于频繁请求资源的客户来说，较适合使用长连接。但如果连接不断开，随着客户端的增长，保持的长连接也会越来越多，对服务器的压力反而会更大。<br>长连接适用于，操作频繁，点对点的通讯，且连接数不适合太多<br>短连接适用于，连接数较多且不会频繁操作的通讯<br><a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">长连接和短连接的理解</a></p><h4 id="http重定向，301和302"><a href="#http重定向，301和302" class="headerlink" title="http重定向，301和302"></a>http重定向，301和302</h4><p>重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置</p><ul><li>301 代表的是永久性的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</li><li>302 代表的是暂时性的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</li></ul><h4 id="https"><a href="#https" class="headerlink" title="https"></a>https</h4><p>在http之上多了一层SSL/TLS，在http开始时，服务端会先向客户端发送ssl证书，<br>ssl证书中会包含网站基本信息，ca机构，证书编号，服务器的公钥。<br>客户端收到证书后，会使用hash对照证书编号验证一致性与完整性，验证的过程就是查找本地维护的证书中指定的ca机构的公钥，对编号进行解密从而得到编号1，然后用证书中指定的编号生成方式生成一个编号2，如果两个编号相同，则证书验证通过。<br>然后客户端取出服务端的公钥，结合随机数生成一个对称加密的密钥再用服务器的公钥加密后，发回给服务端，服务端用自己的私钥解密之后双方就可以使用对称加密密钥进行通信了。<br><a href="http://www.admin10000.com/document/12524.html" target="_blank" rel="noopener">https讲解</a><br><a href="http://blog.csdn.net/sunmenggmail/article/details/11994013" target="_blank" rel="noopener">rsa加密原理</a><br><a href="https://www.zhihu.com/question/33645891?sort=created" target="_blank" rel="noopener">rsa加密原理2</a></p><h3 id="利用ethereal观察分析协议HTTP和DNS"><a href="#利用ethereal观察分析协议HTTP和DNS" class="headerlink" title="利用ethereal观察分析协议HTTP和DNS"></a>利用ethereal观察分析协议HTTP和DNS</h3><p><img src="/2018/03/08/计算机网络学习-二-协议分析/http1.jpg" alt="http抓包1"><br><img src="/2018/03/08/计算机网络学习-二-协议分析/http2.jpg" alt="http抓包2"><br><img src="/2018/03/08/计算机网络学习-二-协议分析/http3.jpg" alt="http抓包3"><br><img src="/2018/03/08/计算机网络学习-二-协议分析/http4.jpg" alt="http抓包4"></p><h4 id="浏览器运行的是HTTP1-0，还是HTTP1-1？所访问的服务器所运行的HTTP版本号是多少？"><a href="#浏览器运行的是HTTP1-0，还是HTTP1-1？所访问的服务器所运行的HTTP版本号是多少？" class="headerlink" title="浏览器运行的是HTTP1.0，还是HTTP1.1？所访问的服务器所运行的HTTP版本号是多少？"></a>浏览器运行的是HTTP1.0，还是HTTP1.1？所访问的服务器所运行的HTTP版本号是多少？</h4><p>运行的都是HTTP Version 1.1</p><h4 id="浏览器向服务器指出它能接收何种语言版本的对象？"><a href="#浏览器向服务器指出它能接收何种语言版本的对象？" class="headerlink" title="浏览器向服务器指出它能接收何种语言版本的对象？"></a>浏览器向服务器指出它能接收何种语言版本的对象？</h4><p>指出了能接收汉语，英语</p><h4 id="计算机的IP地址是多少？服务器gaia-cs-umass-edu的IP地址是多少？"><a href="#计算机的IP地址是多少？服务器gaia-cs-umass-edu的IP地址是多少？" class="headerlink" title="计算机的IP地址是多少？服务器gaia.cs.umass.edu的IP地址是多少？"></a>计算机的IP地址是多少？服务器gaia.cs.umass.edu的IP地址是多少？</h4><p>本机IP：172.30.164.86，目标IP：128.119.245.12</p><h4 id="从服务器上所获取的HTML文件的最后修改时间是多少？"><a href="#从服务器上所获取的HTML文件的最后修改时间是多少？" class="headerlink" title="从服务器上所获取的HTML文件的最后修改时间是多少？"></a>从服务器上所获取的HTML文件的最后修改时间是多少？</h4><p>最后的修改时间为Tue , 30 Oct 2007 17：00：02</p><h4 id="一共发出了多少个HTTP-GET请求？"><a href="#一共发出了多少个HTTP-GET请求？" class="headerlink" title="一共发出了多少个HTTP GET请求？"></a>一共发出了多少个HTTP GET请求？</h4><p>发出了一个GET请求</p><h4 id="承载这一个HTTP响应报文一共需要多少个data-containing-TCP报文段？"><a href="#承载这一个HTTP响应报文一共需要多少个data-containing-TCP报文段？" class="headerlink" title="承载这一个HTTP响应报文一共需要多少个data-containing TCP报文段？"></a>承载这一个HTTP响应报文一共需要多少个data-containing TCP报文段？</h4><p>4个报文段</p><h4 id="这个HTTP-GET请求相对应的响应报文的状态代码和状态短语是什么？"><a href="#这个HTTP-GET请求相对应的响应报文的状态代码和状态短语是什么？" class="headerlink" title="这个HTTP GET请求相对应的响应报文的状态代码和状态短语是什么？"></a>这个HTTP GET请求相对应的响应报文的状态代码和状态短语是什么？</h4><p>状态码200，短语OK ，意思为请求成功</p><h4 id="定位到DNS查询报文和查询响应报文，这两种报文的发送是基于UDP还是基于TCP的？"><a href="#定位到DNS查询报文和查询响应报文，这两种报文的发送是基于UDP还是基于TCP的？" class="headerlink" title="定位到DNS查询报文和查询响应报文，这两种报文的发送是基于UDP还是基于TCP的？"></a>定位到DNS查询报文和查询响应报文，这两种报文的发送是基于UDP还是基于TCP的？</h4><p>能看出，这两种报文都是基于UDP发送的</p><h4 id="查询报文的目的端口号是多少？DNS查询响应报文的源端口号是多少？"><a href="#查询报文的目的端口号是多少？DNS查询响应报文的源端口号是多少？" class="headerlink" title="查询报文的目的端口号是多少？DNS查询响应报文的源端口号是多少？"></a>查询报文的目的端口号是多少？DNS查询响应报文的源端口号是多少？</h4><p>查询报文:<br><img src="/2018/03/08/计算机网络学习-二-协议分析/dns2.jpg" alt="dns查询"><br>查询响应报文：<br><img src="/2018/03/08/计算机网络学习-二-协议分析/dns3.jpg" alt="dns查询"><br>由图可以看出，两个端口号都是一致的，是53号端口</p>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络学习(一)-测试通信</title>
      <link href="/2018/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E4%B8%80-%E6%B5%8B%E8%AF%95%E9%80%9A%E4%BF%A1/"/>
      <content type="html"><![CDATA[<p>之前学习网络的时候做的一些总结，现在正好整理一下，再加深一下记忆<br><a id="more"></a></p><h1 id="测试连接通信主要有5个命令，分别为ping-arp-ipconfig-tracert-netstat"><a href="#测试连接通信主要有5个命令，分别为ping-arp-ipconfig-tracert-netstat" class="headerlink" title="测试连接通信主要有5个命令，分别为ping , arp , ipconfig , tracert , netstat"></a>测试连接通信主要有5个命令，分别为ping , arp , ipconfig , tracert , netstat</h1><!--more--><h2 id="ipconfig-命令（windows）-ifconfig命令（linux）"><a href="#ipconfig-命令（windows）-ifconfig命令（linux）" class="headerlink" title="ipconfig 命令（windows）/ ifconfig命令（linux）"></a>ipconfig 命令（windows）/ ifconfig命令（linux）</h2><p>利用ipconfig命令显示所有当前的TCP/IP网络配置值、刷新动态主机配置协议 (DHCP) 和域名系统 (DNS) 设置。 使用不带参数的IPCONFIG显示所有适配器的 IP 地址、子网掩码、默认网关。<br>利用ifconfig命令可以在linux系统下显示所有适配器的 IP 地址、子网掩码、默认网关。<br><img src="/2018/03/08/计算机网络学习-一-测试通信/ipconfig.png" alt="ipconfig"><br><!--more--></p><h2 id="ping-命令"><a href="#ping-命令" class="headerlink" title="ping 命令"></a>ping 命令</h2><p>Ping向目标主机(地址)发送一个回送请求数据包，要求目标主机收到请求后给予答复，从而判断网络的响应时间和本机是否与目标主机(地址)联通。<br>如果执行Ping不成功，则可以预测故障出现在以下几个方面：网线故障，网络适配器配置不正确，IP地址不正确。如果执行Ping成功而网络仍无法使用，那么问题很可能出在网络系统的软件配置方面，Ping成功只能保证本机与目标主机间存在一条连通的物理路径。<br>命令格式：<br>ping IP地址或主机名 [-t] [-a] [-n count] [-l size]<br>常用参数含义：</p><ul><li>-t不停地向目标主机发送数据；</li><li>-a 以IP地址格式来显示目标主机的网络地址 ；</li><li>-n count 指定要Ping多少次，具体次数由count来指定 ；</li><li>-l size 指定发送到目标主机的数据包的大小。<br><img src="/2018/03/08/计算机网络学习-一-测试通信/ping.png" alt="ping"><!--more--></li></ul><h2 id="tracert-命令-windows-traceroute命令（linux）"><a href="#tracert-命令-windows-traceroute命令（linux）" class="headerlink" title="tracert 命令(windows) / traceroute命令（linux）"></a>tracert 命令(windows) / traceroute命令（linux）</h2><p>Tracert命令用来显示数据包到达目标主机所经过的路径，并显示到达每个节点的时间，分析网络延时产生的原因。<br>Tracert命令用来显示数据包到达目标主机所经过的路径，并显示到达每个节点的时间。命令功能同Ping类似，但它所获得的信息要比Ping命令详细得多，它把数据包所走的全部路径、节点的IP以及花费的时间都显示出来。该命令比较适用于大型网络。<br>命令格式：<br>tracert IP地址或主机名 [-d][-h maximumhops][-j host_list] [-w timeout]<br>参数含义：</p><ul><li>-d 不解析目标主机的名字；</li><li>-h maximum_hops 指定搜索到目标地址的最大跳跃数；</li><li>-j host_list 按照主机列表中的地址释放源路由；</li><li>-w timeout 指定超时时间间隔，程序默认的时间单位是毫秒。</li></ul><p><img src="/2018/03/08/计算机网络学习-一-测试通信/tracert.png" alt="tracert"></p><p>ps: 很实用的一个命令，在使用京东的云主机的时候，出现访问腾讯地图延时过长的问题，使用命令分析后发现是京东云主机默认的主dns服务器对腾讯地图的地址解析过慢（10s以上），更换dns为8.8.8.8后解决问题</p><h2 id="netstat-命令"><a href="#netstat-命令" class="headerlink" title="netstat 命令"></a>netstat 命令</h2><p>Netstat命令了解网络的整体使用情况。显示当前正在活动的网络连接的详细信息，例如显示网络连接、路由表和网络接口信息，统计目前总共有哪些网络连接正在运行。<br>参数含义：</p><ul><li>-a  显示所有连接和侦听端口。</li><li>-b  显示在创建每个连接或侦听端口时涉及的可执行程序。在某些情况下，已知可执行程序承载多个独立的组件，这些情况下，显示创建连接或侦听端口时涉及的组件序列。此情况下，可执行程序的名称位于底部[]中，它调用的组件位于顶部，直至达到 TCP/IP。注意，此选项可能很耗时，并且在没有足够权限时可能失败。</li><li>-e   显示以太网统计。此选项可以与 -s 选项结合使用。</li><li>-f   显示外部地址的完全限定域名(FQDN)。</li><li>-n   以数字形式显示地址和端口号。</li><li>-o   显示拥有的与每个连接关联的进程 ID。</li><li>-p proto  显示 proto 指定的协议的连接；proto 可以是下列任何一个: TCP、UDP、TCPv6 或 UDPv6。如果与 -s 选项一起用来显示每个协议的统计，proto 可以是下列任何一个: IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP或 UDPv6。</li><li>-r    显示路由表。</li><li>-s    显示每个协议的统计。默认情况下，显示IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6的统计；-p 选项可用于指定默认的子网。</li><li>-t    显示当前连接卸载状态。<br><img src="/2018/03/08/计算机网络学习-一-测试通信/netstat.png" alt="netstat"></li></ul><h2 id="arp-命令"><a href="#arp-命令" class="headerlink" title="arp 命令"></a>arp 命令</h2><p>利用ARP确定对应IP地址的网卡物理地址。查看本地计算机或另一台计算机的ARP高速缓存中的当前内容。<br><img src="/2018/03/08/计算机网络学习-一-测试通信/arp.png" alt="arp"></p><h1 id="测试dns服务器与smtp服务器"><a href="#测试dns服务器与smtp服务器" class="headerlink" title="测试dns服务器与smtp服务器"></a>测试dns服务器与smtp服务器</h1><h2 id="nslookup-命令使用"><a href="#nslookup-命令使用" class="headerlink" title="nslookup 命令使用"></a>nslookup 命令使用</h2><p>先从13个根名称服务器中任选一个（本次选择 198.41.0.4）去查找能解析.com的顶级域的域名<br><img src="/2018/03/08/计算机网络学习-一-测试通信/nslookup1.png" alt="nslookup"></p><p>再任选一个（本次选择a.gtld-servers.net）上步给出的顶级域的域名，去查找能解析 baidu.com 的权威名称服务器的域名<br><img src="/2018/03/08/计算机网络学习-一-测试通信/nslookup2.png" alt="nslookup"></p><p>再去上步给出的权威名称服务器中去查找 yun.baidu.com ，最终得到结果<br><img src="/2018/03/08/计算机网络学习-一-测试通信/nslookup3.png" alt="nslookup"></p><h2 id="telnet-命令"><a href="#telnet-命令" class="headerlink" title="telnet 命令"></a>telnet 命令</h2><p>远程连接命令</p><h3 id="Smtp"><a href="#Smtp" class="headerlink" title="Smtp:"></a>Smtp:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Telnet smtp.163.com  25</span><br><span class="line">Helo wang</span><br><span class="line">Auth login</span><br><span class="line">dzMyMTEwNDE4QDE2My5jb20=</span><br><span class="line">d2FuZ3J1aQ==</span><br><span class="line">MAIL FROM:&lt;w32110418@163.com&gt;</span><br><span class="line">RCPT TO:&lt;32110418@qq.com&gt;</span><br><span class="line">Data</span><br><span class="line">TO: 32110418@qq.com</span><br><span class="line">FROM: w32110418@163.com</span><br><span class="line">Subject :test mail</span><br><span class="line">Hahaha</span><br><span class="line">Hahahah</span><br><span class="line">Heheheh</span><br><span class="line">Hehehe</span><br><span class="line">.</span><br><span class="line">Quit</span><br></pre></td></tr></table></figure><p><img src="/2018/03/08//计算机网络学习-一-测试通信/telnet.png" alt="telnet"></p><h3 id="Pop3"><a href="#Pop3" class="headerlink" title="Pop3:"></a>Pop3:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Telnet pop.163.com 110</span><br><span class="line">User w32110418</span><br><span class="line">Pass 120410228</span><br><span class="line">Stat</span><br><span class="line">List 3</span><br><span class="line">Retr 4</span><br><span class="line">Quit</span><br></pre></td></tr></table></figure><p><img src="/2018/03/08/计算机网络学习-一-测试通信/pop3.png" alt="telnet"></p><p><img src="/2018/03/08/计算机网络学习-一-测试通信/pop3-2.png" alt="telnet"></p><p>两种方法都可以实现dos环境下，对邮件的一些操作。但是在操作的过程中，一但输入错误，就必须重新输入，有点烦琐。<br>smtp下，向目标发送的必须是base64转换后的内容。而pop3下就不需要这步。<br>有的邮箱必须是得开启选项后，才能使用这种方法。</p>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux 常用命令</title>
      <link href="/2018/03/07/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <content type="html"><![CDATA[<p>记录一下时不时就会遇到，但就是记不住的几个命令<br><a id="more"></a></p><h2 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -apn | grep port</span><br></pre></td></tr></table></figure><!--more--><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><ul><li><p>apt purge / apt –purge remove<br>删除已安装包（不保留配置文件)。<br>如软件包a，依赖软件包b，则执行该命令会删除a，而且不保留配置文</p></li><li><p>apt autoremove<br>删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装包），保留配置文件。</p></li><li><p>apt remove<br>删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。</p></li><li><p>apt autoclean<br>APT的底层包是dpkg, 而dpkg 安装Package时, 会将 *.deb 放在 /var/cache/apt/archives/中，apt-get autoclean 只会删除 /var/cache/apt/archives/ 已经过期的deb</p></li><li><p>apt clean<br>使用 apt-get clean 会将 /var/cache/apt/archives/ 的 所有 deb 删掉，可以理解为 rm /var/cache/apt/archives/*.deb。</p><!--more--></li></ul><h2 id="查看存储空间"><a href="#查看存储空间" class="headerlink" title="查看存储空间"></a>查看存储空间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free 查看内存使用情况</span><br><span class="line">df -h 查看各挂载点所占用和可用空间</span><br><span class="line">du -sh * 查看当前目录下所有文件和文件夹所占空间</span><br></pre></td></tr></table></figure><h2 id="生成ssh密钥"><a href="#生成ssh密钥" class="headerlink" title="生成ssh密钥"></a>生成ssh密钥</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><h2 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h2><ul><li>-e 显示所有的进程</li><li>-f 显示全格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br><span class="line">可以查看nginx的运行情况</span><br></pre></td></tr></table></figure></li></ul><h2 id="进程结束-kill"><a href="#进程结束-kill" class="headerlink" title="进程结束 kill"></a>进程结束 kill</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -15 pid = kill pid , SIGTERM,  通知程序正常退出</span><br><span class="line">kill -9 pid , SIGKILL， 使程序强制退出</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go语言学习-sync</title>
      <link href="/2017/08/02/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-sync/"/>
      <content type="html"><![CDATA[<h2 id="sync包介绍"><a href="#sync包介绍" class="headerlink" title="sync包介绍"></a>sync包介绍</h2><p>sync包是go提供的实现锁机制的集合</p><h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><p>可用此函数实现单例模式<br>详情可见于 <a href="https://blog.vgmdj.cn/tags/设计模式/">https://blog.vgmdj.cn/tags/设计模式/</a><br><a id="more"></a></p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  // Once is an object that will perform exactly one action.</span><br><span class="line">  type Once struct &#123;</span><br><span class="line">  m    Mutex</span><br><span class="line">  done uint32</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func (o *Once) Do(f func()) &#123;</span><br><span class="line">if atomic.LoadUint32(&amp;o.done) == 1 &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">// Slow-path.</span><br><span class="line">o.m.Lock()</span><br><span class="line">defer o.m.Unlock()</span><br><span class="line">if o.done == 0 &#123;</span><br><span class="line">defer atomic.StoreUint32(&amp;o.done, 1)</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Once的实例 o ，如果其done为1，即已经完成do操作，则直接返回，否则加锁更新为1，并执行函数f</p>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go语言学习-总览</title>
      <link href="/2017/08/01/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要是记录go语言学习过程中遇到的一些难点，在此用于分享和备忘，如有错误或更好的见解，请留言</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="https://blog.vgmdj.cn/tags/Golang">https://blog.vgmdj.cn/tags/Golang</a><br><a id="more"></a></p><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><ul><li>map</li><li>sync</li></ul>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式学习-单例模式</title>
      <link href="/2017/07/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式(Singleton)"></a>单例模式(Singleton)</h2><p>保证同一个类全局只有一个实例对象<br>在第一次实例化后会使用静态变量保存实例，后续全局使用此静态变量<br>在多线程时应该考虑并发问题，防止两次调用都被判定为实例未初始化而重复初始化对象</p><p>PS： 虽然单例简单，我们还是不能任性的用，因为这样做实例会一直存在内存中，一些我们用的不是那么频繁的东西使用了单例是不是就造成了内存的浪费？大家在用单例的时候还是要多思考思考，这个模块适不适合用单例！<br><a id="more"></a></p><h2 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h2><p>书籍：《大话设计模式》，《设计模式之禅》<br>golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank" rel="noopener">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>保证在整个系统中存在唯一的实例，在并发的环境中依旧好用</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>全局共享同一个实例对象（数据库连接等）<br>某一处对此对象的更新全局可见</p><h2 id="golang-实现"><a href="#golang-实现" class="headerlink" title="golang 实现"></a>golang 实现</h2><p>在go中可以使用这么一种机制来保证代码只执行一次，而且不需要我们手工去加锁解锁。<br>那就是sync包里的Once函数，它有一个Do方法，在它中的函数go会只保证仅仅调用一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">  &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type singleton struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance *singleton</span><br><span class="line">var once sync.Once</span><br><span class="line"></span><br><span class="line">func GetInstance() *singleton &#123;</span><br><span class="line">  once.Do(func() &#123;</span><br><span class="line">      instance = &amp;singleton&#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sync-Once解析"><a href="#sync-Once解析" class="headerlink" title="sync.Once解析"></a>sync.Once解析</h2><p>可见于 <a href="/2017/08/02/go语言学习-sync"><strong>go语言学习-sync包</strong></a></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式学习-策略模式</title>
      <link href="/2017/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h2 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式(Strategy)"></a>策略模式(Strategy)</h2><p>策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户<br><a id="more"></a></p><h2 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h2><p>书籍：《大话设计模式》，《设计模式之禅》<br>golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank" rel="noopener">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>需要有一系列不同的算法，这些算法完成的工作是同样的，只是实现不同，强调以相同的方式调用所有的算法，减少算法类和使用算法类之间的耦合</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>使代码结构清晰，便于维护，简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试<br>每个算法的修改都不会影响到其他的算法</p><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><p>商场商品价格计算，其中涉及到的有商品的单价，个数，折扣<br>折扣的策略有：</p><ul><li>固定折扣</li><li>满减</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type CashSuper interface &#123;</span><br><span class="line">Accept(float64) float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//CashNormal normal strategy</span><br><span class="line">type CashNormal struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (normal CashNormal) Accept(money float64) float64 &#123;</span><br><span class="line">return money</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//CashRebate</span><br><span class="line">type CashRebate struct &#123;</span><br><span class="line">moneyRebate float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (re CashRebate) Accept(money float64) float64 &#123;</span><br><span class="line">return money * re.moneyRebate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//CashReturn</span><br><span class="line">type CashReturn struct &#123;</span><br><span class="line">moneyCondition float64</span><br><span class="line">moneyReturn    float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (re CashReturn) Accept(money float64) float64 &#123;</span><br><span class="line">if money &gt;= re.moneyCondition &#123;</span><br><span class="line">return money - re.moneyReturn</span><br><span class="line">&#125;</span><br><span class="line">return money</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//use simple factory optimize strategy</span><br><span class="line">type CashContext struct &#123;</span><br><span class="line">strategy CashSuper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewCashContext(acceptType string) (cashFactory CashContext) &#123;</span><br><span class="line">switch acceptType &#123;</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;wrong type&quot;)</span><br><span class="line"></span><br><span class="line">case &quot;normal&quot;:</span><br><span class="line">cashFactory.strategy = CashNormal&#123;&#125;</span><br><span class="line"></span><br><span class="line">case &quot;0.8rebate&quot;:</span><br><span class="line">cashFactory.strategy = CashRebate&#123;moneyRebate: 0.8&#125;</span><br><span class="line"></span><br><span class="line">case &quot;300return100&quot;:</span><br><span class="line">cashFactory.strategy = CashReturn&#123;300, 100&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cashFactory CashContext) Accept(money float64) float64 &#123;</span><br><span class="line">return cashFactory.strategy.Accept(money)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式学习-抽象工厂模式</title>
      <link href="/2017/07/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h2 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式(Abstract Factory)"></a>抽象工厂模式(Abstract Factory)</h2><p>工厂模式是对象的生产器，解耦用户对具体对象的依赖。<br>提供一个创建一系列相关或相互依赖的接口，而无需指定它们具体的类<br><a id="more"></a></p><h2 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h2><p>书籍：《大话设计模式》，《设计模式之禅》<br>golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank" rel="noopener">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>多使用于产品系列的交换，与工厂方法模式相比，区别在于，工厂方法一般只是一个工厂只产出一个产品，而抽象工厂的工厂可以产出不同的产品<br>类比汽车</p><ul><li>工厂方法<ul><li>A工厂  A轿车</li><li>B工厂  B轿车</li></ul></li><li>抽象工厂<ul><li>A工厂  A轿车， A客车， A卡车</li><li>B工厂  B轿车， B客车， B卡车</li></ul></li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>易于交换产品系列，只需要改变具体工厂即可使用不同的产品配置<br>让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中</p><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><p>多数据库处理用户，部分的增删改查</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>代码是根据大话设计模式里的需求编写，但没有找到go中类似C++里System.Reflection的方法，所以只实现到结合简单工厂来对抽象工厂实现</p><ul><li><p>user相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">type User struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">type IUser interface &#123;</span><br><span class="line">Insert(user User)</span><br><span class="line">Delete(user User)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AccessUser struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (au AccessUser) Insert(user User) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (au AccessUser) Delete(user User) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MysqlUser struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (mu MysqlUser) Insert(user User) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mu MysqlUser) Delete(user User) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>department相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">type Department struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IDepartment interface &#123;</span><br><span class="line">Insert(department Department)</span><br><span class="line">Delete(department Department)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AccessDepartment struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (ad AccessDepartment) Insert(department Department) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ad AccessDepartment) Delete(department Department) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MysqlDepartment struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (md MysqlDepartment) Insert(department Department) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (md MysqlDepartment) Delete(department Department) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象工厂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const (</span><br><span class="line">Mysql  = &quot;mysql&quot;</span><br><span class="line">Access = &quot;access&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type DatabaseFactory struct &#123;</span><br><span class="line">DB string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (df DatabaseFactory) CreateUser() IUser &#123;</span><br><span class="line">switch df.DB &#123;</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;unknown database return default mysql&quot;)</span><br><span class="line">return new(MysqlUser)</span><br><span class="line"></span><br><span class="line">case Mysql:</span><br><span class="line">return new(MysqlUser)</span><br><span class="line"></span><br><span class="line">case Access:</span><br><span class="line">return new(AccessUser)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (df DatabaseFactory) CreateDepartment() IDepartment &#123;</span><br><span class="line">switch df.DB &#123;</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;unknown database return default mysql&quot;)</span><br><span class="line">return new(MysqlDepartment)</span><br><span class="line"></span><br><span class="line">case Mysql:</span><br><span class="line">return new(MysqlDepartment)</span><br><span class="line"></span><br><span class="line">case Access:</span><br><span class="line">return new(AccessDepartment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func TestDatabaseFactory(t *testing.T) &#123;</span><br><span class="line">user := User&#123;&#125;</span><br><span class="line">mysqlUser := DatabaseFactory&#123;&quot;mysql&quot;&#125;.CreateUser()</span><br><span class="line">mysqlUser.Insert(user)</span><br><span class="line"></span><br><span class="line">deppartment := Department&#123;&#125;</span><br><span class="line">accessDepartment := DatabaseFactory&#123;&quot;access&quot;&#125;.CreateDepartment()</span><br><span class="line">accessDepartment.Delete(deppartment)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式学习-工厂方法模式</title>
      <link href="/2017/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h2 id="工厂方法模式-Factory-Method"><a href="#工厂方法模式-Factory-Method" class="headerlink" title="工厂方法模式(Factory Method)"></a>工厂方法模式(Factory Method)</h2><p>工厂模式是对象的生产器，解耦用户对具体对象的依赖。<br>定义了一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。</p><h2 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h2><p>书籍：《大话设计模式》，《设计模式之禅》<br>golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank" rel="noopener">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a><br><a id="more"></a></p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>简单工厂模式虽然实现了对象依赖的解耦，但是每次扩展都要在switch case里添加相应的选择，会修改原有的类，也就是说，违背了开放-封闭原则，而工厂模式则解决了这个问题。<br>工厂方法模式实现时，客户端需要决定实例化哪一个具体的工厂，选择问题仍然存在，但是工厂方法把简单工厂的内部逻辑判断转移到了客户端代码上来，如果要进行扩展，就不用再去修改原来的类了，只需要在客户端进行修改即可</p><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><ul><li>计算器的编写<br>如果用简单工厂模式，一旦要实例化多个计算器，就需要连续创建多次工厂，使代码变的累赘。同时，在新增功能的时候，仍需要对之前的选择部分进行修改，没法完全使模块成为一个易扩展的独立部分</li><li>多数据库处理<br>使用多种数据库对用户表操作，这里应该尽量解除对具体的数据的依赖<br>如果不使用工厂模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user := new(User)</span><br><span class="line">su := new(MysqlUser)</span><br><span class="line">su.Insert(user)</span><br><span class="line">su.Select(user)</span><br><span class="line"></span><br><span class="line">这里的su被框死了，只能是Mysql的实现，如果要换数据库的话，所有涉及到su的地方都需要修改</span><br></pre></td></tr></table></figure><h2 id="例子-计算器"><a href="#例子-计算器" class="headerlink" title="例子-计算器"></a>例子-计算器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Operation 操作接口</span><br><span class="line">type Operation interface &#123;</span><br><span class="line">SetNumber(float64, float64)</span><br><span class="line">GetResult() float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BaseOperation 基础类</span><br><span class="line">type BaseOperation struct &#123;</span><br><span class="line">Operation</span><br><span class="line">NumberA float64</span><br><span class="line">NumberB float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (bo *BaseOperation) SetNumber(numberA, numberB float64) &#123;</span><br><span class="line">bo.NumberA = numberA</span><br><span class="line">bo.NumberB = numberB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//OperationAdd 加法运算</span><br><span class="line">type OperationAdd struct &#123;</span><br><span class="line">BaseOperation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (oa OperationAdd) GetResult() float64 &#123;</span><br><span class="line">return oa.NumberA + oa.NumberB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//OperationSub 减法运算类</span><br><span class="line">type OperationSub struct &#123;</span><br><span class="line">BaseOperation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (os OperationSub) GetResult() float64 &#123;</span><br><span class="line">return os.NumberA - os.NumberB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//OperationSubII 工厂接口</span><br><span class="line">type IFactory interface &#123;</span><br><span class="line">CreateOperation() Operation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type FactoryAdd struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (fa FactoryAdd) CreateOperation() Operation &#123;</span><br><span class="line">return new(OperationAdd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type user struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">type UserDB interface &#123;</span><br><span class="line">Insert(u user) error</span><br><span class="line">Select(u user) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MysqlUserDB struct &#123;</span><br><span class="line">UserDB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mysql MysqlUserDB) Insert(u user) error &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">func (mysql MysqlUserDB) Select(u user) error &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SqlServerUserDB struct &#123;</span><br><span class="line">UserDB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sqlServer SqlServerUserDB) Insert(u user) error &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">func (sqlServer SqlServerUserDB) Select(u user) error &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type DBFactory interface &#123;</span><br><span class="line">CreateFactory() UserDB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MysqlUserFactory struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (mf MysqlUserFactory) CreateFactory() UserDB &#123;</span><br><span class="line">return new(MysqlUserDB)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SqlServerFactory struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (sf SqlServerFactory) CreateFactory() UserDB &#123;</span><br><span class="line">return new(SqlServerUserDB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式学习-简单工厂模式</title>
      <link href="/2017/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h2 id="简单工厂模式-Simple-Factory"><a href="#简单工厂模式-Simple-Factory" class="headerlink" title="简单工厂模式(Simple Factory)"></a>简单工厂模式(Simple Factory)</h2><p>工厂模式是对象的生产器，解耦用户对具体对象的依赖。<br>通过封闭、继承、多态把程序的耦合度降低，使程序更加的灵活，容易修改，并易于复用。<br>简单工厂模式中，各种运算方法类实现了运算接口，在业务上如果想添加一种运算方法，只需要增加一个实现运算接口的类，并且在工厂类中添加一个类型判断。<br>这种设计适合于业务类型并不是很多的情况，如果业务类型非常多，那么在工作类中就会有一个很长的switch…case结构，这时候使用方法工厂模式会比较合适。<br><a id="more"></a></p><h2 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h2><p>书籍：《大话设计模式》，《设计模式之禅》<br>golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank" rel="noopener">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a><br><!--more--></p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>工厂类中包含了必要的逻辑判断，根据客户端的选择条件实例化相应的类，对于客户端来说，去除了与具产品的依赖</p><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><ul><li>计算器的编写<br>如果不使用工厂模式，使用面向过程的思想编写，就会出现每次扩展都需要修改原已经写好的代码，可能会使原来已经实现的功能受到影响，同时不利于阅读和理解</li></ul><h2 id="例子-计算器"><a href="#例子-计算器" class="headerlink" title="例子 - 计算器"></a>例子 - 计算器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">设计一个计算器</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//Operation 操作接口</span><br><span class="line">type Operation interface &#123;</span><br><span class="line">SetNumber(float64, float64)</span><br><span class="line">GetResult() float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BaseOperation 基础类</span><br><span class="line">type BaseOperation struct &#123;</span><br><span class="line">Operation</span><br><span class="line">NumberA float64</span><br><span class="line">NumberB float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (bo *BaseOperation) SetNumber(numberA, numberB float64) &#123;</span><br><span class="line">bo.NumberA = numberA</span><br><span class="line">bo.NumberB = numberB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//OperationAdd 加法运算</span><br><span class="line">type OperationAdd struct &#123;</span><br><span class="line">BaseOperation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (oa OperationAdd) GetResult() float64 &#123;</span><br><span class="line">return oa.NumberA + oa.NumberB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//OperationSub 减法运算类</span><br><span class="line">type OperationSub struct &#123;</span><br><span class="line">BaseOperation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (os OperationSub) GetResult() float64 &#123;</span><br><span class="line">return os.NumberA - os.NumberB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//OperationFactory 工厂类</span><br><span class="line">type OperationFactory struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (of OperationFactory) CreateOperation(oper string) Operation &#123;</span><br><span class="line">switch oper &#123;</span><br><span class="line">default:</span><br><span class="line">return nil</span><br><span class="line">case &quot;+&quot;:</span><br><span class="line">return new(OperationAdd)</span><br><span class="line">case &quot;-&quot;:</span><br><span class="line">return new(OperationSub)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//OperationUsage 工厂操作</span><br><span class="line">func OperationUsage() &#123;</span><br><span class="line">factory := new(OperationFactory)</span><br><span class="line">operation := factory.CreateOperation(&quot;+&quot;)</span><br><span class="line">operation.SetNumber(1, 2)</span><br><span class="line">fmt.Printf(&quot;this is add operation, 1+2=%v\n&quot;, operation.GetResult())</span><br><span class="line"></span><br><span class="line">operation = factory.CreateOperation(&quot;-&quot;)</span><br><span class="line">operation.SetNumber(2, 1)</span><br><span class="line">fmt.Printf(&quot;this is sub operation, 2-1=%v\n&quot;, operation.GetResult())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例子-手机厂商"><a href="#例子-手机厂商" class="headerlink" title="例子 - 手机厂商"></a>例子 - 手机厂商</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">设计一个工厂来生产各种厂商的手机</span><br><span class="line">其中初始的厂商有小米，苹果，华为</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//Phone interface</span><br><span class="line">type Phone interface &#123;</span><br><span class="line">ShowBrand()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//IPhone apple</span><br><span class="line">type IPhone struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (phone IPhone) ShowBrand() &#123;</span><br><span class="line">fmt.Println(&quot;[Phone Brand]: Apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//HPhone huawei</span><br><span class="line">type HPhone struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (phone HPhone) ShowBrand() &#123;</span><br><span class="line">fmt.Println(&quot;[Phone Brand]: Huawei&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//XPhone xiaomi</span><br><span class="line">type XPhone struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (phone XPhone) ShowBrand() &#123;</span><br><span class="line">fmt.Println(&quot;[Phone Brand]: Xiaomi&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PhoneFactory struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (factory PhoneFactory) CreatePhone(brand string) Phone &#123;</span><br><span class="line">switch brand &#123;</span><br><span class="line">default:</span><br><span class="line">return nil</span><br><span class="line">case &quot;HW&quot;:</span><br><span class="line">return new(HPhone)</span><br><span class="line">case &quot;XM&quot;:</span><br><span class="line">return new(XPhone)</span><br><span class="line">case &quot;PG&quot;:</span><br><span class="line">return new(IPhone)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func PhoneUsage() &#123;</span><br><span class="line">factory := PhoneFactory&#123;&#125;</span><br><span class="line">phone := factory.CreatePhone(&quot;HW&quot;)</span><br><span class="line">phone.ShowBrand()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用及运行结果"><a href="#调用及运行结果" class="headerlink" title="调用及运行结果"></a>调用及运行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">OperationUsage()</span><br><span class="line">PhoneUsage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result :</span><br><span class="line"></span><br><span class="line">this is add operation, 1+2=3</span><br><span class="line">this is sub operation, 2-1=1</span><br><span class="line">[Phone Brand]: Huawei</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式学习-总览</title>
      <link href="/2017/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E8%A7%88/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要是将书中资源整理总结，用于分享和回顾复习，如有错误或更好见解，请留言</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="https://blog.vgmdj.cn/tags/设计模式/">https://blog.vgmdj.cn/tags/设计模式/</a></p><h2 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h2><p>书籍：《大话设计模式》，《设计模式之禅》<br>golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank" rel="noopener">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a><br><a id="more"></a></p><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><ul><li>简单工厂模式（Simple Factory）</li><li>工厂方法模式（Factory Method）</li><li>抽象工厂模式（Abstract Factory）</li><li>创建者模式（Builder）</li><li>原型模式（Prototype）</li><li>单例模式（Singleton）</li></ul><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><ul><li>外观模式（Facade）</li><li>适配器模式（Adapter）</li><li>代理模式（Proxy）</li><li>组合模式（Composite）</li><li>享元模式（Flyweight）</li><li>装饰模式（Decorator）</li><li>桥模式（Bridge）</li></ul><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><ul><li>中介者模式（Mediator）</li><li>观察者模式（Observer）</li><li>命令模式（Command）</li><li>迭代器模式（Iterator）</li><li>模板方法模式（Template Method）</li><li>策略模式（Strategy）</li><li>状态模式（State）</li><li>备忘录模式（Memento）</li><li>解释器模式（Interpreter）</li><li>职责链模式（Chain of Responsibility）</li><li>访问者模式（Visitor）</li></ul>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法学习-排序</title>
      <link href="/2017/03/18/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/"/>
      <content type="html"><![CDATA[<h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>算法的排序，一方面作为其他算法的基础，一方面也体现了一些重要的算法的思想，需要我们好好掌握<br>本章代码的go语言实现都可见于： <a href="https://github.com/vgmdj/go_practice/tree/master/algorithm/sort" target="_blank" rel="noopener">https://github.com/vgmdj/go_practice/tree/master/algorithm/sort</a></p><ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>快速排序</li><li>归并排序</li><li>堆排序</li><li>希尔排序</li><li>计数排序</li><li>基数排序</li><li>桶排序<a id="more"></a></li></ul><h2 id="冒泡排序、选择排序"><a href="#冒泡排序、选择排序" class="headerlink" title="冒泡排序、选择排序"></a>冒泡排序、选择排序</h2><p>现在的作用只为了体现算法的思想，熟悉排序的操作，实际工作中没有使用这两个算法的情形，一般是使用其中的一部分操作。</p><ul><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(1)<!--more--></li></ul><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>将一个记录插入到已排好序的有序表中，从而得到一个新的，记录数加1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后 从第2个记录逐个进行插入操作，直到整个序列有序为止。<br>要点是，设立一个临界点，让左边的有序区推着临界点向后，直到临界点到达最后。<br>对于相等的元素，会把想插入的值放在后面，临界点右移，所以，相等的元素的前后顺序也没有变化，所以插入排序是稳定的</p><ul><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(1)</li></ul><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//插入排序</span><br><span class="line">func insertSort(nums []int) &#123;</span><br><span class="line">for i := 1; i &lt; len(nums)-1; i++ &#123;</span><br><span class="line">for j := i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j-1]; j-- &#123;</span><br><span class="line">nums[j], nums[j-1] = nums[j-1], nums[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快排是对冒泡排序的一种改进，使用范围很广，同时也是很很多语言的sort包中使用的其中一种方式（一般根据输入数据的情况选择插入排序、快速排序、堆排序中较为合适的一种）<br>它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列<br>可以根据荷兰国旗问题进行改进，使中间部分的值先排好，再对中间部分两边的进行递归</p><ul><li>时间复杂度： O(nlogn) ~ O(n^2)</li><li>平均时间复杂度： O(nlogn)</li><li>空间复杂度： O(1)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//快速排序</span><br><span class="line">func quickSort(values []int) &#123;</span><br><span class="line">if len(values) &lt;= 1 &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">mid, i := values[0], 1</span><br><span class="line">head, tail := 0, len(values)-1</span><br><span class="line">for head &lt; tail &#123;</span><br><span class="line">if values[i] &gt; mid &#123;</span><br><span class="line">values[i], values[tail] = values[tail], values[i]</span><br><span class="line">tail--</span><br><span class="line">&#125; else &#123;</span><br><span class="line">values[i], values[head] = values[head], values[i]</span><br><span class="line">head++</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">values[i-1] = mid</span><br><span class="line">quickSort(values[:i-1])</span><br><span class="line">quickSort(values[i:])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>分治法的一个典型应用，把整个序列分为左右两个有序序列，再对有序的序列归并成一个有序的序列<br>可有效的解决小和问题和逆序对的问题</p><ul><li>时间复杂度： O(nlogn)</li><li>空间复杂度： O(n)</li></ul><p>时间复杂度的计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">根据master公式： T(n) = aT(n/b)+O(n^c)</span><br><span class="line">a=2,b=2,c=1</span><br><span class="line">则 log(2,2) == c</span><br><span class="line">时间复杂度为：</span><br><span class="line">O(n^1*logn)，即 O(nlogn)</span><br></pre></td></tr></table></figure></p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func mergeSort(nums []int) []int &#123;</span><br><span class="line">if len(nums) &lt;= 1 &#123;</span><br><span class="line">return nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mid := len(nums) / 2</span><br><span class="line">nums1 := mergeSort(nums[:mid])</span><br><span class="line">nums2 := mergeSort(nums[mid:])</span><br><span class="line"></span><br><span class="line">return merge(nums1, nums2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func merge(nums1 []int, nums2 []int) []int &#123;</span><br><span class="line">var nums3 []int</span><br><span class="line">var position1, position2 int</span><br><span class="line"></span><br><span class="line">for position1 &lt; len(nums1) &amp;&amp; position2 &lt; len(nums2) &#123;</span><br><span class="line">if nums1[position1] &lt; nums2[position2] &#123;</span><br><span class="line">nums3 = append(nums3, nums1[position1])</span><br><span class="line">position1++</span><br><span class="line">&#125; else &#123;</span><br><span class="line">nums3 = append(nums3, nums2[position2])</span><br><span class="line">position2++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nums3 = append(nums3, nums1[position1:]...)</span><br><span class="line">nums3 = append(nums3, nums2[position2:]...)</span><br><span class="line"></span><br><span class="line">return nums3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的职业发展之路</title>
      <link href="/2017/03/05/%E6%88%91%E7%9A%84%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E4%B9%8B%E8%B7%AF-%E6%A0%A1%E6%8B%9B/"/>
      <content type="html"><![CDATA[<h2 id="毕业选择"><a href="#毕业选择" class="headerlink" title="毕业选择"></a>毕业选择</h2><p>随着毕业的临近，每天都会一次又一次的问自己，到底想干什么？</p><ul><li>程序员<br>使用大学里学到的技能，为自己赚点饭钱，不停挑战自己的极限，最终成为一个在计算机领域专家<br>优点：各方面还算熟悉，总归是一直在计算机专业环境下，无论是想学哪块，相信都不会太难<br>缺点：方面不明确，行业前景看不清，没有领路人</li><li>公务员<br>就在老家，房价便宜，生活没有压力，富不起来，但也不可能饿着，身边朋友多，生活自在悠闲<br>优点：安逸，没必要为了生存一天到晚的忙碌和委屈求全<br>缺点：有上限，从性格、资源等各个方面都不相信自己有官场升职的潜力</li><li>转行干土木<br>依靠家里的资源，不停的学习，最终自己出来单独接项目，成为光荣的包工头<br>优点：与当程序员正相反，家里大多是这一行，发展会很顺利，基本不会走弯路<br>缺点：各方面都不熟悉，最开始无论是想学哪一块，都会很费劲<a id="more"></a></li></ul><h2 id="最终抉择"><a href="#最终抉择" class="headerlink" title="最终抉择"></a>最终抉择</h2><p>年轻就是最大的本钱，虽说刚毕业后的三五年是人生最为关键的时期，每一年都很关键，但我本身也没有一个很明确的目标，同时我也相信自己无论选择哪一方面，最终都不会说没人要，或者是穷到吃不上饭，所以更多的是顺应自己内心的一点偏向，走上码农之路，去领略计算机职业世界的精彩。哪怕最终真的证明没这方面的天赋，行业没有自己想象的那么有趣，也可以再作出改变，我们一生可以做很多的发展选择，我相信无论哪一条路，只要能再次沉下心，去学习去锻炼，都是可以达到行业中等水平，至于能不能达到顶点，那就需要运气和悟性了。<br><!--more--></p><h2 id="校招选择"><a href="#校招选择" class="headerlink" title="校招选择"></a>校招选择</h2><p>春招没有参加，秋招来的公司并不算多，也没有什么大厂，最好的选择反而是亚信了，但是笔试题都跪的一塌糊涂，最终的选择是大连的外包头子-东软<br>最初的想法很简单，东软有大公司的制度和培训，各种外包项目也很容易让人更加了解整个计算机行业的情况，稍稍锻炼个一两年，基本就可以看清自己应该怎么选择了。<br>一年后再来回顾，还是觉着自己当时的选择并没有什么明显的错误，也可能直接去北京找互联网公司更好，但主要还是看个人，差距不会太大。</p><h2 id="东软生活"><a href="#东软生活" class="headerlink" title="东软生活"></a>东软生活</h2><p>平稳，安逸的一年，各路领导都很好，很照顾我们，同学也多，老乡也多，生活也渐渐丰富起来。每天下班后，健个身或者是去旁边的大学里跑步，每个周六都可以在公司里打网球，周日一群单身狗约着一块吃自助，看电影，确实是一段很美好的经历。很多时候，我都在想，如果没有改变，就一直这样下去，可能也能活成别人眼中的潇洒人生。<br>但终归是年轻，总想着让生活更丰富一些，接触到更接近这个时代前沿的东西，参与到推动整个世界发展的技术研发中来，毕竟每个程序员的梦想都是去改变世界，一年期的调整已经足够，是时候开始重新进行人生规划，做一些自己想去做的事情了。</p><h2 id="目标北京"><a href="#目标北京" class="headerlink" title="目标北京"></a>目标北京</h2><p>祝自己好运</p>]]></content>
      
      <categories>
          
          <category> 职业发展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职业发展 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法学习-总览</title>
      <link href="/2017/03/04/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/"/>
      <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>算法是程序员实力体现的一部分，在日常工作中，不停寻求最优算法，应该是程序员的基本修奍了<br>下面先做一些总结，留着以后复习使用<br><a id="more"></a></p><h2 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h2><ul><li>蛮力算法</li><li>迭代算法</li><li>分治算法</li><li>贪心算法</li><li>动态规划</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h3><ul><li>时间复杂度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">递归master公式</span><br><span class="line">T(n) = aT(n/b)+O(n^c)</span><br><span class="line">- O(n*log(b,a))         log(b,a)&gt;c</span><br><span class="line">- O(n^c*logn)           log(b,a)=c</span><br><span class="line">- O(n^d)                log(b,a)&lt;c</span><br></pre></td></tr></table></figure></li></ul><!--more--><ul><li>空间复杂度<!--more--></li></ul><h2 id="算法练习"><a href="#算法练习" class="headerlink" title="算法练习"></a>算法练习</h2><p>oj：</p><ul><li><a href="http://www.lintcode.com" target="_blank" rel="noopener">http://www.lintcode.com</a></li><li><a href="http://www.leetcode.com" target="_blank" rel="noopener">http://www.leetcode.com</a><!--more--></li></ul><p>golang算法代码库：</p><ul><li><a href="http://github.com/vgmdj/prictice_guide" target="_blank" rel="noopener">http://github.com/vgmdj/prictice_guide</a></li></ul>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>github+hexo blog 搭建过程（二）：配置</title>
      <link href="/2017/03/04/github-hexo-blog-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B-%E4%BA%8C-%EF%BC%9A%E9%85%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<h2 id="站点配置文件-config-yml修改"><a href="#站点配置文件-config-yml修改" class="headerlink" title="站点配置文件_config.yml修改"></a>站点配置文件_config.yml修改</h2><p>主体可参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">hexo next使用文档</a>，下面对其进行补充。<br><a id="more"></a></p><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>推荐注释而不是删除新增<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">#theme: landscape</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></p><!--more--><h3 id="语言配置"><a href="#语言配置" class="headerlink" title="语言配置"></a>语言配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">language: zh-Hans</span><br><span class="line"></span><br><span class="line">修改为：</span><br><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure><!--more--><h3 id="新增sitemap"><a href="#新增sitemap" class="headerlink" title="新增sitemap"></a>新增sitemap</h3><h4 id="使用sitemap生成工具"><a href="#使用sitemap生成工具" class="headerlink" title="使用sitemap生成工具"></a>使用sitemap生成工具</h4><p>配置站点地图可以将站点添加进百度收录，之后就可以在百度里搜索到站点的内容了。<br>在blog根目录执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure></p><!--more--><h4 id="修改站点-config-yml配置文件"><a href="#修改站点-config-yml配置文件" class="headerlink" title="修改站点_config.yml配置文件"></a>修改站点_config.yml配置文件</h4><p>新增内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure></p><p>修改内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: http://blog.vgmdj.cn/</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line">其中url改为自己的域名</span><br></pre></td></tr></table></figure></p><!--more--><h4 id="向百度或谷歌提交网站"><a href="#向百度或谷歌提交网站" class="headerlink" title="向百度或谷歌提交网站"></a>向百度或谷歌提交网站</h4><p>可以参考内容 <a href="https://www.cnblogs.com/tengj/p/5357879.html" target="_blank" rel="noopener">主动提交</a><br>如果使用next主题，可以简化这一过程<br><a href="#jump">next 向百度站长提交内容</a><br><!--more--></p><h3 id="开启本地图片存放"><a href="#开启本地图片存放" class="headerlink" title="开启本地图片存放"></a>开启本地图片存放</h3><p>可查看链接，但是只有新生成的才有，如果是操作前生成的文章，则不会生成文件夹，需要自己手动创建<br><a href="https://www.jianshu.com/p/c2ba9533088a" target="_blank" rel="noopener">hexo博客图片问题</a><br><!--more--></p><h3 id="hexo-deploy配置"><a href="#hexo-deploy配置" class="headerlink" title="hexo deploy配置"></a>hexo deploy配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: git@github.com:vgmdj/vgmdj.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p><a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">其他配置</a></p><p>注意：hexo d的使用需要先配置好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>ssh免密登录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 返回用户根目录 /c/Users/`whoami`</span><br><span class="line">cd</span><br><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br><span class="line"></span><br><span class="line">---- 一顿回车 ----</span><br><span class="line"></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>将cat 输出的内容添加到github ssh key中<br>打开<a href="https://github.com/settings/ssh" target="_blank" rel="noopener">new SSH key</a> 添加密钥，title随便写，key为刚刚cat输出的内容<br><!--more--></p><h3 id="github-cname文件被覆盖的问题"><a href="#github-cname文件被覆盖的问题" class="headerlink" title="github cname文件被覆盖的问题"></a>github cname文件被覆盖的问题</h3><p>cname文件注意要放在根目录下的source里，这样才不会每次部署的时候，将cname文件覆盖掉<br><!--more--></p><h2 id="主题配置文件-config-yml修改"><a href="#主题配置文件-config-yml修改" class="headerlink" title="主题配置文件_config.yml修改"></a>主题配置文件_config.yml修改</h2><p>主体可参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">hexo next使用文档</a>，下面对其进行补充。<br><!--more--></p><h3 id="菜单设置"><a href="#菜单设置" class="headerlink" title="菜单设置"></a>菜单设置</h3><p>当前next主题使用的是新的指定icon的方式，即 “||” 前是page地址，后面是想要显示的icon<br>next使用的是<a href="https://fontawesome.com/icons?d=gallery" target="_blank" rel="noopener">fontawesome</a>里的图标，配置文件里的图标都可以进行替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home  </span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br></pre></td></tr></table></figure></p><p>菜单中每项的意义都可以在语言配置文件中查看 /theme/next/language/zh-CN<br>同时，自己新增的菜单也需要在对应的语言配置文件中设置<br><!--more--></p><h3 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h3><p>需要注意的是，如果开启了leancloud_visitors，会和busuanzi里的post_views冲突，结果会是在文章里出现两个阅读量统计，所以需要将busuanzi里的post_views置为false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.</span><br><span class="line">leancloud_visitors:</span><br><span class="line">enable: true</span><br><span class="line">app_id: your appid</span><br><span class="line">app_key: your app_key</span><br><span class="line"></span><br><span class="line"># Show Views/Visitors of the website/page with busuanzi.</span><br><span class="line"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: false</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure></p><!--more--><h3 id="sitemap配置"><a href="#sitemap配置" class="headerlink" title="sitemap配置"></a><span id="jump">sitemap配置</span></h3><p>next主题对配置过程作了简化，只需要在主题配置文件里修改即可实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seo: false</span><br><span class="line">baidu_push: false</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line">seo: true</span><br><span class="line">baidu_push: true</span><br></pre></td></tr></table></figure></p><p>查看/theme/next/layout/_third-party/seo/baidu-push.swig文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.baidu_push %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">  var bp = document.createElement(&apos;script&apos;);</span><br><span class="line">  var curProtocol = window.location.protocol.split(&apos;:&apos;)[0];</span><br><span class="line">  if (curProtocol === &apos;https&apos;) &#123;</span><br><span class="line">      bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;;        </span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">      bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  var s = document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">  s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>发现和主动推送的实现过程一致<br><!--more--></p><h3 id="gitment-评论"><a href="#gitment-评论" class="headerlink" title="gitment 评论"></a>gitment 评论</h3><p>使用畅言作为评论系统，首页也能显示评论数，还能使用第三方如qq等的登录，但是缺点也很明显，新用户评论，需要绑定手机号等一系列操作，有点麻烦。<br>考虑到受众，使用github 的issues显然更好一点。但是这个gitment的问题也比较多，其中关键的一点是标题起的稍稍长一点，都会导致无法正常初始化评论。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修改/theme/next/layout/_third-party/comments/gitment.swig</span><br><span class="line"></span><br><span class="line">id: window.location.pathname,</span><br><span class="line">改为：</span><br><span class="line">id: &apos;&#123;&#123; page.date &#125;&#125;&apos;,</span><br></pre></td></tr></table></figure></p><p>这种方式下，只要注意每篇博文的data不要乱改，导致时间一致冲突，就不会有问题<br>方法来源于作者君的<a href="https://github.com/imsun/gitment/issues" target="_blank" rel="noopener">issues</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>百度统计、腾讯分析、畅言等都只是去各自的官网注册账号，然后在主题配置文件里填好相应的配置即可<br><!--more--></p><h2 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h2><p>这里只是一些我看着不太统一的地方，将其小小的修改一下<br><!--more--></p><h3 id="添加总访客量、总访问量文字"><a href="#添加总访客量、总访问量文字" class="headerlink" title="添加总访客量、总访问量文字"></a>添加总访客量、总访问量文字</h3><p>开启busuanzi后，页面最下方会生成一个访客量与访问量的统计，但只有图标与数字，而没有相应的文字<br>修改/theme/next/layout/_partials/analytics/busuanzi-counter.swig文件，在相应位置添加“总访客量：”与“总访问量：”的文字解释即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.busuanzi_count.enable %&#125;</span><br><span class="line">&lt;div class=&quot;busuanzi-count&quot;&gt;</span><br><span class="line">  &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line">    &lt;span class=&quot;site-uv&quot; title=&quot;&#123;&#123; __(&apos;footer.total_visitors&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;&gt; 总访客量：&lt;/i&gt;</span><br><span class="line">      &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.busuanzi_count.total_views %&#125;</span><br><span class="line">    &lt;span class=&quot;site-pv&quot; title=&quot;&#123;&#123; __(&apos;footer.total_views&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;&quot;&gt; 总访问量：&lt;/i&gt;</span><br><span class="line">      &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><!--more--><h3 id="添加网站备案号"><a href="#添加网站备案号" class="headerlink" title="添加网站备案号"></a>添加网站备案号</h3><p>打开/theme/next/layout/_partials/footer.swig<br>在copyright后，添加代码即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;copyright&quot;&gt;&#123;#</span><br><span class="line">#&#125;&#123;% set current = date(Date.now(), &quot;YYYY&quot;) %&#125;&#123;#</span><br><span class="line">#&#125;&amp;copy; &#123;% if theme.footer.since and theme.footer.since != current %&#125;&#123;&#123; theme.footer.since &#125;&#125; &amp;mdash; &#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;&lt;span itemprop=&quot;copyrightYear&quot;&gt;&#123;&#123; current &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;with-love&quot;&gt;</span><br><span class="line">  &lt;i class=&quot;fa fa-&#123;&#123; theme.footer.icon &#125;&#125;&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;author&quot; itemprop=&quot;copyrightHolder&quot;&gt;&#123;&#123; theme.footer.copyright || config.author &#125;&#125;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">!!!这里就是添加位置！！！</span><br></pre></td></tr></table></figure></p><p>添加内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.miitbeian.gov.cn/&quot;&gt;京ICP备xxxxxx号&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><!--more--><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p>至此，一个人个博客已基本完成，其实next已经把很多的东西都简化到一个配置参数，我们需要做的，只是看懂这个参数代表的意义，然后填上他，接着运行hexo命令，即可轻松的调试部署<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">check http://localhost:4000, 发现无误后</span><br><span class="line"></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 站点建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>github+hexo blog 搭建过程(一)：准备</title>
      <link href="/2017/03/03/github-blog-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直都有记录的习惯，但内容大多都分散在各个网站，现结合github，使用hexo来搭建一个个人博客，将点滴的记录都聚合在一起，下面是一些关键的搭建过程，一方面作为分享，一方面作为备忘，仅供参考，如有问题请留言通知，谢谢支持！<br>ps: 准备过程和搜索内容没多少变化，不过多记录<br><a id="more"></a></p><h1 id="基本环境准备"><a href="#基本环境准备" class="headerlink" title="基本环境准备"></a>基本环境准备</h1><p>下载安装nodejs和git，我的搭建环境win10 64，可在git bash下运行如下命令测试环境：</p><ul><li>node -v</li><li>npm -v</li><li>git –version<!--more--></li></ul><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>安装过程不再叙述，hexo的安装与使用一直没有什么变化，可自行搜索，安装成功可运行测试命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure></p><p>大致命令集如下：</p><ul><li>npm -g hexo-cli</li><li>cd /c/Users/`whoami`</li><li>mkdir blog</li><li>cd blog</li><li>hexo init</li><li>npm install</li><li>hexo g</li><li>hexo s</li></ul><p>如果一切顺利的话，打开浏览器，访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 便可看到hexo生成的默认主题页面<br><!--more--></p><h1 id="准备主题"><a href="#准备主题" class="headerlink" title="准备主题"></a>准备主题</h1><p>以next主题为例，<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">github地址</a><br><br>在blog根目录执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><p>现在我们的blog文件夹内就有了三个配置文件</p><ul><li>站点配置文件$addr/blog/_config.yml</li><li>next主题配置文件$addr/blog/themes/next/_config.yml</li><li>default主题配置文件$addr/blog/themes/landscape/_config.yml</li></ul><p>修改站点配置文件，即可更换主题，后面我们再详细介绍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#theme: landscape</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></p><!--more--><h1 id="hexo-指南"><a href="#hexo-指南" class="headerlink" title="hexo 指南"></a>hexo 指南</h1><p>hexo 常用操作可见于：<br><a href="http://blog.vgmdj.cn/2018/03/02/Hexo-introduction/">Hexo 使用指南</a></p><p>hexo next主题教程：<br><a href="http://theme-next.iissnan.com" target="_blank" rel="noopener">next 官网</a><br>ps: 最好的教程都来源于代码和注释，其次是官网，本篇只是作为补充。<br><!--more--></p>]]></content>
      
      <categories>
          
          <category> 站点建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo 使用指南</title>
      <link href="/2017/03/02/Hexo-introduction/"/>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><br><a id="more"></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a><br><!--more--></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a><br><!--more--></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a><br><!--more--></p><h2 id="Trouble-Shooting"><a href="#Trouble-Shooting" class="headerlink" title="Trouble Shooting"></a>Trouble Shooting</h2><h3 id="首页显示排版混乱"><a href="#首页显示排版混乱" class="headerlink" title="首页显示排版混乱"></a>首页显示排版混乱</h3><p>在每个需要的地方，加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><p>例如，在一级标题和二级标题间截断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">xxxxxxx</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line">xxxxxxxx</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line">xxxxxxxx</span><br><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure></p><h3 id="标签和分类数量不正确"><a href="#标签和分类数量不正确" class="headerlink" title="标签和分类数量不正确"></a>标签和分类数量不正确</h3><p>删除.deploy_git文件夹和db.json，再删除public文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>这里g执行两次是为了防止小机率的页面渲染不充分的问题<br>s是预览，可以先查看一下有没有什么问题<br>再次部署后，问题解决</p>]]></content>
      
      <categories>
          
          <category> 站点建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
