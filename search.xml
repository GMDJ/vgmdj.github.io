<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>微服务学习-数据一致性理论</title>
      <link href="/2018/05/14/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E7%90%86%E8%AE%BA/"/>
      <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>分布式系统架构中，分布式事务问题是一个绕不过去的挑战。而微服务架构的流行，让分布式事问题日益突出！<br>对于单体应用而言，所有的数据库操作都在一起，可以很简单的使用本地事务，来保证数据的ACID。<br>但是对于分布式系统，系统由多个独立的服务组成，那么如何解决分布式调用时候数据的一致性就成了一个问题。<br>具体业务场景如下，比如一个业务操作，如果同时调用服务 A、B、C，需要满足要么同时成功；要么同时失败。A、B、C 可能是多个不同部门开发、部署在不同服务器上的远程服务。<br><a id="more"></a></p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h2><ul><li><p>强一致性<br>当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。但是这种实现对性能影响较大。</p></li><li><p>弱一致性<br>系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。但会尽可能保证在某个时间级别（比如秒级别）之后，可以让数据达到一致性状态。</p></li><li><p>最终一致性<br>弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS是一个典型的最终一致性系统。</p></li></ul><h2 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h2><blockquote><p>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。</p></blockquote><p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p><ul><li>Consistency 一致性<br>一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。</li></ul><ul><li>Availability 可用性<br>可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。</li></ul><p>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。也就是，该系统使用的任何算法必须最终终止。当同时要求分区容忍性时，这是一个很强的定义：即使是严重的网络错误，每个请求必须终止。</p><p>好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下可用性和分布式数据冗余，负载均衡等有着很大的关联。</p><ul><li>Partition Tolerance分区容错性<br>分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</li></ul><p>分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。</p><h2 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h2><blockquote><p>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。<br>BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。</p></blockquote><ul><li>基本可用（Basically Available）<br>基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。</li></ul><p>电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</p><ul><li><p>软状态（ Soft State）<br>软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</p></li><li><p>最终一致性（ Eventual Consistency）<br>最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p></li></ul><p>ACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。</p><p>ACID和BASE代表了两种截然相反的设计哲学</p><p>在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。</p><h2 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h2><blockquote><p>分布式事务是指会涉及到操作多个数据库的事务。其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）</p></blockquote><p>在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足ACID。但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以从理论上讲，两台机器理论上无法达到一致的状态。如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要不全部都执行，要么全部的都不执行。但是，一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以他也就不知道本次事务到底应该commit还是 roolback。所以，常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行。</p><h2 id="二阶提交协议（Two-Phase-Commitment-Protocol）"><a href="#二阶提交协议（Two-Phase-Commitment-Protocol）" class="headerlink" title="二阶提交协议（Two Phase Commitment Protocol）"></a>二阶提交协议（Two Phase Commitment Protocol）</h2><h2 id="三阶提交协议（Three-Phase-Commitment-Protocol）"><a href="#三阶提交协议（Three-Phase-Commitment-Protocol）" class="headerlink" title="三阶提交协议（Three Phase Commitment Protocol）"></a>三阶提交协议（Three Phase Commitment Protocol）</h2><h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2>]]></content>
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微服务学习-总览</title>
      <link href="/2018/05/11/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/"/>
      <content type="html"><![CDATA[<h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>使用基于微服务的方式使得应用程序开发变得更快更容易管理，它只需要较少的人力就能实现更多的功能，可以更快更容易地部署。把应用程序设计成一套微服务，更加容易在多台具有负载均衡的服务器上运行，使其能够轻松应对需求高峰、由于时间推移而平稳增长的需求和由于硬件或者软件问题导致的宕机事故。<br>微服务，从本质意义上看，还是SOA架构。但内涵有所不同，微服务并不绑定某种特殊的技术，在一个微服务的系统中，可以有Java编写的服务，也可以有Python编写的服务，他们是靠Restful架构风格统一成一个系统的。<br>最粗浅的理解就是将微服务之间的交互看作是各种字符串的传递，各种语言都可以很好的处理字符串，所以微服务本身与具体技术实现无关，扩展性强。另一个不同是微服务架构本身很轻，底层也有类似于SOA的总线，不过非常轻薄，现在看到的就两种方式：MQ和HTTP，而HTTP都不能完全等同于总线，而仅仅是个信息通道。<br>所以，基于这种简单的的协议规范，无论是兼容老旧系统，还是上线新业务，都可以随着时代的步伐，滚动升级。比如：你去年还在使用.NET技术，今年就可以平滑的过度到Go了，而且系统已有服务不用改动。所以微服务架构，既保护用户已有投资，又很容易向新技术演进。<br>本次研究主要是学习相关内容，并根据实际案例进行重构开发。<br><a id="more"></a></p><h1 id="单体与微服务"><a href="#单体与微服务" class="headerlink" title="单体与微服务"></a>单体与微服务</h1><p>单体应用在项目的早期阶段是可以良好运行的，但随着时间的推移，就会逐渐暴露出难以忍受的缺点</p><ul><li>应用程序趋于复杂使得基本代码难以理解</li><li>应用程序启动编译等变成问题，任意一个小的变动都需要整体的重新编译，使大量时间处于等待，降低效率</li><li>不同模块存在资源需求冲突时，单体应用可能难以扩展。例如，一个模块可能会执行 CPU 密集型图像处理逻辑，理想情况下是部署在 Amazon EC2 Compute Optimized 实例中。另一个模块可能是一个内存数据库，最适合部署到 EC2 Memory-optimized 实例。然而，由于这些模块被部署在一起，就必须在硬件选择上做出妥协</li><li>较低的可靠性。因为所有模块都运行在同一进程中。任何模块的一个 bug，比如内存泄漏，都可能会拖垮整个进程。此外，由于应用程序的所有实例都是相同的，该错误将影响到整个应用的可用性。</li><li>单体应用使得采用新框架和语言变得非常困难。例如，我们假设您有 200 万行代码使用了 XYZ 框架编写。如果使用较新的 ABC 框架来重写整个应用，这将非常昂贵（在时间和成本方面），即使框架非常好。因此，这对于采用新技术是一个非常大的障碍。在项目开始时，您无论选择何种新技术都会感到困扰。</li></ul><p>单体应用存在种种的缺陷，而采用现在所谓的微服务架构模式，就可以解决这些问题</p><h1 id="微服务优点"><a href="#微服务优点" class="headerlink" title="微服务优点"></a>微服务优点</h1><p>微服务架构模式有许多非常好的地方。</p><ul><li><p>第一，它解决了复杂问题。它把可能会变得庞大的单体应用程序分解成一套服务。虽然功能数量不变，但是应用程序已经被分解成可管理的块或者服务。每个服务都有一个明确定义边界的方式，如远程过程调用（RPC）驱动或消息驱动 API。微服务架构模式强制一定程度的模块化，实际上，使用单体代码来实现是极其困难的。因此，使用微服务架构模式，<strong>个体服务能被更快地开发，并更容易理解与维护</strong>。</p></li><li><p>第二，这种架构使得每个服务都可以由一个团队独立专注开发。开发者 <strong>可以自由选择任何符合服务 API 契约的技术</strong>。当然，更多的组织是希望通过技术选型限制来避免完全混乱的状态。然而，这种自由意味着开发人员不再有可能在这种自由的新项目开始时使用过时的技术。当编写一个新服务时，他们可以选择当前的技术。此外，由于服务较小，使用当前技术重写旧服务将变得更加可行。</p></li><li><p>第三，微服务架构模式可以实现每个微服务 <strong>独立部署</strong>。开发人员根本不需要去协调部署本地变更到服务。这些变更一经测试即可立即部署。比如，UI 团队可以执行 A|B 测试，并快速迭代 UI 变更。微服务架构模式使得持续部署成为可能。</p></li><li><p>最后，微服务架构模式使得每个服务能够 <strong>独立扩展</strong>。您可以仅部署满足每个服务的容量和可用性约束的实例数目。此外，您可以使用与服务资源要求最匹配的硬件。例如，您可以在 EC2 Compute Optimized 实例上部署一个 CPU 密集型图像处理服务，并且在 EC2 Memory-optimized 实例上部署一个内存数据库服务。</p></li></ul><h1 id="微服务缺点"><a href="#微服务缺点" class="headerlink" title="微服务缺点"></a>微服务缺点</h1><p>与其他技术一样，微服务架构模式也存在着缺点。</p><ul><li><p>微服务一个主要缺点是由于微服务是一个分布式系统，其使得整体变得复杂。开发者需要选择和实现基于消息或者 RPC 的进程间 <strong>通信机制</strong> 。此外，由于目标请求可能很慢或者不可用，他们必须要编写代码来处理局部故障。虽然这些并不是很复杂、高深，但模块间通过语言级方法/过程调用相互调用，这比单体应用要复杂得多。</p></li><li><p>微服务的另一个挑战是 <strong>分区数据库架构</strong>。更新多个业务实体的业务事务是相当普遍的。这些事务在单体应用中的实现显得微不足道，因为单体只存在一个单独的数据库。在基于微服务的应用程序中，您需要更新不同服务所用的数据库。通常不会选择分布式事务，不仅仅是因为 CAP 定理。他们根本不支持如今高度可扩展的 NoSQL 数据库和消息代理。您最后不得不使用基于最终一致性的方法，这对于开发人员来说更具挑战性。</p></li><li><p><strong>测试</strong> 微服务应用程序也很复杂。例如，使用现代框架如 Spring Boot，只需要编写一个测试类来启动一个单体 web 应用程序并测试其 REST API。相比之下，一个类似的测试类对于微服务来说需要启动该服务及其所依赖的所有服务，或者至少为这些服务配置存根。再次声明，虽然这不是一件高深的事情，但不要低估了这样做的复杂性。</p></li><li><p>微服务架构模式的另一个主要挑战是实现了跨越 <strong>多服务变更</strong>。例如，我们假设您正在实现一个变更服务 A、服务 B 和 服务 C 的需求，其中 A 依赖于 B，且 B 依赖于 C。在单体应用程序中，您可以简单地修改相应的模块、整合变更并一次性部署他们。相反，在微服务中您需要仔细规划和协调出现的变更至每个服务。例如，您需要更新服务 C，然后更新服务 B，最后更新服务 A。幸运的是，大多数变更只会影响一个服务，需要协调的多服务变更相对较少。</p></li><li><p><strong>部署</strong> 基于微服务的应用程序也是相当复杂的。一个单体应用可以很容易地部署到基于传统负载均衡器的一组相同服务器上。每个应用程序实例都配置有基础设施服务的位置（主机和端口），比如数据库和消息代理。相比之下，微服务应用程序通常由大量的服务组成。每个服务都有多个运行时实例。还有更多的移动部件需要配置、部署、扩展和监控。此外，您还需要实现服务发现机制，使得服务能够发现需要与之通信的任何其他服务的位置（主机和端口）。因此，要成功部署微服务应用程序，需要求开发人员能高度控制部署方式和高度自动化。<br>自动化微服务部署的另一个方式是开发自己的 PaaS (platform as a service)。一个普遍的起点是使用集群方案，如 Kubernetes，与 Docker 等容器技术相结合。</p></li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/DocsHome/microservices" target="_blank" rel="noopener">https://github.com/DocsHome/microservices</a></li><li><a href="http://www.infoq.com/cn/articles/what-complete-micro-service-system-should-include" target="_blank" rel="noopener">http://www.infoq.com/cn/articles/what-complete-micro-service-system-should-include</a></li></ul>]]></content>
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 微服务 </tag>
            
            <tag> 分布式系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>容器学习-k8s搭建</title>
      <link href="/2018/04/26/%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0-k8s%E6%90%AD%E5%BB%BA/"/>
      <content type="html"><![CDATA[<h1 id="kubernetes-学习"><a href="#kubernetes-学习" class="headerlink" title="kubernetes 学习"></a>kubernetes 学习</h1><p>目标，搭建好环境，使k8s集群运行起来，在其上部署一个服务，并可以正常访问<br>当然，单单一个k8s搭建完成还是不够的，还需要一系统的应用来保证服务的高可用，如负载均衡，多master防单点故障等<br>会在之后进行分析<br><a id="more"></a></p><h1 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h1><h2 id="源码包"><a href="#源码包" class="headerlink" title="源码包"></a>源码包</h2><p>  第一步，先从github上把源码下载到本地，再按照文档的要求一步一步搭建<br>  源码地址： <a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes</a><br>  安装过程可以看：　<a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/" target="_blank" rel="noopener">https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/</a></p><h2 id="完成目标"><a href="#完成目标" class="headerlink" title="完成目标"></a>完成目标</h2><p>根据官方文档走，最终搭建成功后，应该最终情况为</p><ul><li>一个master节点，上面运行着etcd提供k8s数据管理, apiserver, scheduler等提供k8s管控</li><li>n个node节点，其上主要运行服务</li></ul><p>从这里也可以看出，官方不推荐把服务也运行在master上的原因，单master结点，etcd还只在其上，一但master结点压力太大挂掉，虽然不影响node上服务的运行，但将失去变更调控的能力。<br>当然生产环境高可用肯定不能只这样保证，但如果没那么高的需求，这样的一个简单的配置也是可用的</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><h3 id="使用apt-yum安装kubeadm"><a href="#使用apt-yum安装kubeadm" class="headerlink" title="使用apt/yum安装kubeadm"></a>使用apt/yum安装kubeadm</h3><p>这里第一步需要添加kubernetes的密钥，但是这个下载链接是被墙的，这里我放在自己服务器上，有需要的可以<a href="/kubernetes/apt-key.gpg">下载</a>，之后apt-key add apt-key.gpg即可<br>同时，apt源也需要更换成中科大的kubernetes源<br>ps: 之前阿里云源更新不及时，可以会造成版本不一致，现在两者都是最新版本了，就没什么顾虑了。截至到目前为止，都是1.10.1</p><ul><li>ubuntu下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt-get update &amp;&amp; apt-get install -y apt-transport-https curl</span><br><span class="line">curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -</span><br><span class="line">cat &lt;&lt;EOF &gt; /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">deb http://mirrors.ustc.edu.cn/kubernetes/apt/ kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install -y kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure><ul><li>centos下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">      http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line">setenforce 0</span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure><h3 id="master-节点配置"><a href="#master-节点配置" class="headerlink" title="master 节点配置"></a>master 节点配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16</span><br><span class="line"></span><br><span class="line">echo export KUBECONFIG=/etc/kubernetes/admin.conf &gt;&gt; /etc/profile</span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><p>注意，这里有两个点要注意，一个是要加–pod-network-cidr=10.244.0.0/16，在官方文档的第二步没有出现，等我做到第三步了再出现，有点坑，还得kubeadm reset 重置一下，再来一遍init(也可以在配置文件kube-controller-manager.yaml里加上后，再重启服务，总体感觉不如reset + init来的利索)<br>另一点，就是这里的init一般情况下基本都成功不了，会卡在下载镜像这一步，原因还是墙的问题，如果国内没梯子出现下面这句，就不用等了，等了也是白等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This often takes around a minute; or longer if the control plane images have to be pulled.</span><br></pre></td></tr></table></figure><p>通过log可以看出，这是在docker pull的时候卡住了，这里分享一个解决方案</p><ul><li>先在master上建立一个docker registry</li><li>再使用国内源把要下载的镜像下下来，保存好后再传到master上，然后tag改名</li><li>所有需要的images都在/etc/kubernetes/manifest/*.yaml下</li></ul><h3 id="flannel-配置"><a href="#flannel-配置" class="headerlink" title="flannel 配置"></a>flannel 配置</h3><p>先设置cni的前置条件，CNI（Container Network Interface）是CNCF旗下的一个项目，由一组用于配置Linux容器的网络接口的规范和库组成，同时还包含了一些插件。CNI仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。通过此链接浏览该项目：<a href="https://github.com/containernetworking/cni" target="_blank" rel="noopener">https://github.com/containernetworking/cni</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.bridge.bridge-nf-call-iptables=1</span><br></pre></td></tr></table></figure><p>再配置flannel<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure></p><p>这里推荐先把yml文件下载下来，把其中的镜像源替换成国内源</p><ul><li>状态验证</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">此时可以使用</span><br><span class="line">kubectl get pods --all-namespaces</span><br></pre></td></tr></table></figure><p>来查看当前pod情况，如果flannel正常，就可以配置node节点了</p><h3 id="node-节点配置"><a href="#node-节点配置" class="headerlink" title="node 节点配置"></a>node 节点配置</h3><p>先把之前下载的镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker save k8s.gcr.io/xxx &gt; xxx.tar</span><br><span class="line"></span><br><span class="line">scp xxx.tar root@xxx:~/</span><br><span class="line"></span><br><span class="line">切到node上后，</span><br><span class="line"></span><br><span class="line">docker load &lt; xxx.tar</span><br></pre></td></tr></table></figure></p><p>镜像加载完后，照着master上成功后，出现的命令，在node上来一下就好了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</span><br></pre></td></tr></table></figure></p><h1 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h1><p>总的来说，现在k8s搭建还是很简单的，主要遇到的问题，主要是GFW问题，再有就是版本不一致带来的问题</p><ul><li>kubeadm join err</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ERROR CRI]: unable to check if the container runtime at &quot;/var/run/dockershim.sock&quot; is running: fork/exec /opt/golang/bin/crictl -r /var/run/dockershim.sock info: no such file or directory</span><br></pre></td></tr></table></figure><p>crictl 当前仍然不稳定，如果是使用推荐的go get 的方式来安装的，感觉问题反而更大。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">That bug-fix is only applicable after release v1.10. Currently you can try it in all v1.10.0 beta versions, v1.10.0 rc version and v1.11.0 alpha version.</span><br></pre></td></tr></table></figure></p><ul><li>kubeadm init后，kube-dns状态异常<br>进入描述查看，发现message：0/1 nodes are available: 1 node(s) were not ready.<br>发现问题是 node not ready ，再去解决node 问题，dns正常</li></ul><ul><li><p>源码编译 make 失败<br>原因，内存不足，如果想要make编译，需要8G内存应该<br><a href="https://github.com/kubernetes/kubernetes/issues/42599" target="_blank" rel="noopener">https://github.com/kubernetes/kubernetes/issues/42599</a></p></li><li><p>crictl 冲突</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[WARNING FileExisting-crictl]: crictl not found in system path</span><br></pre></td></tr></table></figure></li></ul><p>解决方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/kubernetes-incubator/cri-tools/cmd/crictl</span><br></pre></td></tr></table></figure></p><ul><li>kubeadm init时卡住<br>解决方式如上</li></ul>]]></content>
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 分布式系统 </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>微信开发问题小结</title>
      <link href="/2018/04/23/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/"/>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>微信公众号开发告一段落，在这里作一下期间遇到的各种问题</p><h1 id="oauth2-授权重定向两次问题"><a href="#oauth2-授权重定向两次问题" class="headerlink" title="oauth2 授权重定向两次问题"></a>oauth2 授权重定向两次问题</h1><p>每次从微信那边来的重定向，都有两次，一次什么信息都不带，一次则是正常的含有code和state的跳转，这样就带来了一系列的问题，包含让error信息混乱，加大并发压力等<br>使用第三方代理域名或者是用nginx做反向代理，在向微信服务器发送请求的时候，微信回调时，会认为你的域名请求不一致，会回调两次，重定向你的服务器两次。<br>解决方式也很简单</p><ul><li>更改正式域名，不使用反向代理就会回调一次</li><li>加参数使其只返回一次</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">请求里加上&amp;connect_redirect=1</span><br><span class="line"></span><br><span class="line">func AuthCodeURL(appId, redirectURI, scope, state string) string &#123;</span><br><span class="line">return &quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&quot; + url.QueryEscape(appId) +</span><br><span class="line">&quot;&amp;redirect_uri=&quot; + url.QueryEscape(redirectURI) +</span><br><span class="line">&quot;&amp;response_type=code&amp;scope=&quot; + url.QueryEscape(scope) +</span><br><span class="line">&quot;&amp;state=&quot; + url.QueryEscape(state) +</span><br><span class="line">&quot;#wechat_redirect&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line">func AuthCodeURL(appId, redirectURI, scope, state string) string &#123;</span><br><span class="line">return &quot;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&quot; + url.QueryEscape(appId) +</span><br><span class="line">&quot;&amp;redirect_uri=&quot; + url.QueryEscape(redirectURI) +</span><br><span class="line">&quot;&amp;response_type=code&amp;scope=&quot; + url.QueryEscape(scope) +</span><br><span class="line">&quot;&amp;state=&quot; + url.QueryEscape(state) +</span><br><span class="line">“&amp;connect_redirect=1” +</span><br><span class="line">&quot;#wechat_redirect&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 工作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微信开发 </tag>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql学习-索引</title>
      <link href="/2018/04/06/mysql%E5%AD%A6%E4%B9%A0-%E7%B4%A2%E5%BC%95/"/>
      <content type="html"><![CDATA[<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是存储引擎找到记录的一种数据结构，而索引优化是对查询性能优化最有效的手段。其类似于一本书的目录部分，如果想在一本书中找到某个特定主题，一般会先看书中的“索引部分”，找到对应的页码。<br>在MySQL中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。<br>索引可以包含一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。<br><a id="more"></a></p><h1 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h1><h2 id="根据功能划分"><a href="#根据功能划分" class="headerlink" title="根据功能划分"></a>根据功能划分</h2><ul><li><p>UNIQUE<br>唯一索引，不可以出现相同值，但是可以有NULL值</p></li><li><p>INDEX<br>普通索引，可以出现相同值</p></li><li><p>PRIMARY KEY<br>主键索引，不允许出现相同的值,且不能为NULL值,一个表只能有一个primary_key索引</p></li><li><p>FULLTEXT INDEX<br>全文索引，可以针对值中的某个单词设置索引,但是只有myisam以及英文支持,并且效率不高，特殊场景下使用</p></li></ul><h2 id="根据数据结构划分"><a href="#根据数据结构划分" class="headerlink" title="根据数据结构划分"></a>根据数据结构划分</h2><ul><li><p>B-Tree索引<br>一般来说， B-Tree 索引的物理文件大多都是以 Balance Tree 的结构来存储的，也就是所有实际需要的数据都存放于 Tree 的 Leaf Node ，而且到任何一个 Leaf Node 的最短路径的长度都是完全相同的，在CREATE TABLE和其他语句中都会使用到该关键字，所以我们大家都称之为 B-Tree 索引。当然，各种存储引擎的底层存储结构可能存在不同，如大多数引擎包括MySQL使用的是B+Tree， NDB集群存储引擎内部使用的是T-TREE结构，但它们都是BTREE。<br>可以在 <a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html" target="_blank" rel="noopener">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a> 上看到B-Tree的可视化操作过程</p></li><li><p>Hash索引<br>基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个hash code，这是一个较小的值，并且不同键值的行计算出的hash code也不一样。哈希索引将所有的hash code存储在索引中，同时在哈希表中保存指向每个数据行的指针。<br>在MySQL中，只有Memory引擎支持Hash索引，同时Hash索引也是Memory引擎的默认索引类型。</p></li></ul><h2 id="B-Tree索引-和-Hash索引对比"><a href="#B-Tree索引-和-Hash索引对比" class="headerlink" title="B-Tree索引 和 Hash索引对比"></a>B-Tree索引 和 Hash索引对比</h2><ul><li>如果是等值查询，那么哈希索引明显有绝对优势，因为Hash表查找是O(1)的时间复杂度；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</li><li>如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</li><li>同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</li><li>哈希索引也不支持多列联合索引的最左匹配规则；</li><li>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</li></ul><h2 id="B-Tree-和-B-Tree-比较"><a href="#B-Tree-和-B-Tree-比较" class="headerlink" title="B-Tree 和 B+Tree 比较"></a>B-Tree 和 B+Tree 比较</h2><p> <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p><h1 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>索引大大减少了服务器需要扫描的数据量</li><li>索引可以帮助服务器避免排序和临时表</li><li>索引可以将随机I/O变为顺序I/O</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</li></ul><h1 id="索引的适用范围及限制（B-Tree索引）"><a href="#索引的适用范围及限制（B-Tree索引）" class="headerlink" title="索引的适用范围及限制（B-Tree索引）"></a>索引的适用范围及限制（B-Tree索引）</h1><h2 id="有效范围"><a href="#有效范围" class="headerlink" title="有效范围"></a>有效范围</h2><ul><li>全值匹配</li><li>匹配最左前缀</li><li>匹配列前缀</li><li>匹配范围值</li><li>精确匹配某一列并范围匹配另外一列</li><li>只访问索引的查询</li><li>空值查询，使用<strong>is null</strong>可以使用到索引</li></ul><h2 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h2><ul><li>如果MySQL估计使用索引比全表扫描慢，则不使用<ul><li>value 均匀分布在1-100,查询 ‘where value &gt; 1 and value &lt; 100’时，不使用索引反而更好</li></ul></li><li>like 模糊查找有一定限制<ul><li>like ‘%3’ 不会使用索引</li><li>like ‘3%’ 会使用索引</li></ul></li><li>对于MEMORY/HEAP表，where条件中不使用“=”进行索引列，那么不会用到索引</li></ul><h2 id="设计索引原则"><a href="#设计索引原则" class="headerlink" title="设计索引原则"></a>设计索引原则</h2><ul><li>尽量使用选择性高的列，即在重复度高的列上建立索引，不要在重复度低的列上建立索引</li><li>利用最左前缀，多个列的独立索引相比联合索引会带来更多的空间和计算资源上的消耗，所以如果能匹配上最左前缀，就使用多列索引，而不要使用多个列索引</li><li>利用很少的列尽量不要建立索引，因为虽然索引可以带来搜索效率上的提升，但同时需要占用额外的空间，以及修改时的额外开销</li><li>主键尽量使用较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存效果</li></ul><h1 id="索引策略"><a href="#索引策略" class="headerlink" title="索引策略"></a>索引策略</h1><h2 id="使用独立的列"><a href="#使用独立的列" class="headerlink" title="使用独立的列"></a>使用独立的列</h2><p>独立的列是指索引列不能是表达式的一部分，也不能是函数的参数</p><ul><li>下列查询无法使用索引actor_id</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</span><br></pre></td></tr></table></figure><p>应改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT actor_id FROM sakila.actor WHERE actor_id = 4;</span><br><span class="line"></span><br><span class="line">如果一定要用表达式，也应该是：</span><br><span class="line">SELECT actor_id FROM sakila.actor WHERE actor_id = 5-1;</span><br></pre></td></tr></table></figure></p><ul><li>常见错误<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) &lt;= 10;</span><br></pre></td></tr></table></figure></li></ul><h2 id="前缀索引和索引选择性"><a href="#前缀索引和索引选择性" class="headerlink" title="前缀索引和索引选择性"></a>前缀索引和索引选择性</h2><p>如果要索引一个很长的字符列，这会让索引变得大且慢。一种方案是使用hash索引，但hash索引有时候还不够，这个时候就可以考虑使用前缀索引。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>使用前缀索引，可以大大节约索引空间，从而提高索引效率，但同时也会降低索引的选择性，同时不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引。</p><h3 id="prefix-length确定"><a href="#prefix-length确定" class="headerlink" title="prefix_length确定"></a>prefix_length确定</h3><p>使用前缀索引的关键在于选择合知的prefix_length，从而尽可能提高索引选择性，即假如对于字符长度10的一半就可以唯一确定这个字符，那么使用前缀索引，prefix_length=5,就可以达到使用索引的应有效果，可以大大节约空间和提高效率<br>前缀长度的确定方式，就是计算完整列的选择性，并使前缀的选择性接近于完整的选择性。</p><ul><li>完整列的选择性：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct city)/count(*) from sakila.city_demo;</span><br></pre></td></tr></table></figure><ul><li>不同前缀长度下的选择性：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select count(distinct left(city,3))/count(*) as sel3,</span><br><span class="line">  count(distinct left(city,4))/count(*) as sel4,</span><br><span class="line">  count(distinct left(city,5))/count(*) as sel5,</span><br><span class="line">  count(distinct left(city,6))/count(*) as sel6,</span><br><span class="line">  count(distinct left(city,7))/count(*) as sel7</span><br><span class="line">from sakila.city_demo;</span><br></pre></td></tr></table></figure><ul><li>比较结果，选择长度和选择性都比较合适的情况建立前缀索引</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>字符串列(varchar,char,text等)，需要进行全字段匹配</li><li>字符串本身可能比较长，而且前几个字符就开始不相同。比如我们对中国人的姓名使用前缀索引就没啥意义，因为中国人名字都很短，另外对收件地址使用前缀索引也不是很实用，因为一方面收件地址一般都是以XX省开头，也就是说前几个字符都是差不多的，而且收件地址进行检索一般都是like ’%xxx%’，不会用到前匹配。相反对外国人的姓名可以使用前缀索引，因为其字符较长，而且前几个字符的选择性比较高。同样电子邮件也是一个可以使用前缀索引的字段。</li><li>前一半字符的索引选择性就已经接近于全字段的索引选择性。如果整个字段的长度为20，索引选择性为0.9，而我们对前10个字符建立前缀索引其选择性也只有0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，没有太大的建前缀索引的必要了。</li></ul><h2 id="多列索引"><a href="#多列索引" class="headerlink" title="多列索引"></a>多列索引</h2><p>所谓的多列索引，并不是指为多个列建立独立的索引，而是建立一个包含相关列的多列索引（联合索引）。<br>在一次查询中，MySQL只能使用一个索引，同时，若表中索引过多，会影响INSERT及UPDATE性能，简单说就是会影响数据写入性能。因为更新数据的同时，也要同时更新索引。<br>再者，建立多个独立单列索引，在进行查询时，数据库通常会进行索引合并（index merge）操作，这会耗费大量的计算资源，更优的做法是尽量去除索引合并，改为使用多列索引</p><h2 id="选择合适的顺序（B-Tree）"><a href="#选择合适的顺序（B-Tree）" class="headerlink" title="选择合适的顺序（B-Tree）"></a>选择合适的顺序（B-Tree）</h2><p>使用多列索引时，也要注意索引的顺序问题，即需要注意最左匹配原则。<br>那么如何选取一个索引顺序，下面列举出所有可能有影响的条件：</p><ul><li>列的选择性</li><li>列的长度</li><li>排序和分组情况</li></ul><p>选取 <a href="https://segmentfault.com/q/1010000000342176" target="_blank" rel="noopener">https://segmentfault.com/q/1010000000342176</a> 中的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">对于联合索引（a,b,c)</span><br><span class="line"></span><br><span class="line">优: select * from test where a=10 and b&gt;50 差: select * from test where</span><br><span class="line">a50</span><br><span class="line"></span><br><span class="line">优: select * from test order by a 差: select * from test order by b 差:</span><br><span class="line">select * from test order by c</span><br><span class="line"></span><br><span class="line">优: select * from test where a=10 order by a 优: select * from test</span><br><span class="line">where a=10 order by b 差: select * from test where a=10 order by c</span><br><span class="line"></span><br><span class="line">优: select * from test where a&gt;10 order by a 差: select * from test</span><br><span class="line">where a&gt;10 order by b 差: select * from test where a&gt;10 order by c</span><br><span class="line"></span><br><span class="line">优: select * from test where a=10 and b=10 order by a 优: select * from</span><br><span class="line">test where a=10 and b=10 order by b 优: select * from test where a=10</span><br><span class="line">and b=10 order by c</span><br><span class="line"></span><br><span class="line">优: select * from test where a=10 and b=10 order by a 优: select * from</span><br><span class="line">test where a=10 and b&gt;10 order by b 差: select * from test where a=10</span><br><span class="line">and b&gt;10 order by c</span><br></pre></td></tr></table></figure></p><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引并不是一种单独的索引类型，而是一种数据的存储方式，它的数据行实际上存放在索引的叶子页（leaf page）中，术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引，除此之外的表上的每个非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">以InnoDB来说，每个InnoDB表具有一个特殊的索引称为聚集索引。如果您的表上定义有主键，该主键索引是聚集索引。</span><br><span class="line">如果你不定义为您的表的主键时，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚集索引。</span><br><span class="line">如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。</span><br></pre></td></tr></table></figure></p><p>聚簇索引的使用优点：</p><ul><li>可以把相关数据保存在一起。因为数据和索引存放在一起，所以在读取时，只用读取少量的数据页就能获取某个用户的全部邮件</li><li>数据的访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快</li><li>使用覆盖索引扫描的查询可以直接使用页节点</li></ul><p>聚簇索引的使用缺点：</p><ul><li>聚簇索引最大限度提高了 I/O 密集型应用的性能，但是如果数据全部放在内存，就没必要用聚簇索引</li><li>插入速度严重依赖于插入顺序，按主键的顺序插入是最快的</li><li>更新操作代价很高，因为每个被更新的行都会移动到新的位置</li><li>当插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，页分裂会导致表占用更多的磁盘空间</li><li>如果行比较稀疏，或者由于页分裂导致数据存储不连续时，聚簇索引可能导致全表扫描速度变慢</li></ul><h2 id="覆盖索引（innoDB）"><a href="#覆盖索引（innoDB）" class="headerlink" title="覆盖索引（innoDB）"></a>覆盖索引（innoDB）</h2><p>通常索引的添加方式，都是根据WHERE条件来进行创建合适的索引，不过这只是索引优化的一个方面，设计优秀的索引要考虑的方面要更多，对于其中的一个场景，如果索引的叶子节点中已经包含要查询的数据，那么还有什么必要再回表查询呢？<br>覆盖索引的定义，如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”<br>对于InnoDB而言，其二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * 不好的地方就在于，</span><br><span class="line">一方面一般情况下不会用到所有的字段，会造成资源的浪费</span><br><span class="line">另一方面去除了本可以使用覆盖索引大大提升效率的情况</span><br></pre></td></tr></table></figure></p><h2 id="使用索引扫描来做排序"><a href="#使用索引扫描来做排序" class="headerlink" title="使用索引扫描来做排序"></a>使用索引扫描来做排序</h2><p>MySQL有两种方式可以生成有序的结果： 通过排序操作，或者是通过索引顺序扫描</p><ul><li>只有当索引的列顺序和ORDER BY子句完全一致，并且所有列的排序方向（正序或倒序）都一样时，MySQL才能够使用索引来对结果做排序</li><li>如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序</li><li>ORDER BY子句和查找型查询的限制是一样的，需要满足索引的最左前缀的要求</li><li>前导列为常量的时候，即WHERE或JOIN子句中对这些列指定了常量，就可以“弥补”索引的不足</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">表结构：</span><br><span class="line">CREATE TABLE rental&#123;</span><br><span class="line">    ...</span><br><span class="line">    PRIMARY KEY(rental_id),</span><br><span class="line">    UNIQUE KEY rental_date(rental_date, inventory_id, customer_id),</span><br><span class="line">    KEY idx_fk_inventory_id(inventory_id),</span><br><span class="line">    KEY idx_fk_customer_id(customer_id),</span><br><span class="line">    KEY idx_fk_staff_id(staff_id),</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">查询语句：</span><br><span class="line">EXPLAIN SELECT rental_id, staff_id FROM sakila.rental</span><br><span class="line">-&gt; WHERE rental_date = &apos;2005-05-5&apos;</span><br><span class="line">-&gt; ORDER BY inventory_id, customer_id</span><br><span class="line"></span><br><span class="line">结果：</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: rental_date</span><br><span class="line">          key: rental_date</span><br><span class="line">         rows: 1</span><br><span class="line">        extra: using where</span><br></pre></td></tr></table></figure><h2 id="删除低质量的索引"><a href="#删除低质量的索引" class="headerlink" title="删除低质量的索引"></a>删除低质量的索引</h2><p>所谓的低质量索引，是指那些冗余、重复、未使用的索引</p><ul><li>冗余的情况是指，如果已经有了联合索引（a，b），再建立独立索引a，索引a则是冗余的情况</li><li>重复的索引是指建立主键索引、唯一索引、普通索引里的两个或三个，实际MySQL里的唯一限制和主键限制都是依靠索引实现的，因此，再此基础上，再加索引，就会造成索引重复</li><li>未使用的索引可以通过两个工具来定位。一是打开Percona Server或MariaDB中的userstates服务器变量，运行一段时间后，再查询INFORMATION_SCHEMA.INDEX_STATISTICS追查每个索引的使用频率;二是通过Percona Toolkit中的pt-index-usage，该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操作，然后打印出关于索引和查询的报告</li></ul><h1 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h1><ul><li>《高性能MySQL》</li><li>《深入浅出MySQL》</li><li><a href="https://blog.csdn.net/oChangWen/article/details/54024063" target="_blank" rel="noopener">hash索引和B-Tree索引的区别</a></li><li><a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="noopener">https://dev.mysql.com/doc/refman/5.7/en/</a></li><li><a href="http://www.cnblogs.com/studyzy/p/4310653.html" target="_blank" rel="noopener">http://www.cnblogs.com/studyzy/p/4310653.html</a></li><li><a href="https://tech.meituan.com/mysql-index.html" target="_blank" rel="noopener">https://tech.meituan.com/mysql-index.html</a></li></ul>]]></content>
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>程序员进化之路-技术提升</title>
      <link href="/2018/03/31/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF-%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/"/>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>不知不觉已经毕业快两年了，但是感觉现在的实力还是很差，仍然需要不停的学习，锻炼。<br>而要想快速进步，一个明确的大目标和一个个细化的小目标是必不可少的，经历了一段时间的探索，目前来讲，个人职业发展的规划很简单，紧抱google大腿，以go为主开发语言，在后端领域扑腾，专注web开发100年。<br>那么修炼之路也就很明确了。<br><a id="more"></a></p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="数据结构-算法"><a href="#数据结构-算法" class="headerlink" title="数据结构 + 算法"></a>数据结构 + 算法</h2><ul><li><p>算法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">对于以下算法无变形基本问题可以做到手写无误</span><br><span class="line">二分搜索 Binary Search</span><br><span class="line">分治 Divide Conquer</span><br><span class="line">宽度优先搜索 Breadth First Search</span><br><span class="line">深度优先搜索 Depth First Search</span><br><span class="line">回溯法 Backtracking</span><br><span class="line">双指针 Two Pointers</span><br><span class="line">动态规划 Dynamic Programming</span><br><span class="line">扫描线 Scan-line algorithm</span><br><span class="line">快排 Quick Sort</span><br></pre></td></tr></table></figure></li><li><p>数据结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">栈 Stack</span><br><span class="line">队列 Queue</span><br><span class="line">链表 Linked List</span><br><span class="line">数组 Array</span><br><span class="line">哈希表 Hash Table</span><br><span class="line">二叉树 Binary Tree  </span><br><span class="line">堆 Heap</span><br><span class="line">并查集 Union Find</span><br><span class="line">字典树 Trie</span><br></pre></td></tr></table></figure></li><li><p>练习方式： leetcode</p></li></ul><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><ul><li>书籍：<ul><li>《鸟哥的linux私房菜》</li></ul></li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul><li>书籍：<ul><li>《计算机网络-自顶向下》</li><li>《http权威指南》</li><li>《https权威指南》</li></ul></li></ul><h1 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h1><h2 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h2><h2 id="设计理念"><a href="#设计理念" class="headerlink" title="设计理念"></a>设计理念</h2><ul><li>并发处理模型</li><li>gc原理</li></ul><p>书籍：</p><ul><li>《深入解析go》</li><li>《go语言学习笔记》</li><li>《go并发编程实战》</li></ul><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="基本设计与操作"><a href="#基本设计与操作" class="headerlink" title="基本设计与操作"></a>基本设计与操作</h2><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h2 id="底层结构（索引）"><a href="#底层结构（索引）" class="headerlink" title="底层结构（索引）"></a>底层结构（索引）</h2><p>书籍：</p><ul><li>《高性能MySQL》</li><li>《MySQL必知必会》</li><li>《Redis实战》</li></ul><h1 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h1><ul><li>rabbitmq</li><li>zookper</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><p>书籍：</p><ul><li>《大话设计模式》</li><li>《设计模式之禅》</li></ul><h1 id="基础工具"><a href="#基础工具" class="headerlink" title="基础工具"></a>基础工具</h1><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><ul><li><a href="https://github.com/livoras/blog/issues/7#issue-105082853" target="_blank" rel="noopener">https://github.com/livoras/blog/issues/7#issue-105082853</a></li></ul><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><ul><li>docker</li><li>k8s</li></ul><h1 id="架构能力"><a href="#架构能力" class="headerlink" title="架构能力"></a>架构能力</h1><p>书籍：</p><ul><li>《亿级流量网站架构》</li><li>《微服务设计》</li><li>《图解服务器端网络架构》</li></ul>]]></content>
      
      <categories>
          
          <category> 职业发展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职业发展 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go语言学习-map</title>
      <link href="/2018/03/30/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-map/"/>
      <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>go版本 1.10</p><h2 id="HashMap和HashTable"><a href="#HashMap和HashTable" class="headerlink" title="HashMap和HashTable"></a>HashMap和HashTable</h2><p>线性表中，数组查询方便，链表插入、删除方便，而HashTable则是结合了两者的优点，使得在所有操作上都是 O(1) 的时间复杂度，效率非常高<br>HashMap是基于HashTable的 Map 接口的实现，其去掉了线程同步的操作，因而效率要更高一些，所以说HashTable是线程安全的，而HashMap则非线程安全。<br>go语言中的map类型就是使用的HashMap,即go中的map非线程安全，不能放在多个goroutine中，只能自己维护线程安全<br><a id="more"></a></p><h2 id="go-map一般操作"><a href="#go-map一般操作" class="headerlink" title="go map一般操作"></a>go map一般操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建map</span><br><span class="line">a := make(map[string]string)</span><br><span class="line">//存入</span><br><span class="line">a[&quot;first&quot;] = &quot;first&quot;</span><br><span class="line">//读取</span><br><span class="line">fmt.Println(a[&quot;first&quot;])</span><br></pre></td></tr></table></figure><p>需要注意的是，并不是所有的类型都可以作为key值，在Go的语言规范中已精确定义，只有能比较是否相等的类型才可以作为key值，key的类型可以是：</p><ul><li>布尔值</li><li>数字</li><li>字符串</li><li>指针</li><li>通道</li><li>接口类型</li><li>结构体</li></ul><p>只包含上述类型的数组。<br>不能是：</p><ul><li>slice</li><li>map</li><li>function<br>Key类型只要能支持==和!=操作符，即可以做为Key，当两个值==时，则认为是同一个Key。</li></ul><h2 id="go-map并发线程操作"><a href="#go-map并发线程操作" class="headerlink" title="go map并发线程操作"></a>go map并发线程操作</h2><ul><li><p>结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var counter = struct&#123;</span><br><span class="line">    sync.RWMutex</span><br><span class="line">    m map[string]int</span><br><span class="line">&#125;&#123;m: make(map[string]int)&#125;</span><br></pre></td></tr></table></figure></li><li><p>读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">counter.RLock()</span><br><span class="line">n := counter.m[&quot;some_key&quot;]</span><br><span class="line">counter.RUnlock()</span><br><span class="line">fmt.Println(&quot;some_key:&quot;, n)</span><br></pre></td></tr></table></figure></li><li><p>写</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">counter.Lock()</span><br><span class="line">counter.m[&quot;some_key&quot;]++</span><br><span class="line">counter.Unlock()</span><br></pre></td></tr></table></figure></li></ul><h2 id="go-map的遍历"><a href="#go-map的遍历" class="headerlink" title="go map的遍历"></a>go map的遍历</h2><p>go语言中map存放是无序的，即如果对一个map进行输出，其并不会按照输入的顺序，而是随机的<br>那么如果想要实现map的一个有序的输出，就需要指定一组确立顺序的key<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import &quot;sort&quot;</span><br><span class="line"></span><br><span class="line">var m map[int]string</span><br><span class="line">var keys []int</span><br><span class="line">for k := range m &#123;</span><br><span class="line">    keys = append(keys, k)</span><br><span class="line">&#125;</span><br><span class="line">sort.Ints(keys)</span><br><span class="line">for _, k := range keys &#123;</span><br><span class="line">    fmt.Println(&quot;Key:&quot;, k, &quot;Value:&quot;, m[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="go-map结构"><a href="#go-map结构" class="headerlink" title="go map结构"></a>go map结构</h2><p>map实现可在/runtime/hashmap.go里查看</p><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// A header for a Go map.</span><br><span class="line">type hmap struct &#123;</span><br><span class="line">// Note: the format of the Hmap is encoded in ../../cmd/internal/gc/reflect.go and</span><br><span class="line">// ../reflect/type.go. Don&apos;t change this structure without also changing that code!</span><br><span class="line">count     int // # live cells == size of map.  Must be first (used by len() builtin)</span><br><span class="line">flags     uint8</span><br><span class="line">B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span><br><span class="line">noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details</span><br><span class="line">hash0     uint32 // hash seed</span><br><span class="line"></span><br><span class="line">buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.</span><br><span class="line">oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing</span><br><span class="line">nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)</span><br><span class="line"></span><br><span class="line">extra *mapextra // optional fields</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>count 提供给len()使用，用来记录map的大小，可以统计kv对的个数</li><li>B map的容量，表示当前可以放入 loadFactor * 2^B 个item，2^B 即为buckets的数量</li><li>buckets 桶，指向实际存储空间</li><li>oldbuckets 只有在扩容时使用，其余情况下为空。如果当前哈希表正在扩容中，则oldbuckets不为空，并且buckets大小是oldbuckets大小的两倍。</li><li>noverflow 溢出桶的大小</li></ul><p>由注释我们可以看到，这是Go map的header，map类型就是一个hash表的结构，数据被发放进buckets数组中，每个bucket包含有8个键值对，当溢出时，将再生成一个bucket，并将之链接到之前的bucket上</p><h3 id="bucket"><a href="#bucket" class="headerlink" title="bucket"></a>bucket</h3><p>这里是map中每个bucket的结构，可以看出，是一个 8个单位长度的uint8数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// A bucket for a Go map.</span><br><span class="line">type bmap struct &#123;</span><br><span class="line">// tophash generally contains the top byte of the hash value</span><br><span class="line">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span><br><span class="line">// tophash[0] is a bucket evacuation state instead.</span><br><span class="line">tophash [bucketCnt]uint8</span><br><span class="line">// Followed by bucketCnt keys and then bucketCnt values.</span><br><span class="line">// NOTE: packing all the keys together and then all the values together makes the</span><br><span class="line">// code a bit more complicated than alternating key/value/key/value/... but it allows</span><br><span class="line">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span><br><span class="line">// Followed by an overflow pointer.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>bucketCnt 定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const(</span><br><span class="line">  // Maximum number of key/value pairs a bucket can hold.</span><br><span class="line">  bucketCntBits = 3</span><br><span class="line">  bucketCnt     = 1 &lt;&lt; bucketCntBits</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>可以从tophash的注释中看出，这里的key value存入顺序，不是key/value/key/value/… ， 而是key/key/key/key/value/value/value/value，这是因为考虑到map[int64]int8这种情况，存在64和8两种大小，考虑到字节对齐，会浪费很多存储空间</p><h2 id="map-操作解析"><a href="#map-操作解析" class="headerlink" title="map 操作解析"></a>map 操作解析</h2><h3 id="确定buckets"><a href="#确定buckets" class="headerlink" title="确定buckets"></a>确定buckets</h3><p>hash表的bucket确定方式，一般为key值求hash后，用hash值对总的buckets数取余，即hash mod (2^B)，可优化为以下操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// bucketShift returns 1&lt;&lt;b, optimized for code generation.</span><br><span class="line">func bucketShift(b uint8) uintptr &#123;</span><br><span class="line">if sys.GoarchAmd64|sys.GoarchAmd64p32|sys.Goarch386 != 0 &#123;</span><br><span class="line">b &amp;= sys.PtrSize*8 - 1 // help x86 archs remove shift overflow checks</span><br><span class="line">&#125;</span><br><span class="line">return uintptr(1) &lt;&lt; b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// bucketMask returns 1&lt;&lt;b - 1, optimized for code generation.</span><br><span class="line">func bucketMask(b uint8) uintptr &#123;</span><br><span class="line">return bucketShift(b) - 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">h *hmap</span><br><span class="line">hash % (1 &lt;&lt; h.B)</span><br><span class="line">=&gt; hash &amp; bucketMask(h.B)</span><br></pre></td></tr></table></figure></p><h3 id="增量扩容"><a href="#增量扩容" class="headerlink" title="增量扩容"></a>增量扩容</h3><p>为什么会增量扩容呢？主要是缩短map容器的响应时间。假如我们直接将map用作某个响应实时性要求非常高的web应用存储，如果不采用增量扩容，当map里面存储的元素很多之后，扩容时系统就会卡往，导致较长一段时间内无法响应请求。不过增量扩容本质上还是将总的扩容时间分摊到了每一次哈希操作上面。<br>扩容会建立一个大小是原来2倍的新的表，将旧的bucket搬到新的表中之后，并不会将旧的bucket从oldbucket中删除，而是加上一个已删除的标记。<br>正是由于这个工作是逐渐完成的，这样就会导致一部分数据在old table中，一部分在new table中， 所以对于hash table的insert, remove, lookup操作的处理逻辑产生影响。只有当所有的bucket都从旧表移到新表之后，才会将oldbucket释放掉。<br>扩容的填充因子是多少呢？如果grow的太频繁，会造成空间的利用率很低， 如果很久才grow，会形成很多的overflow buckets，查找的效率也会下降。 这个平衡点如何选取呢(在go中，这个平衡点是有一个宏控制的(#define LOAD 6.5), 它的意思是这样的，如果table中元素的个数大于table中能容纳的元素的个数， 那么就触发一次grow动作。那么这个6.5是怎么得到的呢？原来这个值来源于作者的一个测试程序，遗憾的是没能找到相关的源码，不过作者给出了测试的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Maximum average load of a bucket that triggers growth is 6.5.</span><br><span class="line">// Represent as loadFactorNum/loadFactDen, to allow integer math.</span><br><span class="line">loadFactorNum = 13</span><br><span class="line">loadFactorDen = 2</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Picking loadFactor: too large and we have lots of overflow</span><br><span class="line">buckets, too small and we waste a lot of space. I wrote</span><br><span class="line">a simple program to check some stats for different loads:</span><br><span class="line">(64-bit, 8 byte keys and values)</span><br><span class="line">loadFactor    %overflow  bytes/entry     hitprobe    missprobe</span><br><span class="line">      4.00         2.13        20.77         3.00         4.00</span><br><span class="line">      4.50         4.05        17.30         3.25         4.50</span><br><span class="line">      5.00         6.85        14.77         3.50         5.00</span><br><span class="line">      5.50        10.55        12.94         3.75         5.50</span><br><span class="line">      6.00        15.27        11.67         4.00         6.00</span><br><span class="line">      6.50        20.90        10.79         4.25         6.50</span><br><span class="line">      7.00        27.14        10.15         4.50         7.00</span><br><span class="line">      7.50        34.03         9.73         4.75         7.50</span><br><span class="line">      8.00        41.10         9.40         5.00         8.00</span><br><span class="line"></span><br><span class="line">%overflow   = percentage of buckets which have an overflow bucket</span><br><span class="line">bytes/entry = overhead bytes used per key/value pair</span><br><span class="line">hitprobe    = # of entries to check when looking up a present key</span><br><span class="line">missprobe   = # of entries to check when looking up an absent key</span><br><span class="line"></span><br><span class="line">Keep in mind this data is for maximally loaded tables, i.e. just</span><br><span class="line">before the table grows. Typical tables will be somewhat less loaded.</span><br></pre></td></tr></table></figure><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">未完待续</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>服务器安全防护</title>
      <link href="/2018/03/27/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4/"/>
      <content type="html"><![CDATA[<h2 id="服务器安全"><a href="#服务器安全" class="headerlink" title="服务器安全"></a>服务器安全</h2><p>一段时间没去打理我的服务器，只是搭个ss，当科学工具用，今天忽然收到服务商的电话，说是服务器上存在不合法行为，还吓我一跳，觉着现在都查这么严格，自建梯子都不行了。实际在管理平台上一看日志，才知道说是服务器存在安全问题，应该是已经被黑掉，在不停的试探别的ip的22端口，总计被监测到400多万次行为，看来当真是有挺长一段时间没管理了。。。</p><h2 id="主要被攻击方式"><a href="#主要被攻击方式" class="headerlink" title="主要被攻击方式"></a>主要被攻击方式</h2><p>从日志中可以看到，应该主要是扫描加暴力破解的方式，所以理所当然的应对手段就是，开启防火墙，改ssh端口，改mysql端口，开启安全组，之前是觉着被攻击的机率太低了，现在看来，再低机率也不应该懈怠<br><a id="more"></a></p><h2 id="开启防火墙"><a href="#开启防火墙" class="headerlink" title="开启防火墙"></a>开启防火墙</h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>防火墙开启后，应该先打开相应端口</li><li>一旦出现问题，可以使用页面版的远程登录，进行逆操作恢复<!--more--></li></ul><h3 id="ubuntu默认支持ufw防火墙"><a href="#ubuntu默认支持ufw防火墙" class="headerlink" title="ubuntu默认支持ufw防火墙"></a>ubuntu默认支持ufw防火墙</h3><ul><li><p>开关服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo ufw enable</span><br><span class="line"></span><br><span class="line">关闭命令</span><br><span class="line">sudo ufw disable</span><br></pre></td></tr></table></figure></li><li><p>开关端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启 8080端口</span><br><span class="line">sudo ufw allow 53</span><br><span class="line"></span><br><span class="line">关闭 8080端口</span><br><span class="line">sudo ufw deny 8080</span><br></pre></td></tr></table></figure></li></ul><h3 id="CentOS-7-0默认使用的是firewall作为防火墙"><a href="#CentOS-7-0默认使用的是firewall作为防火墙" class="headerlink" title="CentOS 7.0默认使用的是firewall作为防火墙"></a>CentOS 7.0默认使用的是firewall作为防火墙</h3><ul><li><p>开关服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">开启</span><br><span class="line">sudo systemctl start firewalld.service</span><br><span class="line"></span><br><span class="line">关闭</span><br><span class="line">sudo systemctl stop firewalld.service</span><br><span class="line"></span><br><span class="line">禁用</span><br><span class="line">sudo systemctl disable firewalld.service</span><br></pre></td></tr></table></figure></li><li><p>开关端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">查看状态</span><br><span class="line">sudo firewall-cmd --state</span><br><span class="line"></span><br><span class="line">查看端口</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"></span><br><span class="line">开放端口</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent</span><br><span class="line"></span><br><span class="line">删除端口</span><br><span class="line">firewall-cmd --zone= public --remove-port=80/tcp --permanent</span><br></pre></td></tr></table></figure></li><li><p>更新状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo firewall-cmd --reload</span><br></pre></td></tr></table></figure></li></ul><h3 id="如果想使用iptables作为防火墙，需要配置一下"><a href="#如果想使用iptables作为防火墙，需要配置一下" class="headerlink" title="如果想使用iptables作为防火墙，需要配置一下"></a>如果想使用iptables作为防火墙，需要配置一下</h3><ul><li>服务切换</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service #停止firewall</span><br><span class="line"></span><br><span class="line">systemctl disable firewalld.service #禁止firewall开机启动</span><br><span class="line"></span><br><span class="line">systemctl restart iptables.service #重启防火墙使配置生效</span><br><span class="line"></span><br><span class="line">systemctl enable iptables.service #设置防火墙开机启动</span><br><span class="line"></span><br><span class="line">最后重启系统使设置生效即可</span><br></pre></td></tr></table></figure><ul><li><p>服务开关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开启</span><br><span class="line">service iptables start</span><br><span class="line"></span><br><span class="line">关闭</span><br><span class="line">service iptables stop</span><br></pre></td></tr></table></figure></li><li><p>永久开关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">永久关闭防火墙:</span><br><span class="line"></span><br><span class="line">chkconfig iptables off</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">永久关闭后启用:</span><br><span class="line">chkconfig iptables on</span><br></pre></td></tr></table></figure></li></ul><h2 id="修改ssh端口号"><a href="#修改ssh端口号" class="headerlink" title="修改ssh端口号"></a>修改ssh端口号</h2><ul><li><p>修改/etc/ssh/sshd_config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">去掉端口注释，并添加新端口</span><br><span class="line"># Port 22</span><br><span class="line">Port 222</span><br></pre></td></tr></table></figure></li><li><p>重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/sshd restart</span><br><span class="line">或</span><br><span class="line">systemctl restart sshd</span><br></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 222 ip</span><br></pre></td></tr></table></figure></li></ul><h2 id="关闭密码登录"><a href="#关闭密码登录" class="headerlink" title="关闭密码登录"></a>关闭密码登录</h2><ul><li><p>修改/etc/ssh/sshd_config</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 以下两项设置允许使用常用客户端免密登录</span><br><span class="line">RSAAuthentication yes           #开启rsa验证</span><br><span class="line">PubkeyAuthentication yes        #开启公钥验证</span><br><span class="line"></span><br><span class="line"># 允许root账户登录</span><br><span class="line">PermitRootLogin yes</span><br><span class="line"></span><br><span class="line"># 不允许密码登录</span><br><span class="line">PasswordAuthentication no</span><br></pre></td></tr></table></figure></li><li><p>重启服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d/sshd restart</span><br></pre></td></tr></table></figure></li></ul><h2 id="修改mqsql端口"><a href="#修改mqsql端口" class="headerlink" title="修改mqsql端口"></a>修改mqsql端口</h2><p>docker run 时-p 映射时改一下</p><h2 id="修改安全组策略"><a href="#修改安全组策略" class="headerlink" title="修改安全组策略"></a>修改安全组策略</h2><p>可根据服务商进行选择</p>]]></content>
      
      <categories>
          
          <category> 站点建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql学习-事务</title>
      <link href="/2018/03/22/mysql%E5%AD%A6%E4%B9%A0-%E4%BA%8B%E5%8A%A1/"/>
      <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>事务(transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。同时，事务也是恢复和并发控制的基本单位。</p><h1 id="事务特性-acid"><a href="#事务特性-acid" class="headerlink" title="事务特性(acid)"></a>事务特性(acid)</h1><h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><ul><li><p>原子性(atomicity)<br>　原子性是指事务包含的所有操作要么全部操作，要么全部不做，事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p></li><li><p>一致性(consistency)<br>一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。<br>　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性</p></li><li><p>隔离性(isolation)<br>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。<br>　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p></li><li><p>持久性(durability)<br>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p><a id="more"></a></li></ul><h2 id="区分数据库的原子性和一致性"><a href="#区分数据库的原子性和一致性" class="headerlink" title="区分数据库的原子性和一致性"></a>区分数据库的原子性和一致性</h2><p>如果从逻辑设计上，A转账给B 1000元，那么A扣1000,B加1000，这个转账操作起码要有两个事务：<br>1、查A现有账户，然后扣1000,更新A账户（A=A-1000）<br>2、查B现有账户，然后加1000,更新B账户 (B=B+1000)</p><p>原子性是说，如果提交时，1,2都操作了，要么成功，要么失败回滚<br>一致性是说，如果操作了，但没有提交时系统崩溃，此时原子性满足了，但处于不一致的状态（只有事务的开始，没有事务的结束），所以要进行回滚，回退到上一个一致性的状态</p><h1 id="事务隔离"><a href="#事务隔离" class="headerlink" title="事务隔离"></a>事务隔离</h1><h2 id="事务的四大隔离等级"><a href="#事务的四大隔离等级" class="headerlink" title="事务的四大隔离等级"></a>事务的四大隔离等级</h2><ul><li><p>Read uncommitted (未提交读)：最低级别，任何情况都无法保证<br>如果一个事务已经开始写数据，则另外一个事务不能同时进行写操作，但允许其他事务读此行数据。即事务中的修改，即使没有提交，对其他事务也都是可见的。<br>这样就避免了更新丢失，却可能出现脏读，因为修改的事务也许在提交前还会有其他的很多修改，所以另一个事务的数据读取会错乱。<br>从性能上讲，read uncommitted并没有比其他的三个级别好太多，但却缺少其他隔离级别带来的好处，所以除非是有真的要使用的理由，在实际应用中一般不使用。</p></li><li><p>Read committed (提交读)：可避免脏读的发生<br>一个事务开始时，只能读到已经提交的事务所做的修改。即，一个事务从开始到提交之前所做的修改，对其他事务而言，都是不可见的。<br>该隔离级别避免了脏读，但是却可能出现不可重复读，即两个事务同时开启，事务A读取数据后，事务B对数据进行修改后提交，事务A再次读取，会发现跟前一次读取的内容不一样了<br>read committed, 也被称为 unrepeatable read是大多数数据库默认的隔离级别</p></li><li><p>Repeatable read (可重复读)：可避免脏读、不可重复读的发生<br>同一个事务多次读取的同一个记录，结果是一样的。这时读取的应该是一开始保留下来的快照。<br>读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。这样避免了不可重复读取和脏读，但是有时可能出现幻象读。<br>repeatable read 是mysql的默认隔离级别</p></li><li><p>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生<br>两个事务完全独立，其中一个事务做的操作，对于另外一个事务不产生任何影响<br>数据库事务加了锁，所有事务串行执行，避免了上述所有问题，但是性能上影响很大</p></li></ul><h2 id="并发下事务可能出现的问题"><a href="#并发下事务可能出现的问题" class="headerlink" title="并发下事务可能出现的问题"></a>并发下事务可能出现的问题</h2><p>在多个事务并发做数据库操作的时候，如果没有有效的避免机制，就会出现种种问题。</p><ul><li><p>1、丢失更新<br>两个不同事务同时获得相同数据，然后在各自事务中同时修改了该数据，那么先提交的事务更新会被后提交事务的更新给覆盖掉，那么先提交的更新就会被丢失掉</p></li><li><p>2、脏读（未提交读）<br>事务A读取了未提交的数据，事务B的回滚，导致了事务A的数据不一致，导致了事务A的脏读</p></li><li><p>3、不可重复读<br>一个事务在自己没有更新数据库数据的情况，同一个查询操作执行两次或多次的结果应该是一致的；如果不一致，就说明为不可重复读。<br>如果事务A读取第一次后，事务B对数据进行修改并提交，事务A再次读取后，数据就会不一致</p></li><li><p>4 幻读（Phantom Read）<br>事务A读的时候读出了15条记录，事务B在事务A执行的过程中增加了1条，事务A再读的时候就变成了16条，这种情况就叫做幻影读。<br>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p></li></ul><h2 id="隔离级别的例子"><a href="#隔离级别的例子" class="headerlink" title="隔离级别的例子"></a>隔离级别的例子</h2><p>现在有一个数据项X，执行以下操作<br>1、事务B一直对其进行读操作<br>2、事务A将其从1依次改到10<br>3、事务C将其从10依次改到20<br>4、事务B结束读操作</p><p>那么不同隔离级别下，去除重复值后，B所能看到的为：</p><ul><li>read uncommitted下： 1～20</li><li>read committed下: 1,10,20</li><li>repeatable read下： 1</li><li>serializable下： 因B操作未提交，所以无法按照以上顺序执行</li></ul><p>总的来说，事务隔离级别越高，越能保证数据的完整性和一致性，但是付出的代价却是并发的性能</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><h2 id="共享锁"><a href="#共享锁" class="headerlink" title="共享锁"></a>共享锁</h2><p>被加锁的对象可以被持锁事务读取，但是不能被修改，其他事务也可以在上面再加共享锁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where ? lock in share mode</span><br></pre></td></tr></table></figure></p><h2 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h2><p>被加锁的对象只能被持有锁的事务读取和修改，其他事务无法在该对象上加其他锁，也不能读取和修改该对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select * from table where ? for update;</span><br><span class="line">insert into table values (…);</span><br><span class="line">update table set ? where ?;</span><br><span class="line">delete from table where ?;</span><br></pre></td></tr></table></figure></p><p>对于增删改也是用的互斥锁是因为，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>应用层面的并发控制方式<br>每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</p><h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>应用层面的并发控制方式<br>每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁</p><p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适</p><h2 id="mvcc"><a href="#mvcc" class="headerlink" title="mvcc"></a>mvcc</h2><p>Multiversion concurrency control 即多版本并发控制，乐观锁的一种实现，一般使用时间戳或版本号来标识一次修改，在修改时，验证之前是否已有其他修改提交</p><table><thead><tr><th>事务A</th><th style="text-align:center">事务B</th><th style="text-align:right">备注</th></tr></thead><tbody><tr><td>start transaction;</td><td style="text-align:center"></td><td style="text-align:right"></td></tr><tr><td>select a,version from test where id=1;</td><td style="text-align:center"></td><td style="text-align:right">a=0, version=0</td></tr><tr><td></td><td style="text-align:center">update test set a=1, version=1 where id=1;</td><td style="text-align:right">a=1, version=1</td></tr><tr><td>update test set a=2 where version=0;</td><td style="text-align:center"></td><td style="text-align:right">发现冲突，更新失败</td></tr><tr><td>rollback</td><td style="text-align:center"></td><td style="text-align:right"></td></tr></tbody></table><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>两个事务需求的资源被对方所持有，进入了相互等待状态</p><ul><li>T1时 事务A锁定a，事务B锁定b</li><li>T2时 事务A执行锁定b，但被事务B持有，进入等待<pre><code>事务B执行锁定a，但被事务A持有，进入等待</code></pre></li><li>形成死锁</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">事务A</span><br><span class="line">start transaction</span><br><span class="line">update a</span><br><span class="line">update b</span><br><span class="line">commit</span><br><span class="line"></span><br><span class="line">事务B</span><br><span class="line">start transaction</span><br><span class="line">update b</span><br><span class="line">update a</span><br><span class="line">commit</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mysql学习-总览</title>
      <link href="/2018/03/21/mysql%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/"/>
      <content type="html"><![CDATA[<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>数据库(Database,简称DB): 长期存储在计算机内、有组织的、可共享的大量数据的集合<br>数据库管理系统(Database Management System，简称DBMS)： 位于用户与操作系统之间的一层数据管理软件，是一个大型复杂的软件系统，mysql就是一个开源的RDBMS<br>因所有的关系型数据库操作及功能都很类似，所以深入研究Mysql，可知识迁移到其他数据库中</p><h2 id="书籍推荐："><a href="#书籍推荐：" class="headerlink" title="书籍推荐："></a>书籍推荐：</h2><p>《高性能mysql》、《深入浅出MYSQL》、《MySQL性能调优与架构设计》<br><a id="more"></a></p><h2 id="分类与区别"><a href="#分类与区别" class="headerlink" title="分类与区别"></a>分类与区别</h2><h3 id="关系型数据库优缺点"><a href="#关系型数据库优缺点" class="headerlink" title="关系型数据库优缺点"></a>关系型数据库优缺点</h3><p>采用关系模型来组织数据的数据库<br>优点：</p><ul><li>可以通过事务来保证数据的一致性，对于安全性能很高的数据访问要求得以实现</li><li>通过sql语句，可以方便的在一个或多个表之间作复杂的数据查询</li></ul><p>缺点：</p><ul><li>与非关系型数据库相比，读写性能较差</li><li>难以进行水平扩展<!--more--></li></ul><h3 id="非关系型数据库优缺点"><a href="#非关系型数据库优缺点" class="headerlink" title="非关系型数据库优缺点"></a>非关系型数据库优缺点</h3><p>优点：</p><ul><li>基于键值对，不需要sql的筛选，读写性能很高</li><li>因基于键值对，数据之间没有耦合性，易于水平扩展</li></ul><p>缺点：</p><ul><li>不支持事务，无法保证数据的一致性</li><li>难以应对关系复杂的情况</li></ul><h2 id="go的orm"><a href="#go的orm" class="headerlink" title="go的orm"></a>go的orm</h2><ul><li>xorm<ul><li>源码地址： <a href="https://github.com/jinzhu/gorm" target="_blank" rel="noopener">https://github.com/jinzhu/gorm</a></li><li>首页地址： <a href="http://gorm.io/" target="_blank" rel="noopener">http://gorm.io/</a></li></ul></li><li>gorm<ul><li>源码地址： <a href="https://github.com/go-xorm/xorm" target="_blank" rel="noopener">https://github.com/go-xorm/xorm</a></li><li>首页地址： <a href="http://xorm.io/" target="_blank" rel="noopener">http://xorm.io/</a></li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库学习</title>
      <link href="/2018/03/20/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/"/>
      <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>数据库(Database,简称DB): 长期存储在计算机内、有组织的、可共享的大量数据的集合<br>数据库管理系统(Database Management System，简称DBMS)： 位于用户与操作系统之间的一层数据管理软件，是一个大型复杂的软件系统，mysql就是一个开源的RDBMS</p><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p><img src="https://upload-images.jianshu.io/upload_images/228680-448d468546343fa9?imageMogr2/auto-orient/" alt="数据库分类"><br><a id="more"></a></p><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>虽然网状数据库和层次数据库已经很好的解决了数据的集中和共享问题，但是在数据库独立性和抽象级别上扔有很大欠缺。用户在对这两种数据库进行存取时，仍然需要明确数据的存储结构，指出存取路径。而关系型数据库就可以较好的解决这些问题。</p><p>关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。在关系型数据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关联的表格分类、合并、连接或选取等运算来实现数据库的管理。</p><p>关系型数据库诞生40多年了，从理论产生发展到现实产品，例如：Oracle和MySQL，Oracle在数据库领域上升到霸主地位，形成每年高达数百亿美元的庞大产业市场。</p><h3 id="主流数据库"><a href="#主流数据库" class="headerlink" title="主流数据库"></a>主流数据库</h3><ul><li>Mysql</li><li>Oracle</li><li>Access</li><li>SqlServer</li><li>PostgreSql</li></ul><h2 id="非关系型数据库"><a href="#非关系型数据库" class="headerlink" title="非关系型数据库"></a>非关系型数据库</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>NoSQL，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSql数据库在特定的场景下可以发挥出难以想象的高效率和高性能，它是作为对传统关系型数据库的一个有效的补充。</p><p>NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。</p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>键值存储数据库<br>键值数据库就类似传统语言中使用的哈希表。可以通过key来添加、查询或者删除数据库，因为使用key主键访问，所以会获得很高的性能及扩展性。</li></ul><p>键值数据库主要使用一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署、高并发。</p><p>典型产品：Memcached、Redis</p><ul><li>文档存储数据库<br>文档型数据库的灵感是来自于Lotus Notes办公软件，而且它同第一种键值数据库类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。</li></ul><p>面向文档数据库会将数据以文档形式存储。每个文档都是自包含的数据单元，是一系列数据项的集合。每个数据项都有一个名词与对应值，值既可以是简单的数据类型，如字符串、数字和日期等；也可以是复杂的类型，如有序列表和关联对象。数据存储的最小单位是文档，同一个表中存储的文档属性可以是不同的，数据可以使用XML、JSON或JSONB等多种形式存储。</p><p>典型产品：MongoDB、CouchDB</p><ul><li>列存储数据库<br>列存储数据库将数据存储在列族中，一个列族存储经常被一起查询的相关数据，比如人类，我们经常会查询某个人的姓名和年龄，而不是薪资。这种情况下姓名和年龄会被放到一个列族中，薪资会被放到另一个列族中。</li></ul><p>这种数据库通常用来应对分布式存储海量数据。</p><p>典型产品：Cassandra、HBase</p><ul><li>图型数据库<br>图形数据库允许我们将数据以图的方式存储。实体会被作为顶点，而实体之间的关系则会被作为边。比如我们有三个实体，Steve Jobs、Apple和Next，则会有两个“Founded by”的边将Apple和Next连接到Steve Jobs。</li></ul><p>典型产品：Neo4J、InforGrid</p><h2 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h2><ul><li>关系型数据库以Mysql为代表</li><li>非关系型数据库中键值存储型以Redis为代表</li><li>非关系型数据库中文档存储型以MongoDB为代表</li><li>非关系型数据库中列存储型以Hbase为代表</li></ul><h2 id="本文参考文章"><a href="#本文参考文章" class="headerlink" title="本文参考文章"></a>本文参考文章</h2><p><a href="https://www.jianshu.com/p/107c6b045245" target="_blank" rel="noopener">https://www.jianshu.com/p/107c6b045245</a></p><h2 id="学习过程参考书籍"><a href="#学习过程参考书籍" class="headerlink" title="学习过程参考书籍"></a>学习过程参考书籍</h2><ul><li>《Redis实战》</li><li>《MongoDB权威指南》</li><li>《大数据存储MongoDB实战指南》</li><li>《高性能Mysql》</li><li>《深入浅出Mysql》</li></ul>]]></content>
      
      <categories>
          
          <category> database </category>
          
      </categories>
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络学习(四)-页面的请求过程</title>
      <link href="/2018/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E5%9B%9B-%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
      <content type="html"><![CDATA[<p>我们在学校上网时一次网页请求的过程是什么呢?<br><a id="more"></a></p><p>首先将电脑用一条以太网网线连到以太网交换机, 这个交换机连到学校的路由器,该路由器再连到ISP(Internet Service Provider), 就是电信等公司, 电信会提供DNS域名解析服务.<br><!--more--></p><p>当电脑刚刚连上网络的时候, 需要运行DHCP协议从本地的DHCP服务器来得到一个IP地址。<br><!--more--></p><p>电脑创建一个DHCP request message, 放到一个UDP段里面, 这个段还包含目标端口(DHCP server)和来源端口(DHCP client). 这个UDP段会放到一个IP数据报里面, 这个包的目标IP地址是广播地址(255.255.255.255), 来源地址是0.0.0.0.<br><!--more--></p><p>IP数据报放在一个Ethernet frame里, 这个以太网帧的目标地址是FF:FF:FF:FF:FF:FF所以该帧会被广播到所有连接在该交换机的设备,该帧的来源MAC地址是电脑的物理地址.</p><p>当DHCP服务器收到这个IP数据报后,就会分配一个IP地址. 创建一个包含该IP地址和DNS地址的DHCP ACK message, 发回到我们的电脑.</p><p>有了IP地址后就可以上网了。在浏览器上输入URL <a href="http://www.google.com" target="_blank" rel="noopener">www.google.com</a>, 浏览器会首先创建一个TCP socket, 然后通过TCP socket发送HTTP请求。 为了创建TCP socket我们首先要知道 <a href="http://www.google.com的IP地址，" target="_blank" rel="noopener">www.google.com的IP地址，</a> 该地址由DNS协议得到。</p><p>操作系统创建了一个DNS query message, 放进一个目标端口为53（DNS服务器）的UDP段里面， 这个UDP段放进以DNS server IP的为目标的IP数据报里。</p><p>包含该IP数据报的Ethernet frame会发往学校的网关路由器。尽管我们的电脑知道学校网关的IP地址，但是它不知道网关路由器的MAC地址， 这个时候就需要用到 ARP 协议。</p><p>电脑创建一个包含网关IP地址的ARP query message， 把它放进目标地址为广播地址FF:FF:FF:FF:FF:FF的以太网帧里面。 交换机会把这个帧发送到所有连接的设备，包括网关路由器。</p><p>网关路由器发现这个DNS query message的目标IP是自己，则创建一个ARP reply, 把自己的MAC地址发送回去。 操作系统得到网关的MAC地址后， 就可以发送DNS query了。</p><p>网关路由器拿到DNS query, 查看它的目标地址，根据forwading table决定传递到哪一个路由器去。IP数据报被放进链接层的帧里面。</p><p>拿到该链接层帧的路由器再根据它的forwading table转发，该forwarding table由Internet’s intera-domain protocal(如 RIP, OSPF, IS-IS, BGP)维护。</p><p>最后DNS server查询DNS query里的网址，得到对应的IP， 发送回我们的电脑。</p><p>得到<a href="http://www.google.com的IP地址后，我们就可以创建TCP" target="_blank" rel="noopener">www.google.com的IP地址后，我们就可以创建TCP</a> socket了。 首先TCP要进行三次握手连接到80端口， 然后发送HTTP GET。</p><p>Google的服务器读取HTTP GET讯息，返回包含网页内容的HTTP response. 我们的电脑就可以展示其中的内容了。</p>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络学习(三)-socket套接字分析</title>
      <link href="/2018/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E4%B8%89-socket%E5%A5%97%E6%8E%A5%E5%AD%97%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="TCP实验："><a href="#TCP实验：" class="headerlink" title="TCP实验："></a>TCP实验：</h2><h3 id="TCP客户端套接字程序"><a href="#TCP客户端套接字程序" class="headerlink" title="TCP客户端套接字程序"></a>TCP客户端套接字程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">class TCPClient&#123;</span><br><span class="line">  public static void main(String argv[]) throws Exception</span><br><span class="line">  &#123;</span><br><span class="line">     String sentence;</span><br><span class="line">     String modifiedSentence;</span><br><span class="line">     BufferedReader inFromUser =</span><br><span class="line">        new BufferedReader(</span><br><span class="line">              new InputStreamReader(System.in));</span><br><span class="line">     Socket ClientSocket = new Socket(&quot;222.194.1.36&quot;,6789);</span><br><span class="line">     DataOutputStream outToServer =</span><br><span class="line">        new DataOutputStream(</span><br><span class="line">              ClientSocket.getOutputStream());</span><br><span class="line">     BufferedReader inFromServer =</span><br><span class="line">        new BufferedReader(new InputStreamReader(</span><br><span class="line">               ClientSocket.getInputStream()));</span><br><span class="line">     sentence =inFromUser.readLine();</span><br><span class="line">     outToServer.writeBytes(sentence + &apos;\n&apos;);</span><br><span class="line">     modifiedSentence = inFromServer.readLine();</span><br><span class="line">     System.out.println(&quot;FROM SERVER:&quot;+</span><br><span class="line">                           modifiedSentence);</span><br><span class="line">     ClientSocket.close();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="TCP服务器端套接字程序"><a href="#TCP服务器端套接字程序" class="headerlink" title="TCP服务器端套接字程序"></a>TCP服务器端套接字程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">class TCPServer&#123;</span><br><span class="line">  public static void main(String argv[]) throws Exception</span><br><span class="line">  &#123;</span><br><span class="line">     String ClientSentence;</span><br><span class="line">     String capitalizedSentence;</span><br><span class="line">     ServerSocket welcomeSocket = new ServerSocket(6789);</span><br><span class="line"> </span><br><span class="line">     while(true)&#123;</span><br><span class="line">        Socket connectionSocket = welcomeSocket.accept();</span><br><span class="line">        BufferedReader inFromClient =</span><br><span class="line">          new BufferedReader(new InputStreamReader(</span><br><span class="line">              connectionSocket.getInputStream()));</span><br><span class="line">        DataOutputStream outToClient =</span><br><span class="line">          new DataOutputStream(</span><br><span class="line">              connectionSocket.getOutputStream());</span><br><span class="line">        ClientSentence = inFromClient.readLine();</span><br><span class="line">        capitalizedSentence =</span><br><span class="line">              ClientSentence.toUpperCase() + &apos;\n&apos;;</span><br><span class="line">     outToClient.writeBytes(capitalizedSentence);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!--more--><p><img src="/2018/03/08/计算机网络学习-三-socket套接字分析/tcp1.png" alt="tcp"><br><img src="/2018/03/08/计算机网络学习-三-socket套接字分析/tcp2.png" alt="tcp"></p><h3 id="TCP连接分析："><a href="#TCP连接分析：" class="headerlink" title="TCP连接分析："></a>TCP连接分析：</h3><ul><li><p>1、 客户端：握手请求seq=0,len=0，syn=1<br>syn=1，标志着这是一次握手请求，且客户端设置初始seq=0，发送数据len=0</p></li><li><p>2、 服务器端：握手应答 seq=0 ,ack =1, len=0，syn=1<br>syn=1，这是属于握手应答，且服务端初始seq=0，ack=（客户端的）seq+len+1，发送数据len=0</p></li><li><p>3、 客户端：接收到应答 seq =1, ack =1, len=0<br>seq=（客户端上次的）seq+len+1, ack=（服务端的）seq+len+1</p></li><li><p>4、 客户端：发送数据请求 seq =1 ,ack = 1 ,len =1</p></li><li>5、 服务器端：接收请求 seq =1 ,ack =2 ,len =0</li><li>6、 客户端：发送数据 seq =2, ack =1, len =14</li><li>7、 服务器端:接收数据并请求发送数据 seq =1 ,ack =16 ,len =1</li><li>8、 客户端:接收请求 seq =16 , ack =2 , len=0</li><li>9、 服务器端：发送数据 seq =2 ,ack =16 ,len =14</li><li>10、客户端:接收数据并请求关闭连接 seq = 16 ,ack = 16 ,len =0</li><li>11、服务器端:接收请求 seq = 16 ,ack =17 ,len =0</li></ul><p>客户端关闭连接，但服务器端仍保持监听，则服务器端没有进行请求关闭连接的请求。</p><h2 id="UDP实验："><a href="#UDP实验：" class="headerlink" title="UDP实验："></a>UDP实验：</h2><h3 id="UDP客户端套接字程序"><a href="#UDP客户端套接字程序" class="headerlink" title="UDP客户端套接字程序"></a>UDP客户端套接字程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">class UDPClient &#123;</span><br><span class="line">  public static void main(String args[]) throws Exception</span><br><span class="line">  &#123;</span><br><span class="line">     BufferedReader inFromUser =</span><br><span class="line">        new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">     DatagramSocket clientSocket = new DatagramSocket();</span><br><span class="line">     InetAddress IPAddress = InetAddress.getByName(&quot;222.194.1.36&quot;);</span><br><span class="line">     byte[] sendData = new byte[1024];</span><br><span class="line">byte[] receiveData = new byte[1024];</span><br><span class="line">String sentence = inFromUser.readLine();</span><br><span class="line">sendData = sentence.getBytes();</span><br><span class="line">DatagramPacket sendPacket =</span><br><span class="line">   new DatagramPacket(sendData, sendData.length,</span><br><span class="line">IPAddress,9876);</span><br><span class="line">clientSocket.send(sendPacket);</span><br><span class="line">DatagramPacket receivePacket =</span><br><span class="line">   new DatagramPacket(receiveData, receiveData.length);</span><br><span class="line">clientSocket.receive(receivePacket);</span><br><span class="line">String modifiedSentence=</span><br><span class="line">   new String(receivePacket.getData());</span><br><span class="line">System.out.println(&quot;FROM SERVER:&quot; + modifiedSentence);</span><br><span class="line">clientSocket.close();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP服务器端套接字程序"><a href="#UDP服务器端套接字程序" class="headerlink" title="UDP服务器端套接字程序"></a>UDP服务器端套接字程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.io.*;</span><br><span class="line">import java.net.*;</span><br><span class="line">class UDPServer &#123;</span><br><span class="line">  public static void main(String args[]) throws Exception</span><br><span class="line">  &#123;</span><br><span class="line">    DatagramSocket serverSocket = new DatagramSocket(9876);</span><br><span class="line">     byte[] receiveData = new byte[1024];</span><br><span class="line">     byte[] sendData = new byte[1024];</span><br><span class="line">     while(true)</span><br><span class="line">      &#123;</span><br><span class="line">  DatagramPacket receivePacket =</span><br><span class="line">   new DatagramPacket(receiveData, receiveData.length);</span><br><span class="line">  serverSocket.receive(receivePacket);</span><br><span class="line">       String sentence = new String(receivePacket.getData());</span><br><span class="line">       InetAddress IPAddress = receivePacket.getAddress();</span><br><span class="line">       int port = receivePacket.getPort();</span><br><span class="line">       String capitalizedSentence = sentence.toUpperCase();</span><br><span class="line">       sendData = capitalizedSentence.getBytes();</span><br><span class="line">  DatagramPacket sendPacket =</span><br><span class="line">new DatagramPacket(sendData, sendData.length,</span><br><span class="line">IPAddress,port);</span><br><span class="line">      serverSocket.send(sendPacket);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2018/03/08/计算机网络学习-三-socket套接字分析/udp1.png" alt="udp"><br><img src="/2018/03/08/计算机网络学习-三-socket套接字分析/udp2.png" alt="udp"></p><h3 id="UDP连接分析："><a href="#UDP连接分析：" class="headerlink" title="UDP连接分析："></a>UDP连接分析：</h3><p>1、客户端：向服务器端发送长度为60的数据段<br>2、服务器端 :向客户端发送长度为1066的数据段</p><h2 id="总结：与TCP连接相比，UDP显然更快捷，它不需要进行握手请求，也不用进行关闭请求。但是，很明显的是，少了这些以后，没法保证数据是否正常的传输到目的地，没法保证数据传输的可靠性。"><a href="#总结：与TCP连接相比，UDP显然更快捷，它不需要进行握手请求，也不用进行关闭请求。但是，很明显的是，少了这些以后，没法保证数据是否正常的传输到目的地，没法保证数据传输的可靠性。" class="headerlink" title="总结：与TCP连接相比，UDP显然更快捷，它不需要进行握手请求，也不用进行关闭请求。但是，很明显的是，少了这些以后，没法保证数据是否正常的传输到目的地，没法保证数据传输的可靠性。"></a>总结：与TCP连接相比，UDP显然更快捷，它不需要进行握手请求，也不用进行关闭请求。但是，很明显的是，少了这些以后，没法保证数据是否正常的传输到目的地，没法保证数据传输的可靠性。</h2>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络学习(二)-协议分析</title>
      <link href="/2018/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E4%BA%8C-%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
      <content type="html"><![CDATA[<h2 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h2><p>互联网协议分为五层，各层的所有协议被称为协议栈。一般采用自顶向下的方法，首先处理应用层，然后向下进行处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">应用层</span><br><span class="line">运输层</span><br><span class="line">网络层</span><br><span class="line">链路层</span><br><span class="line">物理层</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>国际标准化组织（ISO）提出了计算机网络的七层模型，即开放式互连模型（OSI），并未被使用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">应用层</span><br><span class="line">表示层</span><br><span class="line">会话层</span><br><span class="line">运输层</span><br><span class="line">网络层</span><br><span class="line">链路层</span><br><span class="line">物理层</span><br></pre></td></tr></table></figure></p><!--more--><h2 id="传输层协议分析"><a href="#传输层协议分析" class="headerlink" title="传输层协议分析"></a>传输层协议分析</h2><p><a href="http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html" target="_blank" rel="noopener">socket可参考文章</a><br><a href="https://www.jianshu.com/p/ef892323e68f" target="_blank" rel="noopener">tcp可参考文章</a><br><!--more--></p><h3 id="tcp"><a href="#tcp" class="headerlink" title="tcp"></a>tcp</h3><p><img src="/2018/03/08/计算机网络学习-二-协议分析/tcp.jpg" alt="tcp报文结构"><br>6位标志域。表示为：紧急标志、有意义的应答标志、推、重置连接标志、同步序列号标志、完成发送数据标志。按照顺序排列是：URG、ACK、PSH、RST、SYN、FIN。<br>tcp的具体分析可见下篇，<a href="/2018/03/08/计算机网络学习-三-socket套接字分析/">socket套接字分析</a><br><!--more--></p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ul><li>客户端向服务器发送一个SEQ J,SYN 1</li><li>服务器向客户端响应一个SEQ K，SYN 1, 并进行确认ACK J+1</li><li>客户端再想服务器发一个确认ACK K+1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A: 请求连接</span><br><span class="line">B：好，收到了，可以连了</span><br><span class="line">A：好，我知道你准备好了</span><br></pre></td></tr></table></figure><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul><li>某个应用进程首先调用close主动关闭连接，这时TCP发送一个FIN M；</li><li>另一端接收到FIN M之后，执行被动关闭，对这个FIN进行确认。它的接收也作为文件结束符传递给应用进程，因为FIN的接收意味着应用进程在相应的连接上再也接收不到额外数据；</li><li>一段时间之后，接收到文件结束符的应用进程调用close关闭它的socket。这导致它的TCP也发送一个FIN N；</li><li>接收到这个FIN的源发送端TCP对它进行确认。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">A: 请求关闭</span><br><span class="line">B：好，我知道了，正在关闭</span><br><span class="line">B: 好了，我处理完了，可以关闭连接了</span><br><span class="line">A：好，那就关闭吧</span><br></pre></td></tr></table></figure><h4 id="为什么不是两次握手或者是四次握手"><a href="#为什么不是两次握手或者是四次握手" class="headerlink" title="为什么不是两次握手或者是四次握手"></a>为什么不是两次握手或者是四次握手</h4><p>主旨就是握手过程中，就是在商议A与B之间的初始通信序列号，</p><ul><li>A告诉B自己序列号</li><li>B告诉A，收到且发送自己序列号</li><li>A告诉B，初始成功</li></ul><p>如果两次，无法保证成功，四次则多了，具体可见：<br><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">https://www.zhihu.com/question/24853633</a></p><h3 id="udp"><a href="#udp" class="headerlink" title="udp"></a>udp</h3><p><img src="/2018/03/08/计算机网络学习-二-协议分析/udp.jpg" alt="udp报文结构"></p><h3 id="对传输层协议TCP-UDP进行捕包分析"><a href="#对传输层协议TCP-UDP进行捕包分析" class="headerlink" title="对传输层协议TCP/UDP进行捕包分析"></a>对传输层协议TCP/UDP进行捕包分析</h3><p><img src="/2018/03/08/计算机网络学习-二-协议分析/tcp2.jpg" alt="tcp包分析"></p><p>(1) 向gaia.cs.umass.edu服务器传送文件的客户端主机的IP地址和TCP端口号是多少？<br>答：IP地址是：128.119.245.12<br>    端口号是：80<br>(1) 客户服务器之间用于初始化TCP连接的TCP SYN报文段的序号（sequence number）是多少？在该报文段中，是用什么来标示该报文段是SYN报文段的？<br>    答：seq为0， 用flags相应位置1来标示SYN报文段</p><p>TCP第二次握手协议图如下：<br><img src="/2018/03/08/计算机网络学习-二-协议分析/tcp3.jpg" alt="tcp包分析"></p><p>(1) 服务器向客户端发送的SYNACK报文段序号是多少？该报文段中，ACKnowledgement字段的值是多少？Gaia.cs.umass.edu服务器是如何决定此值的？在该报文段中，是用什么来标示该报文段是SYNACK报文段的？<br>答：SYNACK报文段的seq = 0 ， ACK = 1, 服务器计算方法是ACK = seq(SYN的) + 1， 在这个报文段中，用flags = 0x012来标示<br>(1) 前六个TCP报文段的长度各是多少？<br>答：由图可知，前六个TCP报文段长度为66 bytes、66 bytes、54 bytes、1462 bytes、1462 bytes、1462 bytes<br>(1) 在跟踪文件中是否有重传的报文段？进行判断的依据是什么？<br>答：没有重传的报文段，判断的依据是，如果有重传的报文段的话，那么服务器端向客户端 发送的TCP报文段里，就会出现大量的重复ACK。<br><img src="/2018/03/08/计算机网络学习-二-协议分析/tcp4.jpg" alt="tcp包分析"></p><h2 id="应用层协议分析"><a href="#应用层协议分析" class="headerlink" title="应用层协议分析"></a>应用层协议分析</h2><h3 id="dns分析"><a href="#dns分析" class="headerlink" title="dns分析"></a>dns分析</h3><p>DNS（域名系统）：Domain Name System  因特网的目录服务<br>DNS协议属于应用层协议<br>DNS通常是由其它应用层协议来使用的。<br>DNS是一个在因特网上实现分布式数据库的精彩范例。</p><p>DNS服务器的种类：</p><ul><li>根DNS服务器：用来引导查询获取顶级域名称服务器的域名及对应的顶级域服务器的IP地址。</li><li>顶级域（DNS）服务器：负责顶级域名如：com、org、net、edu、gov，以及所有国家的顶级域名如uk、fr、ca、jp等。</li><li>权威DNS服务器：在因特网上具有公共可访问主机的每个组织机构都必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。权威名称服务器对这些DNS记录进行收藏。</li><li>本地DNS服务器：不属于服务器的层次结构，但对DNS层次结构非常重要。</li></ul><p><img src="/2018/03/08/计算机网络学习-二-协议分析/dns.png" alt="dns分类"></p><h3 id="http分析"><a href="#http分析" class="headerlink" title="http分析"></a>http分析</h3><p>HTTP（超文本传输协议）：Hyper Text Transfer Protocol<br>HTTP协议永远都是客户端发起请求，服务器回送响应。<br>HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。</p><h4 id="http-header"><a href="#http-header" class="headerlink" title="http header"></a>http header</h4><ul><li><p>Host<br>指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含host，否则系统会以400状态码返回。</p></li><li><p>Range<br>Range头域可以请求实体的一个或者多个子范围。<br>一般用于<a href="http://blog.csdn.net/lv18092081172/article/details/51457525" target="_blank" rel="noopener">断点续传</a></p></li><li><p>User-Agent<br>包含发出请求的用户信息，可根据此来判断浏览器类型或爬虫类型。<br>github page 就是根据此屏蔽百度爬虫</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)</span><br></pre></td></tr></table></figure></li><li><p>Cache-Control<br>指定请求和响应遵循的缓存机制,请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。<br>性能提升相关</p></li></ul><h4 id="http长连接"><a href="#http长连接" class="headerlink" title="http长连接"></a>http长连接</h4><p>实际就是保持用于传输http数据的tcp连接保持不断开，使得客户端下一次访问服务端，还可以使用同一个tcp连接，从而避免了建立tcp连接的消耗。<br>对于频繁请求资源的客户来说，较适合使用长连接。但如果连接不断开，随着客户端的增长，保持的长连接也会越来越多，对服务器的压力反而会更大。<br>长连接适用于，操作频繁，点对点的通讯，且连接数不适合太多<br>短连接适用于，连接数较多且不会频繁操作的通讯<br><a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">长连接和短连接的理解</a></p><h4 id="http重定向，301和302"><a href="#http重定向，301和302" class="headerlink" title="http重定向，301和302"></a>http重定向，301和302</h4><p>重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置</p><ul><li>301 代表的是永久性的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</li><li>302 代表的是暂时性的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</li></ul><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><h4 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h4><p>在http之上多了一层SSL/TLS，在http开始时，服务端会先向客户端发送ssl证书，<br>ssl证书中会包含网站基本信息，ca机构，证书编号，服务器的公钥。<br>客户端收到证书后，会使用hash对照证书编号验证一致性与完整性，验证的过程就是查找本地维护的证书中指定的ca机构的公钥，对编号进行解密从而得到编号1，然后用证书中指定的编号生成方式生成一个编号2，如果两个编号相同，则证书验证通过。<br>然后客户端取出服务端的公钥，结合随机数生成一个对称加密的密钥再用服务器的公钥加密后，发回给服务端，服务端用自己的私钥解密之后双方就可以使用对称加密密钥进行通信了。</p><h4 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h4><p>https的握手过程，包含两部分</p><ul><li>tcp三次握手</li><li>ssl/tls 一次握手</li></ul><p>其中SSL/TLS 握手过程包括<br><img src="https://pic002.cnblogs.com/images/2012/38542/2012072310244445.png" alt="https"></p><ul><li>Client Hello<br>握手第一步是客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 Random1、客户端支持的加密套件（Support Ciphers）和 SSL Version 等信息。</li><li>Server Hello<br>第二步是服务端向客户端发送 Server Hello 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 Random2。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。</li><li>Certificate<br>这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</li><li>Server Key Exchange<br>如果是DH算法，这里发送服务器使用的DH参数。RSA算法不需要这一步。</li><li>Certificate Request<br>Certificate Request 是服务端要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到。</li><li>Server Hello Done<br>Server Hello Done 通知客户端 Server Hello 过程结束。</li><li>Certificate Verify<br>客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 Random3，再用服务端公钥非对称加密 Random3 生成 PreMaster Key。</li><li>Client Key Exchange<br>上面客户端根据服务器传来的公钥生成了 PreMaster Key，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 PreMaster Key 得到客户端生成的 Random3。至此，客户端和服务端都拥有 Random1 + Random2 + Random3，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。</li><li>Change Cipher Spec(Client)<br>这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息。</li><li>Encrypted Handshake Message(Client)<br>这一步对应的是 Client Finish 消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。</li><li>Change Cipher Spec(Server)<br>这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。</li><li>Encrypted Handshake Message(Server)<br>这一步对应的是 Server Finish 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</li><li>Application Data<br>到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。</li></ul><h4 id="安全验证"><a href="#安全验证" class="headerlink" title="安全验证"></a>安全验证</h4><p>可以在配置好https后，在<a href="https://myssl.com/" target="_blank" rel="noopener">myssl</a>上验证是否安全<br>一切配置完成后，基本都可以达到A+的评级，下面是对 <a href="https://blog.vgmdj.cn">https://blog.vgmdj.cn</a> 的安全测试<br><a href="https://myssl.com/blog.vgmdj.cn?domain=blog.vgmdj.cn&amp;status=success" target="_blank" rel="noopener">https://myssl.com/blog.vgmdj.cn?domain=blog.vgmdj.cn&amp;status=success</a></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://www.admin10000.com/document/12524.html" target="_blank" rel="noopener">https讲解</a><br><a href="http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html" target="_blank" rel="noopener">https交互图解</a><br><a href="https://www.jianshu.com/p/7158568e4867" target="_blank" rel="noopener">SSL/TLS 握手过程详解</a><br><a href="http://blog.csdn.net/sunmenggmail/article/details/11994013" target="_blank" rel="noopener">rsa加密原理</a><br><a href="https://www.zhihu.com/question/33645891?sort=created" target="_blank" rel="noopener">rsa加密原理2</a></p><h3 id="利用ethereal观察分析协议HTTP和DNS"><a href="#利用ethereal观察分析协议HTTP和DNS" class="headerlink" title="利用ethereal观察分析协议HTTP和DNS"></a>利用ethereal观察分析协议HTTP和DNS</h3><p><img src="/2018/03/08/计算机网络学习-二-协议分析/http1.jpg" alt="http抓包1"><br><img src="/2018/03/08/计算机网络学习-二-协议分析/http2.jpg" alt="http抓包2"><br><img src="/2018/03/08/计算机网络学习-二-协议分析/http3.jpg" alt="http抓包3"><br><img src="/2018/03/08/计算机网络学习-二-协议分析/http4.jpg" alt="http抓包4"></p><h4 id="浏览器运行的是HTTP1-0，还是HTTP1-1？所访问的服务器所运行的HTTP版本号是多少？"><a href="#浏览器运行的是HTTP1-0，还是HTTP1-1？所访问的服务器所运行的HTTP版本号是多少？" class="headerlink" title="浏览器运行的是HTTP1.0，还是HTTP1.1？所访问的服务器所运行的HTTP版本号是多少？"></a>浏览器运行的是HTTP1.0，还是HTTP1.1？所访问的服务器所运行的HTTP版本号是多少？</h4><p>运行的都是HTTP Version 1.1</p><h4 id="浏览器向服务器指出它能接收何种语言版本的对象？"><a href="#浏览器向服务器指出它能接收何种语言版本的对象？" class="headerlink" title="浏览器向服务器指出它能接收何种语言版本的对象？"></a>浏览器向服务器指出它能接收何种语言版本的对象？</h4><p>指出了能接收汉语，英语</p><h4 id="计算机的IP地址是多少？服务器gaia-cs-umass-edu的IP地址是多少？"><a href="#计算机的IP地址是多少？服务器gaia-cs-umass-edu的IP地址是多少？" class="headerlink" title="计算机的IP地址是多少？服务器gaia.cs.umass.edu的IP地址是多少？"></a>计算机的IP地址是多少？服务器gaia.cs.umass.edu的IP地址是多少？</h4><p>本机IP：172.30.164.86，目标IP：128.119.245.12</p><h4 id="从服务器上所获取的HTML文件的最后修改时间是多少？"><a href="#从服务器上所获取的HTML文件的最后修改时间是多少？" class="headerlink" title="从服务器上所获取的HTML文件的最后修改时间是多少？"></a>从服务器上所获取的HTML文件的最后修改时间是多少？</h4><p>最后的修改时间为Tue , 30 Oct 2007 17：00：02</p><h4 id="一共发出了多少个HTTP-GET请求？"><a href="#一共发出了多少个HTTP-GET请求？" class="headerlink" title="一共发出了多少个HTTP GET请求？"></a>一共发出了多少个HTTP GET请求？</h4><p>发出了一个GET请求</p><h4 id="承载这一个HTTP响应报文一共需要多少个data-containing-TCP报文段？"><a href="#承载这一个HTTP响应报文一共需要多少个data-containing-TCP报文段？" class="headerlink" title="承载这一个HTTP响应报文一共需要多少个data-containing TCP报文段？"></a>承载这一个HTTP响应报文一共需要多少个data-containing TCP报文段？</h4><p>4个报文段</p><h4 id="这个HTTP-GET请求相对应的响应报文的状态代码和状态短语是什么？"><a href="#这个HTTP-GET请求相对应的响应报文的状态代码和状态短语是什么？" class="headerlink" title="这个HTTP GET请求相对应的响应报文的状态代码和状态短语是什么？"></a>这个HTTP GET请求相对应的响应报文的状态代码和状态短语是什么？</h4><p>状态码200，短语OK ，意思为请求成功</p><h4 id="定位到DNS查询报文和查询响应报文，这两种报文的发送是基于UDP还是基于TCP的？"><a href="#定位到DNS查询报文和查询响应报文，这两种报文的发送是基于UDP还是基于TCP的？" class="headerlink" title="定位到DNS查询报文和查询响应报文，这两种报文的发送是基于UDP还是基于TCP的？"></a>定位到DNS查询报文和查询响应报文，这两种报文的发送是基于UDP还是基于TCP的？</h4><p>能看出，这两种报文都是基于UDP发送的</p><h4 id="查询报文的目的端口号是多少？DNS查询响应报文的源端口号是多少？"><a href="#查询报文的目的端口号是多少？DNS查询响应报文的源端口号是多少？" class="headerlink" title="查询报文的目的端口号是多少？DNS查询响应报文的源端口号是多少？"></a>查询报文的目的端口号是多少？DNS查询响应报文的源端口号是多少？</h4><p>查询报文:<br><img src="/2018/03/08/计算机网络学习-二-协议分析/dns2.jpg" alt="dns查询"><br>查询响应报文：<br><img src="/2018/03/08/计算机网络学习-二-协议分析/dns3.jpg" alt="dns查询"><br>由图可以看出，两个端口号都是一致的，是53号端口</p>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计算机网络学习(一)-测试通信</title>
      <link href="/2018/03/08/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E4%B8%80-%E6%B5%8B%E8%AF%95%E9%80%9A%E4%BF%A1/"/>
      <content type="html"><![CDATA[<p>之前学习网络的时候做的一些总结，现在正好整理一下，再加深一下记忆<br><a id="more"></a></p><h1 id="测试连接通信主要有5个命令，分别为ping-arp-ipconfig-tracert-netstat"><a href="#测试连接通信主要有5个命令，分别为ping-arp-ipconfig-tracert-netstat" class="headerlink" title="测试连接通信主要有5个命令，分别为ping , arp , ipconfig , tracert , netstat"></a>测试连接通信主要有5个命令，分别为ping , arp , ipconfig , tracert , netstat</h1><!--more--><h2 id="ipconfig-命令（windows）-ifconfig命令（linux）"><a href="#ipconfig-命令（windows）-ifconfig命令（linux）" class="headerlink" title="ipconfig 命令（windows）/ ifconfig命令（linux）"></a>ipconfig 命令（windows）/ ifconfig命令（linux）</h2><p>利用ipconfig命令显示所有当前的TCP/IP网络配置值、刷新动态主机配置协议 (DHCP) 和域名系统 (DNS) 设置。 使用不带参数的IPCONFIG显示所有适配器的 IP 地址、子网掩码、默认网关。<br>利用ifconfig命令可以在linux系统下显示所有适配器的 IP 地址、子网掩码、默认网关。<br><img src="/2018/03/08/计算机网络学习-一-测试通信/ipconfig.png" alt="ipconfig"><br><!--more--></p><h2 id="ping-命令"><a href="#ping-命令" class="headerlink" title="ping 命令"></a>ping 命令</h2><p>Ping向目标主机(地址)发送一个回送请求数据包，要求目标主机收到请求后给予答复，从而判断网络的响应时间和本机是否与目标主机(地址)联通。<br>如果执行Ping不成功，则可以预测故障出现在以下几个方面：网线故障，网络适配器配置不正确，IP地址不正确。如果执行Ping成功而网络仍无法使用，那么问题很可能出在网络系统的软件配置方面，Ping成功只能保证本机与目标主机间存在一条连通的物理路径。<br>命令格式：<br>ping IP地址或主机名 [-t] [-a] [-n count] [-l size]<br>常用参数含义：</p><ul><li>-t不停地向目标主机发送数据；</li><li>-a 以IP地址格式来显示目标主机的网络地址 ；</li><li>-n count 指定要Ping多少次，具体次数由count来指定 ；</li><li>-l size 指定发送到目标主机的数据包的大小。<br><img src="/2018/03/08/计算机网络学习-一-测试通信/ping.png" alt="ping"><!--more--></li></ul><h2 id="tracert-命令-windows-traceroute命令（linux）"><a href="#tracert-命令-windows-traceroute命令（linux）" class="headerlink" title="tracert 命令(windows) / traceroute命令（linux）"></a>tracert 命令(windows) / traceroute命令（linux）</h2><p>Tracert命令用来显示数据包到达目标主机所经过的路径，并显示到达每个节点的时间，分析网络延时产生的原因。<br>Tracert命令用来显示数据包到达目标主机所经过的路径，并显示到达每个节点的时间。命令功能同Ping类似，但它所获得的信息要比Ping命令详细得多，它把数据包所走的全部路径、节点的IP以及花费的时间都显示出来。该命令比较适用于大型网络。<br>命令格式：<br>tracert IP地址或主机名 [-d][-h maximumhops][-j host_list] [-w timeout]<br>参数含义：</p><ul><li>-d 不解析目标主机的名字；</li><li>-h maximum_hops 指定搜索到目标地址的最大跳跃数；</li><li>-j host_list 按照主机列表中的地址释放源路由；</li><li>-w timeout 指定超时时间间隔，程序默认的时间单位是毫秒。</li></ul><p><img src="/2018/03/08/计算机网络学习-一-测试通信/tracert.png" alt="tracert"></p><p>ps: 很实用的一个命令，在使用京东的云主机的时候，出现访问腾讯地图延时过长的问题，使用命令分析后发现是京东云主机默认的主dns服务器对腾讯地图的地址解析过慢（10s以上），更换dns为8.8.8.8后解决问题</p><h2 id="netstat-命令"><a href="#netstat-命令" class="headerlink" title="netstat 命令"></a>netstat 命令</h2><p>Netstat命令了解网络的整体使用情况。显示当前正在活动的网络连接的详细信息，例如显示网络连接、路由表和网络接口信息，统计目前总共有哪些网络连接正在运行。<br>参数含义：</p><ul><li>-a  显示所有连接和侦听端口。</li><li>-b  显示在创建每个连接或侦听端口时涉及的可执行程序。在某些情况下，已知可执行程序承载多个独立的组件，这些情况下，显示创建连接或侦听端口时涉及的组件序列。此情况下，可执行程序的名称位于底部[]中，它调用的组件位于顶部，直至达到 TCP/IP。注意，此选项可能很耗时，并且在没有足够权限时可能失败。</li><li>-e   显示以太网统计。此选项可以与 -s 选项结合使用。</li><li>-f   显示外部地址的完全限定域名(FQDN)。</li><li>-n   以数字形式显示地址和端口号。</li><li>-o   显示拥有的与每个连接关联的进程 ID。</li><li>-p proto  显示 proto 指定的协议的连接；proto 可以是下列任何一个: TCP、UDP、TCPv6 或 UDPv6。如果与 -s 选项一起用来显示每个协议的统计，proto 可以是下列任何一个: IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP或 UDPv6。</li><li>-r    显示路由表。</li><li>-s    显示每个协议的统计。默认情况下，显示IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6的统计；-p 选项可用于指定默认的子网。</li><li>-t    显示当前连接卸载状态。<br><img src="/2018/03/08/计算机网络学习-一-测试通信/netstat.png" alt="netstat"></li></ul><h2 id="arp-命令"><a href="#arp-命令" class="headerlink" title="arp 命令"></a>arp 命令</h2><p>利用ARP确定对应IP地址的网卡物理地址。查看本地计算机或另一台计算机的ARP高速缓存中的当前内容。<br><img src="/2018/03/08/计算机网络学习-一-测试通信/arp.png" alt="arp"></p><h1 id="测试dns服务器与smtp服务器"><a href="#测试dns服务器与smtp服务器" class="headerlink" title="测试dns服务器与smtp服务器"></a>测试dns服务器与smtp服务器</h1><h2 id="nslookup-命令使用"><a href="#nslookup-命令使用" class="headerlink" title="nslookup 命令使用"></a>nslookup 命令使用</h2><p>先从13个根名称服务器中任选一个（本次选择 198.41.0.4）去查找能解析.com的顶级域的域名<br><img src="/2018/03/08/计算机网络学习-一-测试通信/nslookup1.png" alt="nslookup"></p><p>再任选一个（本次选择a.gtld-servers.net）上步给出的顶级域的域名，去查找能解析 baidu.com 的权威名称服务器的域名<br><img src="/2018/03/08/计算机网络学习-一-测试通信/nslookup2.png" alt="nslookup"></p><p>再去上步给出的权威名称服务器中去查找 yun.baidu.com ，最终得到结果<br><img src="/2018/03/08/计算机网络学习-一-测试通信/nslookup3.png" alt="nslookup"></p><h2 id="telnet-命令"><a href="#telnet-命令" class="headerlink" title="telnet 命令"></a>telnet 命令</h2><p>远程连接命令</p><h3 id="Smtp"><a href="#Smtp" class="headerlink" title="Smtp:"></a>Smtp:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Telnet smtp.163.com  25</span><br><span class="line">Helo wang</span><br><span class="line">Auth login</span><br><span class="line">dzMyMTEwNDE4QDE2My5jb20=</span><br><span class="line">d2FuZ3J1aQ==</span><br><span class="line">MAIL FROM:&lt;w32110418@163.com&gt;</span><br><span class="line">RCPT TO:&lt;32110418@qq.com&gt;</span><br><span class="line">Data</span><br><span class="line">TO: 32110418@qq.com</span><br><span class="line">FROM: w32110418@163.com</span><br><span class="line">Subject :test mail</span><br><span class="line">Hahaha</span><br><span class="line">Hahahah</span><br><span class="line">Heheheh</span><br><span class="line">Hehehe</span><br><span class="line">.</span><br><span class="line">Quit</span><br></pre></td></tr></table></figure><p><img src="/2018/03/08//计算机网络学习-一-测试通信/telnet.png" alt="telnet"></p><h3 id="Pop3"><a href="#Pop3" class="headerlink" title="Pop3:"></a>Pop3:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Telnet pop.163.com 110</span><br><span class="line">User w32110418</span><br><span class="line">Pass 120410228</span><br><span class="line">Stat</span><br><span class="line">List 3</span><br><span class="line">Retr 4</span><br><span class="line">Quit</span><br></pre></td></tr></table></figure><p><img src="/2018/03/08/计算机网络学习-一-测试通信/pop3.png" alt="telnet"></p><p><img src="/2018/03/08/计算机网络学习-一-测试通信/pop3-2.png" alt="telnet"></p><p>两种方法都可以实现dos环境下，对邮件的一些操作。但是在操作的过程中，一但输入错误，就必须重新输入，有点烦琐。<br>smtp下，向目标发送的必须是base64转换后的内容。而pop3下就不需要这步。<br>有的邮箱必须是得开启选项后，才能使用这种方法。</p>]]></content>
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>linux 常用命令</title>
      <link href="/2018/03/07/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <content type="html"><![CDATA[<p>记录一下时不时就会遇到，但总是会忘记的几个命令</p><h1 id="bash-篇"><a href="#bash-篇" class="headerlink" title="bash 篇"></a>bash 篇</h1><h2 id="多条件匹配"><a href="#多条件匹配" class="headerlink" title="多条件匹配"></a>多条件匹配</h2><ul><li>-eq  =</li><li>-ne  !=</li><li>-gt  &gt;</li><li>-lt  &lt;</li><li>-ge  &gt;=</li><li><p>-le  &lt;=<br>以上适用于数字</p></li><li><p>-a  &amp;&amp;</p></li><li>-o  ||<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例： 设a=3,b=4,c=5, if (a + b &gt; c &amp;&amp;  b-a &lt; c ) print (&quot;yes&quot;)</span><br><span class="line"></span><br><span class="line">if [a+b -gt c  -a b-a -lt c  ]; then</span><br><span class="line">  echo &quot;yes&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure></li></ul><h2 id="查看端口占用"><a href="#查看端口占用" class="headerlink" title="查看端口占用"></a>查看端口占用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo netstat -apn | grep port</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><ul><li><p>apt purge / apt –purge remove<br>删除已安装包（不保留配置文件)。<br>如软件包a，依赖软件包b，则执行该命令会删除a，而且不保留配置文</p></li><li><p>apt autoremove<br>删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装包），保留配置文件。</p></li><li><p>apt remove<br>删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。</p></li><li><p>apt autoclean<br>APT的底层包是dpkg, 而dpkg 安装Package时, 会将 *.deb 放在 /var/cache/apt/archives/中，apt-get autoclean 只会删除 /var/cache/apt/archives/ 已经过期的deb</p></li><li><p>apt clean<br>使用 apt-get clean 会将 /var/cache/apt/archives/ 的 所有 deb 删掉，可以理解为 rm /var/cache/apt/archives/*.deb。</p><!--more--></li></ul><h2 id="查看存储空间"><a href="#查看存储空间" class="headerlink" title="查看存储空间"></a>查看存储空间</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free 查看内存使用情况</span><br><span class="line">df -h 查看各挂载点所占用和可用空间</span><br><span class="line">du -sh * 查看当前目录下所有文件和文件夹所占空间</span><br></pre></td></tr></table></figure><h2 id="生成ssh密钥"><a href="#生成ssh密钥" class="headerlink" title="生成ssh密钥"></a>生成ssh密钥</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure><h2 id="进程查看"><a href="#进程查看" class="headerlink" title="进程查看"></a>进程查看</h2><ul><li>-e 显示所有的进程</li><li>-f 显示全格式<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep nginx</span><br><span class="line">可以查看nginx的运行情况</span><br></pre></td></tr></table></figure></li></ul><h2 id="进程结束-kill"><a href="#进程结束-kill" class="headerlink" title="进程结束 kill"></a>进程结束 kill</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -15 pid = kill pid , SIGTERM,  通知程序正常退出</span><br><span class="line">kill -9 pid , SIGKILL， 使程序强制退出</span><br></pre></td></tr></table></figure><h1 id="vim-篇"><a href="#vim-篇" class="headerlink" title="vim 篇"></a>vim 篇</h1><h2 id="显示行号"><a href="#显示行号" class="headerlink" title="显示行号"></a>显示行号</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">：set number</span><br></pre></td></tr></table></figure><h2 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h2><ul><li><p>当前行替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:s/src/dst/g</span><br></pre></td></tr></table></figure></li><li><p>全文替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/src/dst/g</span><br></pre></td></tr></table></figure></li><li><p>全文确认替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/src/dst/gc</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 命令 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go语言学习-sync</title>
      <link href="/2017/08/02/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-sync/"/>
      <content type="html"><![CDATA[<h2 id="sync包介绍"><a href="#sync包介绍" class="headerlink" title="sync包介绍"></a>sync包介绍</h2><p>sync包是go提供的实现锁机制的集合</p><h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><p>sync.Mutex是互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。</p><h2 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h2><p>sync.RWMutex是读写锁，它的作用是允许同一时间多个线程对变量进行读操作，但是只能一个线程进行写操作，常用于读操作远远多于写操作的场景下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l := new(sync.RWMutex)</span><br></pre></td></tr></table></figure></p><ul><li><p>l.RLock 读锁<br>当有写锁时，无法加载读锁，当只有读锁或者没有锁时，可以加载多个读锁，所有适合读多写少的场景</p></li><li><p>l.RUnlock 读解锁<br>对之前加的读锁进行解锁，需要注意的是，一旦没有读锁，而进行解锁，就会引发一个运行时错误</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// RUnlock undoes a single RLock call;</span><br><span class="line">// it does not affect other simultaneous readers.</span><br><span class="line">// It is a run-time error if rw is not locked for reading</span><br><span class="line">// on entry to RUnlock.</span><br><span class="line">func (rw *RWMutex) RUnlock() &#123;</span><br><span class="line">if race.Enabled &#123;</span><br><span class="line">_ = rw.w.state</span><br><span class="line">race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))</span><br><span class="line">race.Disable()</span><br><span class="line">&#125;</span><br><span class="line">if r := atomic.AddInt32(&amp;rw.readerCount, -1); r &lt; 0 &#123;</span><br><span class="line">if r+1 == 0 || r+1 == -rwmutexMaxReaders &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">throw(&quot;sync: RUnlock of unlocked RWMutex&quot;)</span><br><span class="line">&#125;</span><br><span class="line">// A writer is pending.</span><br><span class="line">if atomic.AddInt32(&amp;rw.readerWait, -1) == 0 &#123;</span><br><span class="line">// The last reader unblocks the writer.</span><br><span class="line">runtime_Semrelease(&amp;rw.writerSem, false)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if race.Enabled &#123;</span><br><span class="line">race.Enable()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>readerCount是读锁的计数，一旦读解锁比加锁多，则readerCount小于0，会抛出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw(&quot;sync: RUnlock of unlocked RWMutex&quot;)</span><br></pre></td></tr></table></figure></p><ul><li>l.Lock 写锁<br>当有读锁时，写锁会等待读锁解锁后，再进行加锁，即同一变量加读锁后再加写锁，写锁会阻塞</li></ul><ul><li>死锁<br>写锁等待读锁解锁，读锁解锁等待加写锁，引发死锁。当然，go的并发编程里还有别的情况会引发死锁，比如channel, WaitGroup等<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> l := new(sync.RWMutex)</span><br><span class="line">l.RLock()</span><br><span class="line">l.Lock()</span><br><span class="line">l.RUnlock()</span><br><span class="line">l.Unlock()</span><br></pre></td></tr></table></figure></li></ul><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><p>WaitGroup用于等待一组goroutine执行完成，主线程调用Add方法来设置要等待的goroutine数量，每个goroutine运行后会调用Done方法，同时Wait方法会一直堵塞直到所有goroutine执行完成。包含三个函数Add(), Done(), Wait()</p><ul><li><p>Add(delta int)<br>使计数器加delta</p></li><li><p>Done()<br>使计数器减1</p></li><li><p>Wait()<br>等待计数器变为0</p></li><li><p>并发的输出0-4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">wg := &amp;sync.WaitGroup&#123;&#125;</span><br><span class="line"></span><br><span class="line">for i := 0; i &lt; 5; i++ &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">go func(i int) &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">log.Printf(&quot;i:%d&quot;, i)</span><br><span class="line">&#125;(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">log.Println(&quot;exit&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h2><p>sync.Cond是用来控制某个条件下，goroutine进入等待时期，等待信号到来，然后重新启动。比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    locker := new(sync.Mutex)</span><br><span class="line">    cond := sync.NewCond(locker)</span><br><span class="line">    done := false</span><br><span class="line"></span><br><span class="line">    cond.L.Lock()</span><br><span class="line"></span><br><span class="line">    go func() &#123;</span><br><span class="line">        time.Sleep(2e9)</span><br><span class="line">        done = true</span><br><span class="line">        cond.Signal()</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    if (!done) &#123;</span><br><span class="line">        cond.Wait()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(&quot;now done is &quot;, done);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里当主goroutine进入cond.Wait的时候，就会进入等待，当从goroutine发出信号之后，主goroutine才会继续往下面走。</p><p>sync.Cond还有一个BroadCast方法，用来通知唤醒所有等待的gouroutine。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">    &quot;fmt&quot;</span><br><span class="line">    &quot;sync&quot;</span><br><span class="line">    &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var locker = new(sync.Mutex)</span><br><span class="line">var cond = sync.NewCond(locker)</span><br><span class="line"></span><br><span class="line">func test(x int) &#123;</span><br><span class="line"></span><br><span class="line">    cond.L.Lock() // 获取锁</span><br><span class="line">    cond.Wait()   // 等待通知  暂时阻塞</span><br><span class="line">    fmt.Println(x)</span><br><span class="line">    time.Sleep(time.Second * 1)</span><br><span class="line">    cond.L.Unlock() // 释放锁，不释放的话将只会有一次输出</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">    for i := 0; i &lt; 40; i++ &#123;</span><br><span class="line">        go test(i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(&quot;start all&quot;)</span><br><span class="line">    cond.Broadcast() //  下发广播给所有等待的goroutine</span><br><span class="line">    time.Sleep(time.Second * 60)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主gouroutine开启后，可以创建多个从gouroutine，从gouroutine获取锁后，进入cond.Wait状态，当主gouroutine执行完任务后，通过BroadCast广播信号。<br>处于cond.Wait状态的所有gouroutine收到信号后将全部被唤醒并往下执行。需要注意的是，从gouroutine执行完任务后，需要通过cond.L.Unlock释放锁， 否则其它被唤醒的gouroutine将没法继续执行。<br>通过查看cond.Wait 的源码就明白为什么需要需要释放锁了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func (c *Cond) Wait() &#123;</span><br><span class="line">    c.checker.check()</span><br><span class="line">    if raceenabled &#123;</span><br><span class="line">        raceDisable()</span><br><span class="line">    &#125;</span><br><span class="line">    atomic.AddUint32(&amp;c.waiters, 1)</span><br><span class="line">    if raceenabled &#123;</span><br><span class="line">        raceEnable()</span><br><span class="line">    &#125;</span><br><span class="line">    c.L.Unlock()</span><br><span class="line">    runtime_Syncsemacquire(&amp;c.sema)</span><br><span class="line">    c.L.Lock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Cond.Wait会自动释放锁等待信号的到来，当信号到来后，第一个获取到信号的Wait将继续往下执行并从新上锁，如果不释放锁， 其它收到信号的gouroutine将阻塞无法继续执行。<br>由于各个Wait收到信号的时间是不确定的，因此每次的输出顺序也都是随机的。</p><h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><p>可用此函数实现单例模式<br>详情可见于 <a href="https://blog.vgmdj.cn/tags/设计模式/">https://blog.vgmdj.cn/tags/设计模式/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  // Once is an object that will perform exactly one action.</span><br><span class="line">  type Once struct &#123;</span><br><span class="line">  m    Mutex</span><br><span class="line">  done uint32</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  func (o *Once) Do(f func()) &#123;</span><br><span class="line">if atomic.LoadUint32(&amp;o.done) == 1 &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">// Slow-path.</span><br><span class="line">o.m.Lock()</span><br><span class="line">defer o.m.Unlock()</span><br><span class="line">if o.done == 0 &#123;</span><br><span class="line">defer atomic.StoreUint32(&amp;o.done, 1)</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于Once的实例 o ，如果其done为1，即已经完成do操作，则直接返回，否则加锁更新为1，并执行函数f</p><h2 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h2><p>临时对象池，当多个goroutine都需要创建同一个对象的时候，如果goroutine过多，可能导致对象的创建数目剧增。 而对象又是占用内存的，进而导致的就是内存回收的GC压力徒增。造成“并发大－占用内存大－GC缓慢－处理并发能力降低－并发更大”这样的恶性循环。 在这个时候，我们非常迫切需要有一个对象池，每个goroutine不再自己单独创建对象，而是从对象池中获取出一个对象（如果池中已经有的话）。 这就是sync.Pool出现的目的了。<br>sync.Pool的使用非常简单，提供两个方法:Get和Put 和一个初始化回调函数New。</p>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>go语言学习-总览</title>
      <link href="/2017/08/01/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要是记录go语言学习过程中遇到的一些难点，在此用于分享和备忘，如有错误或更好的见解，请留言</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="https://blog.vgmdj.cn/tags/Golang">https://blog.vgmdj.cn/tags/Golang</a><br><a id="more"></a></p><h2 id="机制"><a href="#机制" class="headerlink" title="机制"></a>机制</h2><ul><li>并发</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><ul><li>map</li><li>sync</li></ul>]]></content>
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式学习-单例模式</title>
      <link href="/2017/07/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h2 id="单例模式-Singleton"><a href="#单例模式-Singleton" class="headerlink" title="单例模式(Singleton)"></a>单例模式(Singleton)</h2><p>保证同一个类全局只有一个实例对象<br>在第一次实例化后会使用静态变量保存实例，后续全局使用此静态变量<br>在多线程时应该考虑并发问题，防止两次调用都被判定为实例未初始化而重复初始化对象</p><p>PS： 虽然单例简单，我们还是不能任性的用，因为这样做实例会一直存在内存中，一些我们用的不是那么频繁的东西使用了单例是不是就造成了内存的浪费？大家在用单例的时候还是要多思考思考，这个模块适不适合用单例！<br><a id="more"></a></p><h2 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h2><p>书籍：《大话设计模式》，《设计模式之禅》<br>golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank" rel="noopener">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>保证在整个系统中存在唯一的实例，在并发的环境中依旧好用</p><h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>全局共享同一个实例对象（数据库连接等）<br>某一处对此对象的更新全局可见</p><h2 id="golang-实现"><a href="#golang-实现" class="headerlink" title="golang 实现"></a>golang 实现</h2><p>在go中可以使用这么一种机制来保证代码只执行一次，而且不需要我们手工去加锁解锁。<br>那就是sync包里的Once函数，它有一个Do方法，在它中的函数go会只保证仅仅调用一次</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">  &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type singleton struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var instance *singleton</span><br><span class="line">var once sync.Once</span><br><span class="line"></span><br><span class="line">func GetInstance() *singleton &#123;</span><br><span class="line">  once.Do(func() &#123;</span><br><span class="line">      instance = &amp;singleton&#123;&#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  return instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sync-Once解析"><a href="#sync-Once解析" class="headerlink" title="sync.Once解析"></a>sync.Once解析</h2><p>可见于 <a href="/2017/08/02/go语言学习-sync"><strong>go语言学习-sync包</strong></a></p>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式学习-策略模式</title>
      <link href="/2017/07/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h2 id="策略模式-Strategy"><a href="#策略模式-Strategy" class="headerlink" title="策略模式(Strategy)"></a>策略模式(Strategy)</h2><p>策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户<br><a id="more"></a></p><h2 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h2><p>书籍：《大话设计模式》，《设计模式之禅》<br>golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank" rel="noopener">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>需要有一系列不同的算法，这些算法完成的工作是同样的，只是实现不同，强调以相同的方式调用所有的算法，减少算法类和使用算法类之间的耦合</p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>使代码结构清晰，便于维护，简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试<br>每个算法的修改都不会影响到其他的算法</p><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><p>商场商品价格计算，其中涉及到的有商品的单价，个数，折扣<br>折扣的策略有：</p><ul><li>固定折扣</li><li>满减</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type CashSuper interface &#123;</span><br><span class="line">Accept(float64) float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//CashNormal normal strategy</span><br><span class="line">type CashNormal struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (normal CashNormal) Accept(money float64) float64 &#123;</span><br><span class="line">return money</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//CashRebate</span><br><span class="line">type CashRebate struct &#123;</span><br><span class="line">moneyRebate float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (re CashRebate) Accept(money float64) float64 &#123;</span><br><span class="line">return money * re.moneyRebate</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//CashReturn</span><br><span class="line">type CashReturn struct &#123;</span><br><span class="line">moneyCondition float64</span><br><span class="line">moneyReturn    float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (re CashReturn) Accept(money float64) float64 &#123;</span><br><span class="line">if money &gt;= re.moneyCondition &#123;</span><br><span class="line">return money - re.moneyReturn</span><br><span class="line">&#125;</span><br><span class="line">return money</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//use simple factory optimize strategy</span><br><span class="line">type CashContext struct &#123;</span><br><span class="line">strategy CashSuper</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewCashContext(acceptType string) (cashFactory CashContext) &#123;</span><br><span class="line">switch acceptType &#123;</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;wrong type&quot;)</span><br><span class="line"></span><br><span class="line">case &quot;normal&quot;:</span><br><span class="line">cashFactory.strategy = CashNormal&#123;&#125;</span><br><span class="line"></span><br><span class="line">case &quot;0.8rebate&quot;:</span><br><span class="line">cashFactory.strategy = CashRebate&#123;moneyRebate: 0.8&#125;</span><br><span class="line"></span><br><span class="line">case &quot;300return100&quot;:</span><br><span class="line">cashFactory.strategy = CashReturn&#123;300, 100&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (cashFactory CashContext) Accept(money float64) float64 &#123;</span><br><span class="line">return cashFactory.strategy.Accept(money)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式学习-抽象工厂模式</title>
      <link href="/2017/07/03/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h2 id="抽象工厂模式-Abstract-Factory"><a href="#抽象工厂模式-Abstract-Factory" class="headerlink" title="抽象工厂模式(Abstract Factory)"></a>抽象工厂模式(Abstract Factory)</h2><p>工厂模式是对象的生产器，解耦用户对具体对象的依赖。<br>提供一个创建一系列相关或相互依赖的接口，而无需指定它们具体的类<br><a id="more"></a></p><h2 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h2><p>书籍：《大话设计模式》，《设计模式之禅》<br>golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank" rel="noopener">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>多使用于产品系列的交换，与工厂方法模式相比，区别在于，工厂方法一般只是一个工厂只产出一个产品，而抽象工厂的工厂可以产出不同的产品<br>类比汽车</p><ul><li>工厂方法<ul><li>A工厂  A轿车</li><li>B工厂  B轿车</li></ul></li><li>抽象工厂<ul><li>A工厂  A轿车， A客车， A卡车</li><li>B工厂  B轿车， B客车， B卡车</li></ul></li></ul><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>易于交换产品系列，只需要改变具体工厂即可使用不同的产品配置<br>让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中</p><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><p>多数据库处理用户，部分的增删改查</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>代码是根据大话设计模式里的需求编写，但没有找到go中类似C++里System.Reflection的方法，所以只实现到结合简单工厂来对抽象工厂实现</p><ul><li><p>user相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">type User struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">type IUser interface &#123;</span><br><span class="line">Insert(user User)</span><br><span class="line">Delete(user User)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AccessUser struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (au AccessUser) Insert(user User) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (au AccessUser) Delete(user User) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MysqlUser struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (mu MysqlUser) Insert(user User) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mu MysqlUser) Delete(user User) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>department相关</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">type Department struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type IDepartment interface &#123;</span><br><span class="line">Insert(department Department)</span><br><span class="line">Delete(department Department)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type AccessDepartment struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (ad AccessDepartment) Insert(department Department) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (ad AccessDepartment) Delete(department Department) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MysqlDepartment struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (md MysqlDepartment) Insert(department Department) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (md MysqlDepartment) Delete(department Department) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>抽象工厂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const (</span><br><span class="line">Mysql  = &quot;mysql&quot;</span><br><span class="line">Access = &quot;access&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type DatabaseFactory struct &#123;</span><br><span class="line">DB string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (df DatabaseFactory) CreateUser() IUser &#123;</span><br><span class="line">switch df.DB &#123;</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;unknown database return default mysql&quot;)</span><br><span class="line">return new(MysqlUser)</span><br><span class="line"></span><br><span class="line">case Mysql:</span><br><span class="line">return new(MysqlUser)</span><br><span class="line"></span><br><span class="line">case Access:</span><br><span class="line">return new(AccessUser)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (df DatabaseFactory) CreateDepartment() IDepartment &#123;</span><br><span class="line">switch df.DB &#123;</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;unknown database return default mysql&quot;)</span><br><span class="line">return new(MysqlDepartment)</span><br><span class="line"></span><br><span class="line">case Mysql:</span><br><span class="line">return new(MysqlDepartment)</span><br><span class="line"></span><br><span class="line">case Access:</span><br><span class="line">return new(AccessDepartment)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func TestDatabaseFactory(t *testing.T) &#123;</span><br><span class="line">user := User&#123;&#125;</span><br><span class="line">mysqlUser := DatabaseFactory&#123;&quot;mysql&quot;&#125;.CreateUser()</span><br><span class="line">mysqlUser.Insert(user)</span><br><span class="line"></span><br><span class="line">deppartment := Department&#123;&#125;</span><br><span class="line">accessDepartment := DatabaseFactory&#123;&quot;access&quot;&#125;.CreateDepartment()</span><br><span class="line">accessDepartment.Delete(deppartment)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式学习-工厂方法模式</title>
      <link href="/2017/07/02/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h2 id="工厂方法模式-Factory-Method"><a href="#工厂方法模式-Factory-Method" class="headerlink" title="工厂方法模式(Factory Method)"></a>工厂方法模式(Factory Method)</h2><p>工厂模式是对象的生产器，解耦用户对具体对象的依赖。<br>定义了一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。</p><h2 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h2><p>书籍：《大话设计模式》，《设计模式之禅》<br>golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank" rel="noopener">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a><br><a id="more"></a></p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>简单工厂模式虽然实现了对象依赖的解耦，但是每次扩展都要在switch case里添加相应的选择，会修改原有的类，也就是说，违背了开放-封闭原则，而工厂模式则解决了这个问题。<br>工厂方法模式实现时，客户端需要决定实例化哪一个具体的工厂，选择问题仍然存在，但是工厂方法把简单工厂的内部逻辑判断转移到了客户端代码上来，如果要进行扩展，就不用再去修改原来的类了，只需要在客户端进行修改即可</p><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><ul><li>计算器的编写<br>如果用简单工厂模式，一旦要实例化多个计算器，就需要连续创建多次工厂，使代码变的累赘。同时，在新增功能的时候，仍需要对之前的选择部分进行修改，没法完全使模块成为一个易扩展的独立部分</li><li>多数据库处理<br>使用多种数据库对用户表操作，这里应该尽量解除对具体的数据的依赖<br>如果不使用工厂模式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user := new(User)</span><br><span class="line">su := new(MysqlUser)</span><br><span class="line">su.Insert(user)</span><br><span class="line">su.Select(user)</span><br><span class="line"></span><br><span class="line">这里的su被框死了，只能是Mysql的实现，如果要换数据库的话，所有涉及到su的地方都需要修改</span><br></pre></td></tr></table></figure><h2 id="例子-计算器"><a href="#例子-计算器" class="headerlink" title="例子-计算器"></a>例子-计算器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//Operation 操作接口</span><br><span class="line">type Operation interface &#123;</span><br><span class="line">SetNumber(float64, float64)</span><br><span class="line">GetResult() float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BaseOperation 基础类</span><br><span class="line">type BaseOperation struct &#123;</span><br><span class="line">Operation</span><br><span class="line">NumberA float64</span><br><span class="line">NumberB float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (bo *BaseOperation) SetNumber(numberA, numberB float64) &#123;</span><br><span class="line">bo.NumberA = numberA</span><br><span class="line">bo.NumberB = numberB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//OperationAdd 加法运算</span><br><span class="line">type OperationAdd struct &#123;</span><br><span class="line">BaseOperation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (oa OperationAdd) GetResult() float64 &#123;</span><br><span class="line">return oa.NumberA + oa.NumberB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//OperationSub 减法运算类</span><br><span class="line">type OperationSub struct &#123;</span><br><span class="line">BaseOperation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (os OperationSub) GetResult() float64 &#123;</span><br><span class="line">return os.NumberA - os.NumberB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//OperationSubII 工厂接口</span><br><span class="line">type IFactory interface &#123;</span><br><span class="line">CreateOperation() Operation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type FactoryAdd struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (fa FactoryAdd) CreateOperation() Operation &#123;</span><br><span class="line">return new(OperationAdd)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">type user struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">type UserDB interface &#123;</span><br><span class="line">Insert(u user) error</span><br><span class="line">Select(u user) error</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MysqlUserDB struct &#123;</span><br><span class="line">UserDB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (mysql MysqlUserDB) Insert(u user) error &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">func (mysql MysqlUserDB) Select(u user) error &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SqlServerUserDB struct &#123;</span><br><span class="line">UserDB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (sqlServer SqlServerUserDB) Insert(u user) error &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line">func (sqlServer SqlServerUserDB) Select(u user) error &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type DBFactory interface &#123;</span><br><span class="line">CreateFactory() UserDB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type MysqlUserFactory struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (mf MysqlUserFactory) CreateFactory() UserDB &#123;</span><br><span class="line">return new(MysqlUserDB)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type SqlServerFactory struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (sf SqlServerFactory) CreateFactory() UserDB &#123;</span><br><span class="line">return new(SqlServerUserDB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式学习-简单工厂模式</title>
      <link href="/2017/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <content type="html"><![CDATA[<h2 id="简单工厂模式-Simple-Factory"><a href="#简单工厂模式-Simple-Factory" class="headerlink" title="简单工厂模式(Simple Factory)"></a>简单工厂模式(Simple Factory)</h2><p>工厂模式是对象的生产器，解耦用户对具体对象的依赖。<br>通过封闭、继承、多态把程序的耦合度降低，使程序更加的灵活，容易修改，并易于复用。<br>简单工厂模式中，各种运算方法类实现了运算接口，在业务上如果想添加一种运算方法，只需要增加一个实现运算接口的类，并且在工厂类中添加一个类型判断。<br>这种设计适合于业务类型并不是很多的情况，如果业务类型非常多，那么在工作类中就会有一个很长的switch…case结构，这时候使用方法工厂模式会比较合适。<br><a id="more"></a></p><h2 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h2><p>书籍：《大话设计模式》，《设计模式之禅》<br>golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank" rel="noopener">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a><br><!--more--></p><h2 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h2><p>工厂类中包含了必要的逻辑判断，根据客户端的选择条件实例化相应的类，对于客户端来说，去除了与具产品的依赖</p><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><ul><li>计算器的编写<br>如果不使用工厂模式，使用面向过程的思想编写，就会出现每次扩展都需要修改原已经写好的代码，可能会使原来已经实现的功能受到影响，同时不利于阅读和理解</li></ul><h2 id="例子-计算器"><a href="#例子-计算器" class="headerlink" title="例子 - 计算器"></a>例子 - 计算器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">设计一个计算器</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//Operation 操作接口</span><br><span class="line">type Operation interface &#123;</span><br><span class="line">SetNumber(float64, float64)</span><br><span class="line">GetResult() float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//BaseOperation 基础类</span><br><span class="line">type BaseOperation struct &#123;</span><br><span class="line">Operation</span><br><span class="line">NumberA float64</span><br><span class="line">NumberB float64</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (bo *BaseOperation) SetNumber(numberA, numberB float64) &#123;</span><br><span class="line">bo.NumberA = numberA</span><br><span class="line">bo.NumberB = numberB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//OperationAdd 加法运算</span><br><span class="line">type OperationAdd struct &#123;</span><br><span class="line">BaseOperation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (oa OperationAdd) GetResult() float64 &#123;</span><br><span class="line">return oa.NumberA + oa.NumberB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//OperationSub 减法运算类</span><br><span class="line">type OperationSub struct &#123;</span><br><span class="line">BaseOperation</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (os OperationSub) GetResult() float64 &#123;</span><br><span class="line">return os.NumberA - os.NumberB</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//OperationFactory 工厂类</span><br><span class="line">type OperationFactory struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (of OperationFactory) CreateOperation(oper string) Operation &#123;</span><br><span class="line">switch oper &#123;</span><br><span class="line">default:</span><br><span class="line">return nil</span><br><span class="line">case &quot;+&quot;:</span><br><span class="line">return new(OperationAdd)</span><br><span class="line">case &quot;-&quot;:</span><br><span class="line">return new(OperationSub)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//OperationUsage 工厂操作</span><br><span class="line">func OperationUsage() &#123;</span><br><span class="line">factory := new(OperationFactory)</span><br><span class="line">operation := factory.CreateOperation(&quot;+&quot;)</span><br><span class="line">operation.SetNumber(1, 2)</span><br><span class="line">fmt.Printf(&quot;this is add operation, 1+2=%v\n&quot;, operation.GetResult())</span><br><span class="line"></span><br><span class="line">operation = factory.CreateOperation(&quot;-&quot;)</span><br><span class="line">operation.SetNumber(2, 1)</span><br><span class="line">fmt.Printf(&quot;this is sub operation, 2-1=%v\n&quot;, operation.GetResult())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例子-手机厂商"><a href="#例子-手机厂商" class="headerlink" title="例子 - 手机厂商"></a>例子 - 手机厂商</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">设计一个工厂来生产各种厂商的手机</span><br><span class="line">其中初始的厂商有小米，苹果，华为</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">//Phone interface</span><br><span class="line">type Phone interface &#123;</span><br><span class="line">ShowBrand()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//IPhone apple</span><br><span class="line">type IPhone struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (phone IPhone) ShowBrand() &#123;</span><br><span class="line">fmt.Println(&quot;[Phone Brand]: Apple&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//HPhone huawei</span><br><span class="line">type HPhone struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (phone HPhone) ShowBrand() &#123;</span><br><span class="line">fmt.Println(&quot;[Phone Brand]: Huawei&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//XPhone xiaomi</span><br><span class="line">type XPhone struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (phone XPhone) ShowBrand() &#123;</span><br><span class="line">fmt.Println(&quot;[Phone Brand]: Xiaomi&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type PhoneFactory struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (factory PhoneFactory) CreatePhone(brand string) Phone &#123;</span><br><span class="line">switch brand &#123;</span><br><span class="line">default:</span><br><span class="line">return nil</span><br><span class="line">case &quot;HW&quot;:</span><br><span class="line">return new(HPhone)</span><br><span class="line">case &quot;XM&quot;:</span><br><span class="line">return new(XPhone)</span><br><span class="line">case &quot;PG&quot;:</span><br><span class="line">return new(IPhone)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func PhoneUsage() &#123;</span><br><span class="line">factory := PhoneFactory&#123;&#125;</span><br><span class="line">phone := factory.CreatePhone(&quot;HW&quot;)</span><br><span class="line">phone.ShowBrand()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="调用及运行结果"><a href="#调用及运行结果" class="headerlink" title="调用及运行结果"></a>调用及运行结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">OperationUsage()</span><br><span class="line">PhoneUsage()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result :</span><br><span class="line"></span><br><span class="line">this is add operation, 1+2=3</span><br><span class="line">this is sub operation, 2-1=1</span><br><span class="line">[Phone Brand]: Huawei</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>设计模式学习-总览</title>
      <link href="/2017/07/01/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E8%A7%88/"/>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文主要是将书中资源整理总结，用于分享和回顾复习，如有错误或更好见解，请留言</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><p><a href="https://blog.vgmdj.cn/tags/设计模式/">https://blog.vgmdj.cn/tags/设计模式/</a></p><h2 id="资料推荐"><a href="#资料推荐" class="headerlink" title="资料推荐"></a>资料推荐</h2><p>书籍：《大话设计模式》，《设计模式之禅》<br>golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank" rel="noopener">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a><br><a id="more"></a></p><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><ul><li>简单工厂模式（Simple Factory）</li><li>工厂方法模式（Factory Method）</li><li>抽象工厂模式（Abstract Factory）</li><li>创建者模式（Builder）</li><li>原型模式（Prototype）</li><li>单例模式（Singleton）</li></ul><h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><ul><li>外观模式（Facade）</li><li>适配器模式（Adapter）</li><li>代理模式（Proxy）</li><li>组合模式（Composite）</li><li>享元模式（Flyweight）</li><li>装饰模式（Decorator）</li><li>桥模式（Bridge）</li></ul><h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><ul><li>中介者模式（Mediator）</li><li>观察者模式（Observer）</li><li>命令模式（Command）</li><li>迭代器模式（Iterator）</li><li>模板方法模式（Template Method）</li><li>策略模式（Strategy）</li><li>状态模式（State）</li><li>备忘录模式（Memento）</li><li>解释器模式（Interpreter）</li><li>职责链模式（Chain of Responsibility）</li><li>访问者模式（Visitor）</li></ul>]]></content>
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法学习-排序</title>
      <link href="/2017/03/18/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/"/>
      <content type="html"><![CDATA[<h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>算法的排序，一方面作为其他算法的基础，一方面也体现了一些重要的算法的思想，需要我们好好掌握<br>本章代码的go语言实现都可见于： <a href="https://github.com/vgmdj/go_practice/tree/master/algorithm/sort" target="_blank" rel="noopener">https://github.com/vgmdj/go_practice/tree/master/algorithm/sort</a></p><ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li><li>快速排序</li><li>归并排序</li><li>堆排序</li><li>希尔排序</li><li>计数排序</li><li>基数排序</li><li>桶排序<a id="more"></a></li></ul><h2 id="冒泡排序、选择排序"><a href="#冒泡排序、选择排序" class="headerlink" title="冒泡排序、选择排序"></a>冒泡排序、选择排序</h2><p>现在的作用只为了体现算法的思想，熟悉排序的操作，实际工作中没有使用这两个算法的情形，一般是使用其中的一部分操作。</p><ul><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(1)<!--more--></li></ul><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>将一个记录插入到已排好序的有序表中，从而得到一个新的，记录数加1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后 从第2个记录逐个进行插入操作，直到整个序列有序为止。<br>要点是，设立一个临界点，让左边的有序区推着临界点向后，直到临界点到达最后。<br>对于相等的元素，会把想插入的值放在后面，临界点右移，所以，相等的元素的前后顺序也没有变化，所以插入排序是稳定的</p><ul><li>时间复杂度： O(n^2)</li><li>空间复杂度： O(1)</li></ul><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//插入排序</span><br><span class="line">func insertSort(nums []int) &#123;</span><br><span class="line">for i := 1; i &lt; len(nums)-1; i++ &#123;</span><br><span class="line">for j := i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j-1]; j-- &#123;</span><br><span class="line">nums[j], nums[j-1] = nums[j-1], nums[j]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快排是对冒泡排序的一种改进，使用范围很广，同时也是很很多语言的sort包中使用的其中一种方式（一般根据输入数据的情况选择插入排序、快速排序、堆排序中较为合适的一种）<br>它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列<br>可以根据荷兰国旗问题进行改进，使中间部分的值先排好，再对中间部分两边的进行递归</p><ul><li>时间复杂度： O(nlogn) ~ O(n^2)</li><li>平均时间复杂度： O(nlogn)</li><li>空间复杂度： O(1)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//快速排序</span><br><span class="line">func quickSort(values []int) &#123;</span><br><span class="line">if len(values) &lt;= 1 &#123;</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">mid, i := values[0], 1</span><br><span class="line">head, tail := 0, len(values)-1</span><br><span class="line">for head &lt; tail &#123;</span><br><span class="line">if values[i] &gt; mid &#123;</span><br><span class="line">values[i], values[tail] = values[tail], values[i]</span><br><span class="line">tail--</span><br><span class="line">&#125; else &#123;</span><br><span class="line">values[i], values[head] = values[head], values[i]</span><br><span class="line">head++</span><br><span class="line">i++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">values[i-1] = mid</span><br><span class="line">quickSort(values[:i-1])</span><br><span class="line">quickSort(values[i:])</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>分治法的一个典型应用，把整个序列分为左右两个有序序列，再对有序的序列归并成一个有序的序列<br>可有效的解决小和问题和逆序对的问题</p><ul><li>时间复杂度： O(nlogn)</li><li>空间复杂度： O(n)</li></ul><p>时间复杂度的计算：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">根据master公式： T(n) = aT(n/b)+O(n^c)</span><br><span class="line">a=2,b=2,c=1</span><br><span class="line">则 log(2,2) == c</span><br><span class="line">时间复杂度为：</span><br><span class="line">O(n^1*logn)，即 O(nlogn)</span><br></pre></td></tr></table></figure></p><p>代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">func mergeSort(nums []int) []int &#123;</span><br><span class="line">if len(nums) &lt;= 1 &#123;</span><br><span class="line">return nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mid := len(nums) / 2</span><br><span class="line">nums1 := mergeSort(nums[:mid])</span><br><span class="line">nums2 := mergeSort(nums[mid:])</span><br><span class="line"></span><br><span class="line">return merge(nums1, nums2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func merge(nums1 []int, nums2 []int) []int &#123;</span><br><span class="line">var nums3 []int</span><br><span class="line">var position1, position2 int</span><br><span class="line"></span><br><span class="line">for position1 &lt; len(nums1) &amp;&amp; position2 &lt; len(nums2) &#123;</span><br><span class="line">if nums1[position1] &lt; nums2[position2] &#123;</span><br><span class="line">nums3 = append(nums3, nums1[position1])</span><br><span class="line">position1++</span><br><span class="line">&#125; else &#123;</span><br><span class="line">nums3 = append(nums3, nums2[position2])</span><br><span class="line">position2++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">nums3 = append(nums3, nums1[position1:]...)</span><br><span class="line">nums3 = append(nums3, nums2[position2:]...)</span><br><span class="line"></span><br><span class="line">return nums3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的职业发展之路</title>
      <link href="/2017/03/05/%E6%88%91%E7%9A%84%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E4%B9%8B%E8%B7%AF-%E6%A0%A1%E6%8B%9B/"/>
      <content type="html"><![CDATA[<h2 id="毕业选择"><a href="#毕业选择" class="headerlink" title="毕业选择"></a>毕业选择</h2><p>随着毕业的临近，每天都会一次又一次的问自己，到底想干什么？</p><ul><li>程序员<br>使用大学里学到的技能，为自己赚点饭钱，不停挑战自己的极限，最终成为一个在计算机领域专家<br>优点：各方面还算熟悉，总归是一直在计算机专业环境下，无论是想学哪块，相信都不会太难<br>缺点：方面不明确，行业前景看不清，没有领路人</li><li>公务员<br>就在老家，房价便宜，生活没有压力，富不起来，但也不可能饿着，身边朋友多，生活自在悠闲<br>优点：安逸，没必要为了生存一天到晚的忙碌和委屈求全<br>缺点：有上限，从性格、资源等各个方面都不相信自己有官场升职的潜力</li><li>转行干土木<br>依靠家里的资源，不停的学习，最终自己出来单独接项目，成为光荣的包工头<br>优点：与当程序员正相反，家里大多是这一行，发展会很顺利，基本不会走弯路<br>缺点：各方面都不熟悉，最开始无论是想学哪一块，都会很费劲<a id="more"></a></li></ul><h2 id="最终抉择"><a href="#最终抉择" class="headerlink" title="最终抉择"></a>最终抉择</h2><p>年轻就是最大的本钱，虽说刚毕业后的三五年是人生最为关键的时期，每一年都很关键，但我本身也没有一个很明确的目标，同时我也相信自己无论选择哪一方面，最终都不会说没人要，或者是穷到吃不上饭，所以更多的是顺应自己内心的一点偏向，走上码农之路，去领略计算机职业世界的精彩。哪怕最终真的证明没这方面的天赋，行业没有自己想象的那么有趣，也可以再作出改变，我们一生可以做很多的发展选择，我相信无论哪一条路，只要能再次沉下心，去学习去锻炼，都是可以达到行业中等水平，至于能不能达到顶点，那就需要运气和悟性了。<br><!--more--></p><h2 id="校招选择"><a href="#校招选择" class="headerlink" title="校招选择"></a>校招选择</h2><p>春招没有参加，秋招来的公司并不算多，也没有什么大厂，最好的选择反而是亚信了，但是笔试题都跪的一塌糊涂，最终的选择是大连的外包头子-东软<br>最初的想法很简单，东软有大公司的制度和培训，各种外包项目也很容易让人更加了解整个计算机行业的情况，稍稍锻炼个一两年，基本就可以看清自己应该怎么选择了。<br>一年后再来回顾，还是觉着自己当时的选择并没有什么明显的错误，也可能直接去北京找互联网公司更好，但主要还是看个人，差距不会太大。</p><h2 id="东软生活"><a href="#东软生活" class="headerlink" title="东软生活"></a>东软生活</h2><p>平稳，安逸的一年，各路领导都很好，很照顾我们，同学也多，老乡也多，生活也渐渐丰富起来。每天下班后，健个身或者是去旁边的大学里跑步，每个周六都可以在公司里打网球，周日一群单身狗约着一块吃自助，看电影，确实是一段很美好的经历。很多时候，我都在想，如果没有改变，就一直这样下去，可能也能活成别人眼中的潇洒人生。<br>但终归是年轻，总想着让生活更丰富一些，接触到更接近这个时代前沿的东西，参与到推动整个世界发展的技术研发中来，毕竟每个程序员的梦想都是去改变世界，一年期的调整已经足够，是时候开始重新进行人生规划，做一些自己想去做的事情了。</p><h2 id="目标北京"><a href="#目标北京" class="headerlink" title="目标北京"></a>目标北京</h2><p>祝自己好运</p>]]></content>
      
      <categories>
          
          <category> 职业发展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 职业发展 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>算法学习-总览</title>
      <link href="/2017/03/04/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/"/>
      <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>算法是程序员实力体现的一部分，在日常工作中，不停寻求最优算法，应该是程序员的基本修奍了<br>下面先做一些总结，留着以后复习使用<br><a id="more"></a></p><h2 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h2><ul><li>蛮力算法</li><li>迭代算法</li><li>分治算法</li><li>贪心算法</li><li>动态规划</li></ul><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="评价标准"><a href="#评价标准" class="headerlink" title="评价标准"></a>评价标准</h3><ul><li>时间复杂度<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">递归master公式</span><br><span class="line">T(n) = aT(n/b)+O(n^c)</span><br><span class="line">- O(n*log(b,a))         log(b,a)&gt;c</span><br><span class="line">- O(n^c*logn)           log(b,a)=c</span><br><span class="line">- O(n^d)                log(b,a)&lt;c</span><br></pre></td></tr></table></figure></li></ul><!--more--><ul><li>空间复杂度<!--more--></li></ul><h2 id="算法练习"><a href="#算法练习" class="headerlink" title="算法练习"></a>算法练习</h2><p>oj：</p><ul><li><a href="http://www.lintcode.com" target="_blank" rel="noopener">http://www.lintcode.com</a></li><li><a href="http://www.leetcode.com" target="_blank" rel="noopener">http://www.leetcode.com</a><!--more--></li></ul><p>golang算法代码库：</p><ul><li><a href="http://github.com/vgmdj/prictice_guide" target="_blank" rel="noopener">http://github.com/vgmdj/prictice_guide</a></li></ul>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>github+hexo blog 搭建过程（二）：配置</title>
      <link href="/2017/03/04/github-hexo-blog-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B-%E4%BA%8C-%EF%BC%9A%E9%85%8D%E7%BD%AE/"/>
      <content type="html"><![CDATA[<h2 id="站点配置文件-config-yml修改"><a href="#站点配置文件-config-yml修改" class="headerlink" title="站点配置文件_config.yml修改"></a>站点配置文件_config.yml修改</h2><p>主体可参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">hexo next使用文档</a>，下面对其进行补充。<br><a id="more"></a></p><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>推荐注释而不是删除新增<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">#theme: landscape</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></p><!--more--><h3 id="语言配置"><a href="#语言配置" class="headerlink" title="语言配置"></a>语言配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Site</span><br><span class="line">language: zh-Hans</span><br><span class="line"></span><br><span class="line">修改为：</span><br><span class="line">language: zh-CN</span><br></pre></td></tr></table></figure><!--more--><h3 id="新增sitemap"><a href="#新增sitemap" class="headerlink" title="新增sitemap"></a>新增sitemap</h3><h4 id="使用sitemap生成工具"><a href="#使用sitemap生成工具" class="headerlink" title="使用sitemap生成工具"></a>使用sitemap生成工具</h4><p>配置站点地图可以将站点添加进百度收录，之后就可以在百度里搜索到站点的内容了。<br>在blog根目录执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure></p><!--more--><h4 id="修改站点-config-yml配置文件"><a href="#修改站点-config-yml配置文件" class="headerlink" title="修改站点_config.yml配置文件"></a>修改站点_config.yml配置文件</h4><p>新增内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># sitemap</span><br><span class="line">sitemap:</span><br><span class="line">  path: sitemap.xml</span><br><span class="line">baidusitemap:</span><br><span class="line">  path: baidusitemap.xml</span><br></pre></td></tr></table></figure></p><p>修改内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class="line">url: http://blog.vgmdj.cn/</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:title/</span><br><span class="line">permalink_defaults:</span><br><span class="line"></span><br><span class="line">其中url改为自己的域名</span><br></pre></td></tr></table></figure></p><!--more--><h4 id="向百度或谷歌提交网站"><a href="#向百度或谷歌提交网站" class="headerlink" title="向百度或谷歌提交网站"></a>向百度或谷歌提交网站</h4><p>可以参考内容 <a href="https://www.cnblogs.com/tengj/p/5357879.html" target="_blank" rel="noopener">主动提交</a><br>如果使用next主题，可以简化这一过程<br><a href="#jump">next 向百度站长提交内容</a><br><!--more--></p><h3 id="开启本地图片存放"><a href="#开启本地图片存放" class="headerlink" title="开启本地图片存放"></a>开启本地图片存放</h3><p>可查看链接，但是只有新生成的才有，如果是操作前生成的文章，则不会生成文件夹，需要自己手动创建<br><a href="https://www.jianshu.com/p/c2ba9533088a" target="_blank" rel="noopener">hexo博客图片问题</a><br><!--more--></p><h3 id="hexo-deploy配置"><a href="#hexo-deploy配置" class="headerlink" title="hexo deploy配置"></a>hexo deploy配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: git@github.com:vgmdj/vgmdj.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p><a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">其他配置</a></p><p>注意：hexo d的使用需要先配置好<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>ssh免密登录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 返回用户根目录 /c/Users/`whoami`</span><br><span class="line">cd</span><br><span class="line">ssh-keygen -t rsa -C &quot;your_email@example.com&quot;</span><br><span class="line"></span><br><span class="line">---- 一顿回车 ----</span><br><span class="line"></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></p><p>将cat 输出的内容添加到github ssh key中<br>打开<a href="https://github.com/settings/ssh" target="_blank" rel="noopener">new SSH key</a> 添加密钥，title随便写，key为刚刚cat输出的内容<br><!--more--></p><h3 id="github-cname文件被覆盖的问题"><a href="#github-cname文件被覆盖的问题" class="headerlink" title="github cname文件被覆盖的问题"></a>github cname文件被覆盖的问题</h3><p>cname文件注意要放在根目录下的source里，这样才不会每次部署的时候，将cname文件覆盖掉<br><!--more--></p><h2 id="主题配置文件-config-yml修改"><a href="#主题配置文件-config-yml修改" class="headerlink" title="主题配置文件_config.yml修改"></a>主题配置文件_config.yml修改</h2><p>主体可参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">hexo next使用文档</a>，下面对其进行补充。<br><!--more--></p><h3 id="菜单设置"><a href="#菜单设置" class="headerlink" title="菜单设置"></a>菜单设置</h3><p>当前next主题使用的是新的指定icon的方式，即 “||” 前是page地址，后面是想要显示的icon<br>next使用的是<a href="https://fontawesome.com/icons?d=gallery" target="_blank" rel="noopener">fontawesome</a>里的图标，配置文件里的图标都可以进行替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home  </span><br><span class="line">  about: /about/ || user</span><br><span class="line">  tags: /tags/ || tags</span><br><span class="line">  categories: /categories/ || th</span><br><span class="line">  archives: /archives/ || archive</span><br></pre></td></tr></table></figure></p><p>菜单中每项的意义都可以在语言配置文件中查看 /theme/next/language/zh-CN<br>同时，自己新增的菜单也需要在对应的语言配置文件中设置<br><!--more--></p><h3 id="字数统计"><a href="#字数统计" class="headerlink" title="字数统计"></a>字数统计</h3><p>需要注意的是，如果开启了leancloud_visitors，会和busuanzi里的post_views冲突，结果会是在文章里出现两个阅读量统计，所以需要将busuanzi里的post_views置为false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># Show number of visitors to each article.</span><br><span class="line"># You can visit https://leancloud.cn get AppID and AppKey.</span><br><span class="line">leancloud_visitors:</span><br><span class="line">enable: true</span><br><span class="line">app_id: your appid</span><br><span class="line">app_key: your app_key</span><br><span class="line"></span><br><span class="line"># Show Views/Visitors of the website/page with busuanzi.</span><br><span class="line"># Get more information on http://ibruce.info/2015/04/04/busuanzi/</span><br><span class="line">busuanzi_count:</span><br><span class="line">  enable: true</span><br><span class="line">  total_visitors: true</span><br><span class="line">  total_visitors_icon: user</span><br><span class="line">  total_views: true</span><br><span class="line">  total_views_icon: eye</span><br><span class="line">  post_views: false</span><br><span class="line">  post_views_icon: eye</span><br></pre></td></tr></table></figure></p><!--more--><h3 id="sitemap配置"><a href="#sitemap配置" class="headerlink" title="sitemap配置"></a><span id="jump">sitemap配置</span></h3><p>next主题对配置过程作了简化，只需要在主题配置文件里修改即可实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seo: false</span><br><span class="line">baidu_push: false</span><br><span class="line"></span><br><span class="line">改为</span><br><span class="line">seo: true</span><br><span class="line">baidu_push: true</span><br></pre></td></tr></table></figure></p><p>查看/theme/next/layout/_third-party/seo/baidu-push.swig文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.baidu_push %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">(function()&#123;</span><br><span class="line">  var bp = document.createElement(&apos;script&apos;);</span><br><span class="line">  var curProtocol = window.location.protocol.split(&apos;:&apos;)[0];</span><br><span class="line">  if (curProtocol === &apos;https&apos;) &#123;</span><br><span class="line">      bp.src = &apos;https://zz.bdstatic.com/linksubmit/push.js&apos;;        </span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">      bp.src = &apos;http://push.zhanzhang.baidu.com/push.js&apos;;</span><br><span class="line">  &#125;</span><br><span class="line">  var s = document.getElementsByTagName(&quot;script&quot;)[0];</span><br><span class="line">  s.parentNode.insertBefore(bp, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><p>发现和主动推送的实现过程一致<br><!--more--></p><h3 id="gitment-评论"><a href="#gitment-评论" class="headerlink" title="gitment 评论"></a>gitment 评论</h3><p>使用畅言作为评论系统，首页也能显示评论数，还能使用第三方如qq等的登录，但是缺点也很明显，新用户评论，需要绑定手机号等一系列操作，有点麻烦。<br>考虑到受众，使用github 的issues显然更好一点。但是这个gitment的问题也比较多，其中关键的一点是标题起的稍稍长一点，都会导致无法正常初始化评论。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">修改/theme/next/layout/_third-party/comments/gitment.swig</span><br><span class="line"></span><br><span class="line">id: window.location.pathname,</span><br><span class="line">改为：</span><br><span class="line">id: &apos;&#123;&#123; page.date &#125;&#125;&apos;,</span><br></pre></td></tr></table></figure></p><p>这种方式下，只要注意每篇博文的data不要乱改，导致时间一致冲突，就不会有问题<br>方法来源于作者君的<a href="https://github.com/imsun/gitment/issues" target="_blank" rel="noopener">issues</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>百度统计、腾讯分析、畅言等都只是去各自的官网注册账号，然后在主题配置文件里填好相应的配置即可<br><!--more--></p><h2 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚"></a>修改页脚</h2><p>这里只是一些我看着不太统一的地方，将其小小的修改一下<br><!--more--></p><h3 id="添加总访客量、总访问量文字"><a href="#添加总访客量、总访问量文字" class="headerlink" title="添加总访客量、总访问量文字"></a>添加总访客量、总访问量文字</h3><p>开启busuanzi后，页面最下方会生成一个访客量与访问量的统计，但只有图标与数字，而没有相应的文字<br>修改/theme/next/layout/_partials/analytics/busuanzi-counter.swig文件，在相应位置添加“总访客量：”与“总访问量：”的文字解释即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.busuanzi_count.enable %&#125;</span><br><span class="line">&lt;div class=&quot;busuanzi-count&quot;&gt;</span><br><span class="line">  &lt;script async src=&quot;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&quot;&gt;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line">    &lt;span class=&quot;site-uv&quot; title=&quot;&#123;&#123; __(&apos;footer.total_visitors&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;&quot;&gt; 总访客量：&lt;/i&gt;</span><br><span class="line">      &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_uv&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.busuanzi_count.total_views %&#125;</span><br><span class="line">    &lt;span class=&quot;site-pv&quot; title=&quot;&#123;&#123; __(&apos;footer.total_views&apos;) &#125;&#125;&quot;&gt;</span><br><span class="line">      &lt;i class=&quot;fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;&quot;&gt; 总访问量：&lt;/i&gt;</span><br><span class="line">      &lt;span class=&quot;busuanzi-value&quot; id=&quot;busuanzi_value_site_pv&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p><!--more--><h3 id="添加网站备案号"><a href="#添加网站备案号" class="headerlink" title="添加网站备案号"></a>添加网站备案号</h3><p>打开/theme/next/layout/_partials/footer.swig<br>在copyright后，添加代码即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;copyright&quot;&gt;&#123;#</span><br><span class="line">#&#125;&#123;% set current = date(Date.now(), &quot;YYYY&quot;) %&#125;&#123;#</span><br><span class="line">#&#125;&amp;copy; &#123;% if theme.footer.since and theme.footer.since != current %&#125;&#123;&#123; theme.footer.since &#125;&#125; &amp;mdash; &#123;% endif %&#125;&#123;#</span><br><span class="line">#&#125;&lt;span itemprop=&quot;copyrightYear&quot;&gt;&#123;&#123; current &#125;&#125;&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;with-love&quot;&gt;</span><br><span class="line">  &lt;i class=&quot;fa fa-&#123;&#123; theme.footer.icon &#125;&#125;&quot;&gt;&lt;/i&gt;</span><br><span class="line">&lt;/span&gt;</span><br><span class="line">&lt;span class=&quot;author&quot; itemprop=&quot;copyrightHolder&quot;&gt;&#123;&#123; theme.footer.copyright || config.author &#125;&#125;&lt;/span&gt;</span><br><span class="line"></span><br><span class="line">!!!这里就是添加位置！！！</span><br></pre></td></tr></table></figure></p><p>添加内容<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=&quot;http://www.miitbeian.gov.cn/&quot;&gt;京ICP备xxxxxx号&lt;/a&gt;</span><br></pre></td></tr></table></figure></p><!--more--><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p>至此，一个人个博客已基本完成，其实next已经把很多的东西都简化到一个配置参数，我们需要做的，只是看懂这个参数代表的意义，然后填上他，接着运行hexo命令，即可轻松的调试部署<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line"></span><br><span class="line">check http://localhost:4000, 发现无误后</span><br><span class="line"></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 站点建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>github+hexo blog 搭建过程(一)：准备</title>
      <link href="/2017/03/03/github-blog-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一直都有记录的习惯，但内容大多都分散在各个网站，现结合github，使用hexo来搭建一个个人博客，将点滴的记录都聚合在一起，下面是一些关键的搭建过程，一方面作为分享，一方面作为备忘，仅供参考，如有问题请留言通知，谢谢支持！<br>ps: 准备过程和搜索内容没多少变化，不过多记录<br><a id="more"></a></p><h1 id="基本环境准备"><a href="#基本环境准备" class="headerlink" title="基本环境准备"></a>基本环境准备</h1><p>下载安装nodejs和git，我的搭建环境win10 64，可在git bash下运行如下命令测试环境：</p><ul><li>node -v</li><li>npm -v</li><li>git –version<!--more--></li></ul><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>安装过程不再叙述，hexo的安装与使用一直没有什么变化，可自行搜索，安装成功可运行测试命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure></p><p>大致命令集如下：</p><ul><li>npm -g hexo-cli</li><li>cd /c/Users/`whoami`</li><li>mkdir blog</li><li>cd blog</li><li>hexo init</li><li>npm install</li><li>hexo g</li><li>hexo s</li></ul><p>如果一切顺利的话，打开浏览器，访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 便可看到hexo生成的默认主题页面<br><!--more--></p><h1 id="准备主题"><a href="#准备主题" class="headerlink" title="准备主题"></a>准备主题</h1><p>以next主题为例，<a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">github地址</a><br><br>在blog根目录执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p><p>现在我们的blog文件夹内就有了三个配置文件</p><ul><li>站点配置文件$addr/blog/_config.yml</li><li>next主题配置文件$addr/blog/themes/next/_config.yml</li><li>default主题配置文件$addr/blog/themes/landscape/_config.yml</li></ul><p>修改站点配置文件，即可更换主题，后面我们再详细介绍<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#theme: landscape</span><br><span class="line">theme: next</span><br></pre></td></tr></table></figure></p><!--more--><h1 id="hexo-指南"><a href="#hexo-指南" class="headerlink" title="hexo 指南"></a>hexo 指南</h1><p>hexo 常用操作可见于：<br><a href="http://blog.vgmdj.cn/2018/03/02/Hexo-introduction/">Hexo 使用指南</a></p><p>hexo next主题教程：<br><a href="http://theme-next.iissnan.com" target="_blank" rel="noopener">next 官网</a><br>ps: 最好的教程都来源于代码和注释，其次是官网，本篇只是作为补充。<br><!--more--></p>]]></content>
      
      <categories>
          
          <category> 站点建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo 使用指南</title>
      <link href="/2017/03/02/Hexo-introduction/"/>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a><br><a id="more"></a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a><br><!--more--></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a><br><!--more--></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a><br><!--more--></p><h2 id="Trouble-Shooting"><a href="#Trouble-Shooting" class="headerlink" title="Trouble Shooting"></a>Trouble Shooting</h2><h3 id="首页显示排版混乱"><a href="#首页显示排版混乱" class="headerlink" title="首页显示排版混乱"></a>首页显示排版混乱</h3><p>在每个需要的地方，加上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure><p>例如，在一级标题和二级标题间截断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">xxxxxxx</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line">xxxxxxxx</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br><span class="line">## 二级标题</span><br><span class="line">xxxxxxxx</span><br><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure></p><h3 id="标签和分类数量不正确"><a href="#标签和分类数量不正确" class="headerlink" title="标签和分类数量不正确"></a>标签和分类数量不正确</h3><p>删除.deploy_git文件夹和db.json，再删除public文件夹<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo g</span><br><span class="line">hexo s</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure></p><p>这里g执行两次是为了防止小机率的页面渲染不充分的问题<br>s是预览，可以先查看一下有没有什么问题<br>再次部署后，问题解决</p>]]></content>
      
      <categories>
          
          <category> 站点建设 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> blog </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
