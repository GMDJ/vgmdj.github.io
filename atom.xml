<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US">
    <title type="text">vgmdj&#39;s blog</title>
    <subtitle type="html">vgmdj's personal blog.</subtitle>
    <updated>2020-01-08T00:35:54+08:00</updated>
    <id>https://blog.vgmdj.cn/</id>
    <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/" />
    <link rel="self" type="application/atom+xml" href="https://blog.vgmdj.cn/atom.xml" />
    <author>
            <name>VGMDJ</name>
            <uri>https://blog.vgmdj.cn/</uri>
            
                <email>vgmdj.wr@gmail.com</email>
            </author>
    <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights>
    <generator uri="https://gohugo.io/" version="0.62.2">Hugo</generator>
        <entry>
            <title type="text">2019年度总结</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/2019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/" />
            <id>https://blog.vgmdj.cn/posts/2019%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/</id>
            <updated>2019-12-26T19:39:28+00:00</updated>
            <published>2019-12-26T19:53:52+08:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[回顾 2019匆匆而过，审视整个一年中的自己，虽然仍没有达到理想中的目标，但好在进程仍在推进，没有虚度一年时间。
 对于年度目标，基本已完成 对于对比目标，目前而言还差30%左右 对于长期目标，目前确实还差的远，还差80%左右]]></summary>
            
                <content type="html"><![CDATA[<h1 id="回顾">回顾</h1>

<p>2019匆匆而过，审视整个一年中的自己，虽然仍没有达到理想中的目标，但好在进程仍在推进，没有虚度一年时间。</p>

<ul>
<li>对于年度目标，基本已完成</li>
<li>对于对比目标，目前而言还差30%左右</li>
<li>对于长期目标，目前确实还差的远，还差80%左右</li>
</ul>

<h1 id="目标">目标</h1>

<p>遥想最初来北京的时候，面试遇到一个面试官，各种嘲讽、蔑视，难受的同时，更多的是尴尬和羞愧，也发现了自己有很多的问题。后面不断的学习，也是为了以后再也不会遇到这种情况吧。</p>

<ul>
<li>19年的年度目标

<ul>
<li>减肥30斤，已达成（年初时180斤左右，目前143斤左右）</li>
<li>读30本书，已达成（原来是想只看专业类书，但没刷够数，近期离职期间，大量刷了一些心理学，健身方面的书，算是凑够数了）</li>
<li>尝试找女朋女，已达成（19年目标是尝试，虽然结果没成，但也算是完成了）</li>
<li>补足基础问题，已达成（leetcode 刷了200左右补算法，网络和操作系统把考研题刷了一轮）</li>
</ul></li>
<li>对比目标，对比目标算是长期目标的一种，只是是一个很模糊的概念，目前而言的对比对象，就是同级中的中上游水平的那批人，或是在同年毕业的同学或同年毕业的同事中的上游水平的人。</li>
<li>长期目标

<ul>
<li>一直以来的职业规划中，都是向着架构师的目标前进的。</li>
<li>我目前的优势在于毕业后目标基本明确，中间没有试图去转型成前端或区块链，每年都是在积累学习相关方面的内容。</li>
<li>我目前的劣势在于，对于架构师的理解还是太片面，虽然经过学习，大体上有了一个概念，但是没有见过活生生的，符合标准的例子（要与其一起工作，并且工作能体现出来他的专业才算）。</li>
</ul></li>
</ul>

<h1 id="事件">事件</h1>

<ul>
<li>前端入门</li>
<li>小程序入门</li>
<li>初步实践项目管理</li>
<li>初步实践整体架构设计（视野不够开阔，实践整体上还是小家子气）</li>
<li>跳槽</li>
</ul>

<h1 id="提升">提升</h1>

<p>一年里最大的提升就是磨平，耐住了性子，慢慢养成了阅读、健身、总结的习惯。</p>

<p>生活方面：</p>

<ul>
<li>羽毛球水平 upup</li>
<li>网球水平 upup</li>
<li>人际交流更为流畅</li>
<li>英语学了小半年，学了忘，忘了学，词汇量还是扩充了不少</li>
</ul>

<p>专业方面：<br>
基本上还是在还大学的债，大学没学明白的东西，现在再拾起来。总的来讲，工科还是一个实践的学科，理论不与实践结合，不自己亲自动手试一下，学了的东西还是会忘，而且难有明显的进步。</p>

<ul>
<li>算法能力有提升

<ul>
<li>动态规划问题，回溯问题基本都能有思路，并解决，但总体速度还是慢。</li>
<li>分治问题中等水平</li>
<li>贪心算法的问题，基本还是欠练</li>
</ul></li>
<li>网络

<ul>
<li>全部过了一轮</li>
<li>tcp基本是很细的过了几遍</li>
<li>剩余部分，仍然需要再好好过学一下，但是优先级可以向下排</li>
</ul></li>
<li>操作系统

<ul>
<li>全部过了一轮</li>
<li>进程，线程这块重点过了几遍</li>
<li>剩余部分还差得远</li>
</ul></li>
<li>分布式

<ul>
<li>微服务基本有了概念</li>
<li>常见问题基本了解</li>
</ul></li>
</ul>

<h1 id="仍需加强的点">仍需加强的点</h1>

<p>其实现在再回头看，大学学的内容真是的重点中的重点，来回学多少遍都不为过。很多东西，只学会使用方式，不能说没用，但是作用确实有限。基础作为根本，多年的完善，起码从理论方面已经不会大改，每次变动，只要学会变动部分，更新一下自己的知识图谱就可以了，和从头学比要简单太多。</p>

<p>基础篇:</p>

<ul>
<li>算法（leetcode 接着刷）</li>
<li>网络（与 unix 网络编程结合，更深入的理解 socket）</li>
<li>操作系统（与 linux 结合）</li>
<li>Mysql （开始更细致的学，主要从常遇到的问题入手）</li>
<li>Redis （源码级熟悉，实在不行抄一遍）</li>
<li>RabbitMQ（与Kafka 对比着学，主要从架构设计，怎么保证数据的不丢失，怎么保证吞吐量方面入手）</li>
<li>ElasticSearch （深入理解）</li>
</ul>

<p>项目篇:</p>

<ul>
<li>细致分析项目架构</li>
<li>细致分析工作中的高并发、分布式问题，并记录所做的操作与对应的解决问题的原理</li>
<li>细致学习软件工程在工作中的实践</li>
</ul>

<h1 id="2020年度目标">2020年度目标</h1>

<ul>
<li>健身刷脂，体重保持在140斤以下，体脂保持在18%以下</li>
<li>看书30本，并总结笔记

<ul>
<li>本专业书15本，主要学习软件工程，操作系统，分布式，互联网常用中间件方面，使已会的内容梳理地更系统，理解地更深入</li>
<li>非专业书15本，主要学习心理学，话术，历史，文学，管理学方面</li>
</ul></li>
<li>leetcode 刷300题（主要是要养成把刷题当成业余休闲的习惯，并熟悉 Python）</li>
<li>实践一个全栈项目（前端用 vue，后端用 python）</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/" term="职业发展" label="职业发展" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/" term="职业发展" label="职业发展" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">健身学习</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E5%81%A5%E8%BA%AB%E5%AD%A6%E4%B9%A0/" />
            <id>https://blog.vgmdj.cn/posts/%E5%81%A5%E8%BA%AB%E5%AD%A6%E4%B9%A0/</id>
            <updated>2019-07-24T16:23:58+00:00</updated>
            <published>2019-07-24T16:23:51+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[健身学习 健身可使用自重和器械，都可以对自身进行锻炼，但也有些不同之处。在此记录的，是健身学习的总结和经验，学习和实践时间尚短，需要不时的来更新和更正，切记，切记。]]></summary>
            
                <content type="html"><![CDATA[<h1 id="健身学习">健身学习</h1>

<p>健身可使用自重和器械，都可以对自身进行锻炼，但也有些不同之处。在此记录的，是健身学习的总结和经验，学习和实践时间尚短，需要不时的来更新和更正，切记，切记。</p>

<h1 id="拉伸">拉伸</h1>

<p>拉伸分为静态拉伸和动态拉伸，运动前进行拉伸可以很好的避免受伤，但运动前进行静态拉伸，则会降低运动的能力。所以，在运动前适合使用动态拉伸，来活动开身体，避免运动中受伤；在运动后使用静态拉伸，消减延迟性肌肉疼痛。
注意点：静力拉伸的时候，不要大幅晃动，以免造成拉伸拉伤。</p>

<h1 id="肌群划分">肌群划分</h1>

<p>大肌群分为三部分：</p>

<ul>
<li>胸</li>
<li>背</li>
<li>腿</li>
</ul>

<p>小肌群主要有：</p>

<ul>
<li>肩</li>
<li>肱二头肌</li>
<li>肱三头肌</li>
<li>小臂</li>
<li>小腿</li>
<li>腹</li>
</ul>

<h1 id="计划安排原则">计划安排原则</h1>

<p>健身计划的安排，以能达到每个部位都锻炼和各部位锻炼间影响最小为基准进行。
练胸是推的动作，需要肱三头肌进行配合；练背是拉的动作，需要肱二头肌进行配合。即胸和肱三是协同肌，背和肱二是协同肌。若肌耐力较差，背+肱二的组合，会使练胸时，肱二不能完全恢复，使不上力气，从而让胸的训练效果减弱。</p>

<ul>
<li>胸+肱三头肌+肩</li>
<li>背+肱二头肌</li>
<li>腿+臀</li>
<li>腰腹穿插</li>
</ul>

<h1 id="训练注意点">训练注意点</h1>

<p>找准自身强弱点，来相应安排顺序（摸索动作发力阶段）。
比如练胸时一般会代偿到肱三头肌和肩，可以先让肩疲劳，这样更容易找到胸的发力感觉。但是如果肩和肱三头太弱，胸较强，如果先练肩和肱三头，会使练胸时重量加不上去。</p>

<h1 id="训练组数">训练组数</h1>

<p>一般我们要练的都是红肌，即线条好看，耗能大户，不易发胖体质必备。这时最好是让心率在130-150，先从低重量高次数，再加重量减次数。
完成后再来一组渐降组，即依次减重量，再加次数，直到彻底没力气，一次训练就算完成了</p>

<h1 id="训练达标标准">训练达标标准</h1>

<p>以休息后（心率下降到正常水平），仍无力做动作。或完成最低标准动作时，仍会出现大量借力和核心不稳等问题时，表明已经无法完成当前训练，训练已到位。
需要注意的是，如果换低重量仍可以继续，则表明仍然可以训练。如果换动作后仍可以继续，可能是协同的肌肉疲劳，而不是训练的部位到位，需要自己感受判断自身的情况是属于哪一种。</p>

<h1 id="练肩">练肩</h1>

<ul>
<li>弹力带</li>
<li>蝴蝶机反向飞鸟</li>
<li>哑铃侧平举</li>
</ul>

<h1 id="练胸动作">练胸动作</h1>

<ul>
<li>俯卧撑</li>
<li>杠铃卧推</li>
<li>哑铃飞鸟</li>
<li>龙门架夹胸</li>
<li>蝴蝶机夹胸</li>
</ul>

<h1 id="练背动作">练背动作</h1>

<ul>
<li>引体向上</li>
<li>高位下拉</li>
<li>俯身哑铃划船</li>
<li>坐姿绳索划船</li>
</ul>

<h1 id="练腿动作">练腿动作</h1>

<ul>
<li>深蹲</li>
<li>硬拉</li>
<li>杠铃负重深蹲</li>
</ul>

<h1 id="练腹">练腹</h1>

<ul>
<li>卷腹</li>
<li>俯卧挺身</li>
<li>龙旗</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E7%94%9F%E6%B4%BB/" term="生活" label="生活" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E7%94%9F%E6%B4%BB/" term="生活" label="生活" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">js学习-总览</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/js%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/" />
            <id>https://blog.vgmdj.cn/posts/js%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/</id>
            <updated>2019-07-16T15:27:15+00:00</updated>
            <published>2019-07-16T10:46:12+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[JavaScript JavaScript 是一种可以给网站增加交互性的编程语言。JavaScript 是一种客户端语言，也就是说，设计它的目的是在用户的机器上而不是服务器上执行任务。因此，JavaScript 有一些固有的限制，这些限制主要出于如下安全原因。
 JavaScript 不允许写服务器机器上的文件。 JavaScript 不能关闭不是由它自己打开的窗口。这是为了避免一个站点关闭其他任何站点的窗口，从而独占浏览器。 JavaScript 不能从来自另一个服务器的已经打开的网页中读取信息。换句话说，网页不能读取已经打开的其他窗口中的信息，因此无法探察访问这个站点的使用者还在访问其他哪些站点。]]></summary>
            
                <content type="html"><![CDATA[<h1 id="javascript">JavaScript</h1>

<p>JavaScript 是一种可以给网站增加交互性的编程语言。JavaScript 是一种客户端语言，也就是说，设计它的目的是在用户的机器上而不是服务器上执行任务。因此，JavaScript 有一些固有的限制，这些限制主要出于如下安全原因。</p>

<ul>
<li>JavaScript 不允许写服务器机器上的文件。</li>
<li>JavaScript 不能关闭不是由它自己打开的窗口。这是为了避免一个站点关闭其他任何站点的窗口，从而独占浏览器。</li>
<li>JavaScript 不能从来自另一个服务器的已经打开的网页中读取信息。换句话说，网页不能读取已经打开的其他窗口中的信息，因此无法探察访问这个站点的使用者还在访问其他哪些站点。</li>
</ul>

<h1 id="javascript-脚本放在-head-和-body-中的区别">JavaScript 脚本放在 head 和 body 中的区别</h1>

<ul>
<li>在HTML body部分中的JavaScripts会在页面加载的时候被执行。</li>
<li>在HTML head部分中的JavaScripts会在被调用的时候才执行。</li>
</ul>

<p>如果放在 body 中，我们需要在页面加载完成后，再运行，可以在 js ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">window.onload = initAll;

function initAll(){
  ......

}</code></pre></td></tr></table>
</div>
</div>
<h1 id="javascript-针对缓存的处理">JavaScript 针对缓存的处理</h1>

<p>针对使用 back 时，window.onload 不触发，可以使用 window.onunload 来解决，如果 window.onunload 被设置后，页面在后退时，不会使用缓存。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">window.onload = initAll;
window.onunload = function(){};</code></pre></td></tr></table>
</div>
</div>
<h1 id="javascript-的面向对象特性">JavaScript 的面向对象特性</h1>

<ul>
<li>Object, 就是某种东西。对于 JavaScript来说，它处理的对象都在 Web 浏览器中，比如窗口、表单，以及如按钮和复选框的表单元素。</li>
<li>Property, 在 JavaScript 环境中，文档有标题，表单可以有复选框。改变对象的属性就修改了这个对象。相同的属性名可以用于完全不同的对象。假设有一个名为 empty 的属性。在任何合适的地方都可以使用 empty，所以可以说猫的肚子空了，也可以说猫的食盆空了。注意，计算机的键盘和自行车的轮子不仅仅是属性，它们本身也是对象，可以具有自己的属性。所以，对象可以有子对象。</li>
<li>Method，对象可以做的事情称为方法。JavaScript 对象也有方法:按钮的 click()，窗口的 open()，文本的 selected()。圆括号表示它们是方法，而不是属性。</li>
</ul>

<h1 id="浏览器内核">浏览器内核</h1>

<p>浏览器内核是浏览器所彩的渲染内核。主流浏览器的内核有</p>

<ul>
<li>IE - Trident</li>
<li>Chrome - Webkit/Blink</li>
<li>Firefox - Gecko</li>
<li>Safari - Webkit</li>
<li>Opera - Presto</li>
</ul>

<h1 id="dom-document-object-model">DOM（Document Object Model）</h1>

<p>JavaScript 将 文档树中的每一项都当做对象，可以使用 JavaScript 操纵这些对象。用来表示文档中对象的标准模型就 称为 DOM.</p>

<h1 id="图像处理">图像处理</h1>

<p>翻转器是用 JavaScript 实现的一种常见且有效的效果，当用户将鼠标移动到图像上时，会改变网页上的图像，这样页面就能对用户的操作及时做出反应。</p>

<h1 id="事件处理">事件处理</h1>

<p>事件(event)是用户在访问页面时执行的操作。提交表单和在图像上移动鼠标就是两种事件。JavaScript 使用称为事件处理程序(event handler)的命令来处理事件。常见的事件有：</p>

<ul>
<li>窗口事件</li>
<li>表单事件</li>
<li>鼠标事件</li>
<li>键事件</li>
</ul>

<h1 id="窗口和框架处理">窗口和框架处理</h1>

<p>可实现对 iframe 和 window 的操作，包括且不限于 iframe 内内容替换（需同源），window 的重载与新建。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/js/" term="js" label="js" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/js/" term="js" label="js" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">容器学习-k8s证书更换</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0-k8s%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2/" />
            <id>https://blog.vgmdj.cn/posts/%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0-k8s%E8%AF%81%E4%B9%A6%E6%9B%B4%E6%8D%A2/</id>
            <updated>2019-04-29T10:47:12+00:00</updated>
            <published>2019-04-29T09:14:15+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[k8s证书更换 一般正常安装k8s集群，集群证书的有效期是一年，包括以下证书：
 apiserver apiserver-kubelet-client apiserver-etcd-client front-proxy-client etcd/server etcd/peer etcd/healthcheck-client]]></summary>
            
                <content type="html"><![CDATA[<h1 id="k8s证书-更换">k8s证书更换</h1>

<p>一般正常安装k8s集群，集群证书的有效期是一年，包括以下证书：</p>

<ul>
<li>apiserver</li>
<li>apiserver-kubelet-client</li>
<li>apiserver-etcd-client</li>
<li>front-proxy-client</li>
<li>etcd/server</li>
<li>etcd/peer</li>
<li>etcd/healthcheck-client</li>
</ul>

<h1 id="证书过期问题解决办法">证书过期问题解决办法</h1>

<ul>
<li>升级k8s集群，这是推荐方式</li>
<li>重新生成证书，这是懒人方式</li>
</ul>

<h1 id="过期表现">过期表现</h1>

<ul>
<li><p>kubectl 命令报错</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ kubectl get pods
Unable to connect to the server: x509: certificate has expired or is not yet valid
或
The connection to the server xxxxxx:6443 was refused - did you specify the right host or port?

ps：因证书过期，apiserver可能会挂掉，
如果存活，会报第一个错，
如果挂掉，会报第二个错</code></pre></td></tr></table>
</div>
</div></li>

<li><p>证书时间
cfssl-certinfo -cert /etc/kubernetes/pki/apiserver.crt | grep not</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">&#34;not_before&#34;: &#34;2017-04-26T14:03:35Z&#34;,
&#34;not_after&#34;: &#34;2018-04-23T06:57:24Z&#34;,</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h1 id="cfssl安装">cfssl安装</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64

wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64

wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64

chmod +x cfssl_linux-amd64 cfssljson_linux-amd64 cfssl-certinfo_linux-amd64

mv cfssl_linux-amd64 /usr/local/bin/cfssl

mv cfssljson_linux-amd64 /usr/local/bin/cfssljson

mv cfssl-certinfo_linux-amd64 /usr/bin/cfssl-certinfo</code></pre></td></tr></table>
</div>
</div>
<h1 id="操作-步骤">操作步骤</h1>

<h2 id="删除apiserver证书">删除apiserver证书</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">rm -f /etc/kubernetes/pki/apiserver*</code></pre></td></tr></table>
</div>
</div>
<h2 id="删除front-proxy-client证书">删除front-proxy-client证书</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">rm -f /etc/kubernetes/pki/front-proxy-client.*</code></pre></td></tr></table>
</div>
</div>
<h2 id="删除etcd证书">删除etcd证书</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">rm -rf /etc/kubernetes/pki/etcd/healthcheck-client.*
rm -rf /etc/kubernetes/pki/etcd/server.*
rm -rf /etc/kubernetes/pki/etcd/peer.*</code></pre></td></tr></table>
</div>
</div>
<h2 id="配置代理">配置代理</h2>

<p>因kubeadm alpha phase certs 会访问 <a href="https://dl.k8s.io" target="_blank">https://dl.k8s.io</a> ,然后跳转到 <a href="https://storage.googleapis.com/kubernetes-release" target="_blank">https://storage.googleapis.com/kubernetes-release</a> ，所以需要配置代理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">#代理地址以实际为准
export http_proxy=socks5://127.0.0.1:1080
export https_proxy=socks5://127.0.0.1:1080</code></pre></td></tr></table>
</div>
</div>
<h2 id="重新生成证书">重新生成证书</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">kubeadm alpha phase certs apiserver --apiserver-cert-extra-sans xxxxxx --apiserver-advertise-address xxxxxx

kubeadm alpha phase certs apiserver-kubelet-client

kubeadm alpha phase certs front-proxy-client

kubeadm alpha phase certs apiserver-etcd-client

kubeadm alpha phase certs etcd-healthcheck-client

kubeadm alpha phase certs etcd-server

kubeadm alpha phase certs etcd-peer</code></pre></td></tr></table>
</div>
</div>
<h2 id="删除配置文件">删除配置文件</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">rm -f /etc/kubernetes/\*.conf</code></pre></td></tr></table>
</div>
</div>
<h2 id="重新生成配置文件">重新生成配置文件</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">kubeadm alpha phase kubeconfig all --apiserver-advertise-address xxxxxx</code></pre></td></tr></table>
</div>
</div>
<h2 id="重启kubelet">重启kubelet</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">systemctl restart kubelet</code></pre></td></tr></table>
</div>
</div>
<h1 id="新-slave-节点加入">新 slave 节点加入</h1>

<h2 id="生成token">生成token</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">在master节点上

$ kubeadm token create --print-join-command</code></pre></td></tr></table>
</div>
</div>
<p>运行后会创建有效期一天的token，并打印出 <strong>kubeadm join</strong> 指令</p>

<h2 id="ssh到要新加入节点运行指令">ssh到要新加入节点运行指令</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">$ kubeadm join ...... # 上一步打印出的指令</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" term="分布式系统" label="分布式系统" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/k8s/" term="k8s" label="k8s" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" term="分布式系统" label="分布式系统" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">grpc学习-总览</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/grpc%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/" />
            <id>https://blog.vgmdj.cn/posts/grpc%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/</id>
            <updated>2019-04-27T10:00:01+00:00</updated>
            <published>2019-04-27T08:16:21+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[总览  GRPC protocol-buffers protoc]]></summary>
            
                <content type="html"><![CDATA[<h1 id="总览">总览</h1>

<ul>
<li>GRPC</li>
<li>protocol-buffers</li>
<li>protoc</li>
</ul>

<h2 id="grpc">GRPC</h2>

<p>gRPC  是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C++, Python, Ruby, Objective-C, PHP, C#.</p>

<p>gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。</p>

<p>官方文档：</p>

<ul>
<li><a href="https://www.grpc.io/docs" target="_blank">https://www.grpc.io/docs</a></li>
</ul>

<p>中文文档（v1.0版本）：</p>

<ul>
<li><a href="https://doc.oschina.net/grpc" target="_blank">https://doc.oschina.net/grpc</a></li>
</ul>

<h2 id="protocol-buffers">protocol-buffers</h2>

<p>gRPC 默认使用 protocol buffers，这是 Google 开源的一套成熟的结构数据序列化机制（当然也可以使用其他数据格式如 JSON）。</p>

<p>官方文档：</p>

<ul>
<li><a href="https://developers.google.com/protocol-buffers/" target="_blank">https://developers.google.com/protocol-buffers/</a></li>
</ul>

<h2 id="安装">安装</h2>

<p>以 <a href="https://github.com/vgmdj/grpc-example/tree/master/helloworld" target="_blank">https://github.com/vgmdj/grpc-example/tree/master/helloworld</a> 为例</p>

<ul>
<li>install protobuf compiler</li>
</ul>

<blockquote>
<p><a href="https://github.com/protocolbuffers/protobuf/blob/master/README.md#protocol-compiler-installation" target="_blank">https://github.com/protocolbuffers/protobuf/blob/master/README.md#protocol-compiler-installation</a></p>
</blockquote>

<ul>
<li>Install the protoc Go plugin</li>
</ul>

<blockquote>
<p>$ go get -u github.com/golang/protobuf/protoc-gen-go</p>
</blockquote>

<ul>
<li>Rebuild the generated Go code</li>
</ul>

<blockquote>
<p>$ protoc -I helloworld &ndash;go_out=plugins=grpc:./helloworld helloworld/helloworld.proto</p>
</blockquote>

<h2 id="protoc">protoc</h2>

<blockquote>
<p>protoc &ndash;proto_path=IMPORT_PATH &ndash;go_out=DST_DIR path/to/file.proto</p>
</blockquote>

<ul>
<li><p>&ndash;proto_path
指定了 .proto 文件所在的 <strong>目录</strong> 路径，如果为空，则默认为当前路径</p></li>

<li><p>-I IMPORT_PATH的简写，&ndash;proto_path 的简写使用</p></li>

<li><p>&ndash;go_out 生成GO代码在目标目录，go文件名和 proto文件相同，如file.proto ，生成后的go文件为 file.pb.go</p></li>

<li><p>plugins=grpc 与 &ndash;go_out结合，可以指定生成适配 grpc 的代码，使用方式为： &ndash;go_out=plugins=grpc:DST_DIR</p></li>

<li><p>*.proto IMPORT_PATH下的 proto文件，可以指定多个</p></li>
</ul>

<h1 id="举例">举例</h1>

<h2 id="定义-proto-格式">定义 proto 格式</h2>

<p>指定 proto3 语法，并指定一个 package，以避免包名的冲突问题。
 如果提供了 go_package , 则GO package name以 go_package为主。
 即便是提供了 go_package，package 也是需要的，这可以避免 Protocol Buffers name space 和非go语言中的定义冲突。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">syntax</span> <span class="p">=</span> <span class="s">&#34;proto3&#34;</span><span class="p">;</span>
<span class="kn">package</span> <span class="nx">grpc</span><span class="p">.</span><span class="nx">example</span><span class="p">;</span>
<span class="nx">option</span> <span class="nx">go_package</span> <span class="p">=</span> <span class="nx">address</span><span class="p">.</span><span class="nx">book</span>

<span class="kn">import</span> <span class="s">&#34;google/protobuf/timestamp.proto&#34;</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="定义-message">定义 message</h2>

<p>message 是包含有一系列定义的集合，可以使用一些标准的数据类型，包括 bool, int32, float, double, 和 string。 也可以自己定义结构体，使用 <strong>message</strong> 关键字进行定义。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">message Person {
  string name = 1;
  int32 id = 2;  // Unique ID number for this person.
  string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    string number = 1;
    PhoneType type = 2;
  }

  repeated PhoneNumber phones = 4;

  google.protobuf.Timestamp last_updated = 5;
}

// Our address book file is just one of these.
message AddressBook {
  repeated Person people = 1;
}

// define response .
message Reply {
  int32 code = 1;
  string msg = 2;
}</code></pre></td></tr></table>
</div>
</div>
<p>在上面的例子中， Person message 包含了 PhoneNumber messages，同时 AddressBook message 包含了 Person messages。
当然，也可以如上面的例子一样，在message里定义一个messag（PhoneNumber就是定义在Person里）。
也可以使用 enum 指定field的取值范围</p>

<p>&rdquo; = 1&rdquo;, &ldquo; = 2&rdquo; 标识了每一个元素，标识号1-15比更大的数字少一个字节进行编码，所以作为优化，应该使用1-15作为常用的或重复的元素的标号。将16及以上的数字作为不常用的可选元素的标号。重复字段中的每个元素都需要重新编码标记号，因此重复字段尤其适合于此优化。</p>

<p>如果未设置字段值，则使用默认值：对于数值类型为零，对于字符串为空字符串，对于布尔值为假。对于嵌入的message，默认值始终是消息的“默认实例”或“原型”，它没有设置任何字段。调用访问器以获取尚未显式设置的字段的值，始终返回该字段的默认值。</p>

<p>如果一个字段重复，该字段可以重复任意次数（包括零）。在protocol buffer中，重复值的顺序将保留,并将重复字段视为动态大小的数组。</p>

<p>您将在<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank">Protocol Buffer Language Guide</a>中找到一个完整的.proto文件编写指南，包括所有可能的字段类型。不过，不要去寻找类似于类继承的工具——protocol buffer不会这样做。</p>

<h2 id="定义-service">定义 service</h2>

<p>要定义一个服务，就必须在 .proto 文件中进行指定，然后在服务中定义 rpc 方法，指定请求和响应的类型。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">service Manage {
   rpc Add(AddressBook) returns (Reply){};
}</code></pre></td></tr></table>
</div>
</div>
<h2 id="client-server">client &amp; server</h2>

<p>client &amp; server 及更多例子详可见：</p>

<ul>
<li><a href="https://github.com/vgmdj/grpc-example" target="_blank">https://github.com/vgmdj/grpc-example</a></li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/grpc/" term="grpc" label="grpc" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/grpc/" term="grpc" label="grpc" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/rpc/" term="rpc" label="rpc" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">设计模式学习-模板方法模式</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
            <updated>2019-02-18T20:30:47+00:00</updated>
            <published>2019-02-18T13:40:48+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[模板方法模式(TemplateMethod) 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
特点  模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码，再将一些具体的步骤延迟下放到子类中。 模板方法模式就是提供了一个很好的代码复用平台。 当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。]]></summary>
            
                <content type="html"><![CDATA[<h2 id="模板方法模式-templatemethod">模板方法模式(TemplateMethod)</h2>

<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>

<h2 id="特点">特点</h2>

<ul>
<li>模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码，再将一些具体的步骤延迟下放到子类中。</li>
<li>模板方法模式就是提供了一个很好的代码复用平台。</li>
<li>当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。</li>
</ul>

<h2 id="资料推荐">资料推荐</h2>

<p>书籍：《大话设计模式》，《设计模式之禅》
golang相关实现代码:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p>

<h2 id="优点">优点</h2>

<ul>
<li>提供代码复用平台</li>
<li>帮助子类摆脱重复的不变行为</li>
</ul>

<h2 id="golang版本支持">golang版本支持</h2>

<p>模板方法主要是用到了类的继承和多态，但在go里面，由于go使用的是匿名组合的方式，所以需要做一些特殊处理，而不能直接使用。</p>

<h2 id="例子">例子</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">type IHummerModel interface {
	Start()
	Stop()
	Alarm()
	EngineBoom()
}

type HummerModel struct {
	model IHummerModel
}

func (hm *HummerModel) Run() {
	hm.model.Start()
	hm.model.EngineBoom()
	hm.model.Alarm()
	hm.model.Stop()
}

type HummerH1Model struct {
	HummerModel
}

func NewHummerH1Model() *HummerModel {
	return &amp;HummerModel{
		&amp;HummerH1Model{},
	}
}

func (h1 *HummerH1Model) Start() {
	fmt.Println(&#34;hummer h1 start&#34;)
}

func (h1 *HummerH1Model) EngineBoom() {
	fmt.Println(&#34;hummer h1 engine boom&#34;)
}

func (h1 *HummerH1Model) Alarm() {
	fmt.Println(&#34;hummer h1 alarm&#34;)
}

func (h1 *HummerH1Model) Stop() {
	fmt.Println(&#34;hummer h1 stop&#34;)
}

type HummerH2Model struct {
	HummerModel
}

func NewHummerH2Model() *HummerModel {
	return &amp;HummerModel{
		&amp;HummerH2Model{},
	}
}

func (h2 *HummerH2Model) Start() {
	fmt.Println(&#34;hummer h2 start&#34;)
}

func (h2 *HummerH2Model) EngineBoom() {
	fmt.Println(&#34;hummer h2 engine boom&#34;)
}

func (h2 *HummerH2Model) Alarm() {
	fmt.Println(&#34;hummer h2 alarm&#34;)
}

func (h2 *HummerH2Model) Stop() {
	fmt.Println(&#34;hummer h2 stop&#34;)
}

h1 := NewHummerH1Model()
h1.Run()

h2 := NewHummerH2Model()
h2.Run()</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">linux学习-awk命令</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/linux%E5%AD%A6%E4%B9%A0-awk%E5%91%BD%E4%BB%A4/" />
            <id>https://blog.vgmdj.cn/posts/linux%E5%AD%A6%E4%B9%A0-awk%E5%91%BD%E4%BB%A4/</id>
            <updated>2019-01-28T18:32:12+00:00</updated>
            <published>2019-01-28T16:23:04+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[awk命令 常用命令参数  -F fs fs指定输入分隔符，fs可以是字符串或正则表达式，如-F: -v var=value 赋值一个用户定义变量，将外部变量传递给awk -f scripfile 从脚本文件中读取awk命令 -m[fr] val 对val值设置内在限制，-mf选项限制分配给val的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。]]></summary>
            
                <content type="html"><![CDATA[<h1 id="awk命令">awk命令</h1>

<h1 id="常用命令参数">常用命令参数</h1>

<ul>
<li>-F fs   fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:</li>
<li>-v var=value   赋值一个用户定义变量，将外部变量传递给awk</li>
<li>-f scripfile  从脚本文件中读取awk命令</li>
<li>-m[fr] val   对val值设置内在限制，-mf选项限制分配给val的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li>
</ul>

<h1 id="常用组合-print">常用组合-print</h1>

<p>printf 是linux 下的格式化输出命令,有点儿类似于python 和c 语言的printf 命令，常与awk一起组合使用。</p>

<ul>
<li><p>%d: Decimal 十进制整数 &ndash; 对应位置参数必须是十进制整数，否则报错！</p></li>

<li><p>%s: String 字符串 &ndash; 对应位置参数必须是字符串或者字符型，否则报错！</p></li>

<li><p>%c: Char 字符 &ndash; 对应位置参数必须是字符串或者字符型，否则报错！</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">printf &#34;%c\n&#34; def&#34;
d #输出为第一个字符</code></pre></td></tr></table>
</div>
</div></li>

<li><p>%f: Float 浮点 &ndash; 对应位置参数必须是数字型，否则报错！</p></li>

<li><p>%x: 不带正负号的十六进制.使用a至f表示10至15</p></li>

<li><p>%X: 不带正负号的十六进制.使用A至F表示10至15</p></li>

<li><p>0: 以零填补输出,而非空白.这仅发生在字段宽度大于转换后的情况</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">printf &#34;%05d\n&#34; 15
00015 #输出补齐5位</code></pre></td></tr></table>
</div>
</div></li>

<li><p>+: 总是在数值之前放置一个正号或负号,即便是正值也是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">printf &#34;%+d,%+d\n&#34; 15 -15  
+15,-15 #输出带正负号的数值</code></pre></td></tr></table>
</div>
</div></li>

<li><p>空格: 在正值前置一个空格,在负值前置一个负号</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">printf &#34;% d,% d\n&#34; 15 -15  
15,-15 #输出带空格或负号的数值</code></pre></td></tr></table>
</div>
</div></li>

<li><p>-:    将字段里已格式化的值向左对齐</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">printf &#34;|%-10s| |%10s|\n&#34; hello world
|hello     | |     world| #输出%-10s 为左对齐，占10位</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h1 id="语法形式">语法形式</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">awk [options] &#39;script&#39; var=value file(s)
awk [options] -f scriptfile var=value file(s)</code></pre></td></tr></table>
</div>
</div>
<h1 id="工作原理">工作原理</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">awk &#39;BEGIN{ commands } pattern{ commands } END{ commands }&#39;</code></pre></td></tr></table>
</div>
</div>
<ul>
<li>第一步：执行BEGIN{ commands }语句块中的语句；</li>
<li>第二步：从文件或标准输入(stdin)读取一行，然后执行pattern{ commands }语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。</li>
<li>第三步：当读至输入流末尾时，执行END{ commands }语句块。</li>
</ul>

<p>BEGIN语句块在awk开始从输入流中读取行之前被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。</p>

<p>END语句块在awk从输入流中读取完所有的行之后即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。</p>

<p>pattern语句块中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行{ print }，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/linux/" term="linux" label="linux" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/linux/" term="linux" label="linux" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%91%BD%E4%BB%A4/" term="命令" label="命令" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">linux学习-grep命令</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/linux%E5%AD%A6%E4%B9%A0-grep%E5%91%BD%E4%BB%A4/" />
            <id>https://blog.vgmdj.cn/posts/linux%E5%AD%A6%E4%B9%A0-grep%E5%91%BD%E4%BB%A4/</id>
            <updated>2019-01-28T14:31:25+00:00</updated>
            <published>2019-01-28T13:46:02+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[grep命令 grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。
测试用例  testout.txt date 命令，每分钟执行一次的结果，共49622行
1 2 3 4 5 6 7 8 9 10 11 12  以前十行为例： 2018年 12月 12日 星期三 14:53:01 CST 2018年 12月 12日 星期三 14:54:01 CST 2018年 12月 12日 星期三 14:55:01 CST 2018年 12月 12日 星期三 14:56:01 CST 2018年 12月 12日 星期三 14:57:01 CST 2018年 12月 12日 星期三 14:58:01 CST 2018年 12月 12日 星期三 14:59:01 CST 2018年 12月 12日 星期三 15:00:01 CST 2018年 12月 12日 星期三 15:01:01 CST 2018年 12月 12日 星期三 15:02:01 CST    选项  -c 计算符合范本样式的列数。]]></summary>
            
                <content type="html"><![CDATA[

<h1 id="grep命令">grep命令</h1>

<p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>

<h1 id="测试用例">测试用例</h1>

<ul>
<li><p>testout.txt
date 命令，每分钟执行一次的结果，共49622行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">以前十行为例：

2018年 12月 12日 星期三 14:53:01 CST
2018年 12月 12日 星期三 14:54:01 CST
2018年 12月 12日 星期三 14:55:01 CST
2018年 12月 12日 星期三 14:56:01 CST
2018年 12月 12日 星期三 14:57:01 CST
2018年 12月 12日 星期三 14:58:01 CST
2018年 12月 12日 星期三 14:59:01 CST
2018年 12月 12日 星期三 15:00:01 CST
2018年 12月 12日 星期三 15:01:01 CST
2018年 12月 12日 星期三 15:02:01 CST</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h1 id="选项">选项</h1>

<ul>
<li><p>-c 计算符合范本样式的列数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">grep -c &#34;2018年 12月 14日&#34; testout.txt
1440 #24*60=1440

等同于：
grep &#34;2018年 12月 14日&#34; testout.txt |wc -l</code></pre></td></tr></table>
</div>
</div></li>

<li><p>-A&lt;显示列数&gt; 除了显示符合范本样式的那一行之外，并显示该行之后的内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">grep -A 0 &#34;2018年 12月 14日 星期五 23:00:01&#34; testout.txt
2018年 12月 14日 星期五 23:00:01 CST

grep -A 2 &#34;2018年 12月 14日 星期五 23:00:01&#34; testout.txt
2018年 12月 14日 星期五 23:00:01 CST
2018年 12月 14日 星期五 23:01:01 CST
2018年 12月 14日 星期五 23:02:01 CST</code></pre></td></tr></table>
</div>
</div></li>

<li><p>-C&lt;显示列数&gt;或-&lt;显示列数&gt;  除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">grep -C 2 &#34;2018年 12月 14日 星期五 23:00:01&#34; testout.txt
2018年 12月 14日 星期五 22:58:01 CST
2018年 12月 14日 星期五 22:59:01 CST
2018年 12月 14日 星期五 23:00:01 CST
2018年 12月 14日 星期五 23:01:01 CST
2018年 12月 14日 星期五 23:02:01 CST</code></pre></td></tr></table>
</div>
</div></li>

<li><p>-P 支持Perl正则表达式</p></li>

<li><p>-E 支持扩展正则表达式</p></li>

<li><p>-F 不支持正则表达式，将模式按照字面意思匹配</p></li>

<li><p>-e 匹配模板，多次使用模板之间关系为 &lsquo;或&rsquo;</p></li>

<li><p>-l 只列出含有匹配的文本行的文件的文件名，而不显示具体的匹配内容</p></li>

<li><p>-L 列出文件内容不符合指定的范本样式的文件名称。</p></li>

<li><p>-n 列出所有的匹配的文本行，并显示行号</p></li>

<li><p>-v 只显示不匹配的文本行</p></li>

<li><p>-R/-r 递归搜索，搜索当前目录和子目录</p></li>

<li><p>-q 不显示任何信息。</p></li>

<li><p>-h 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</p></li>

<li><p>-H 在显示符合范本样式的那一列之前，标示该列的文件名称。</p></li>

<li><p>-i/-y 忽略字符大小写的差别。</p></li>

<li><p>-w 只显示全字符合的列。</p></li>

<li><p>-s 不显示错误信息。</p></li>

<li><p>-x 整行内容完全匹配</p></li>

<li><p>-o 只输出文件中匹配到的部分。</p></li>
</ul>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/linux/" term="linux" label="linux" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/linux/" term="linux" label="linux" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%91%BD%E4%BB%A4/" term="命令" label="命令" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">influxdb学习-连续查询</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/inflxdb%E5%AD%A6%E4%B9%A0-%E8%BF%9E%E7%BB%AD%E6%9F%A5%E8%AF%A2/" />
            <id>https://blog.vgmdj.cn/posts/inflxdb%E5%AD%A6%E4%B9%A0-%E8%BF%9E%E7%BB%AD%E6%9F%A5%E8%AF%A2/</id>
            <updated>2019-05-06T09:33:20+08:00</updated>
            <published>2019-01-16T14:12:23+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[CONTINUOUS QUERIES influxdb 连续查询功能常与过期机制结合使用，降低时间精度来，以达到提升查询效率，压缩空间的目的。
查看所有的连续查询 1  SHOW CONTINUOUS QUERIES   语法 基础语法 1 2 3 4  CREATE CONTINUOUS QUERY <cq_name> ON <database_name> BEGIN <cq_query> END   cq_query 1  SELECT <function[s]> INTO <destination_measurement> FROM <measurement> [WHERE <stuff>] GROUP BY time(<interval>)[,<tag_key[s]>]   注意点 在cq_query里 WHERE 条件里不需要额外指定时间范围, 因为influxdb会自动根据 group by 里的时间生成时间区间, 所有在 WHERE 条件里指定的时间都会被系统自动忽略.]]></summary>
            
                <content type="html"><![CDATA[

<h1 id="continuous-queries">CONTINUOUS QUERIES</h1>

<p>influxdb 连续查询功能常与过期机制结合使用，降低时间精度来，以达到提升查询效率，压缩空间的目的。</p>

<h1 id="查看所有的连续查询">查看所有的连续查询</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">SHOW CONTINUOUS QUERIES</code></pre></td></tr></table>
</div>
</div>
<h1 id="语法">语法</h1>

<h2 id="基础语法">基础语法</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
BEGIN
  &lt;cq_query&gt;
END</code></pre></td></tr></table>
</div>
</div>
<h2 id="cq-query">cq_query</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">SELECT &lt;function[s]&gt; INTO &lt;destination_measurement&gt; FROM &lt;measurement&gt; [WHERE &lt;stuff&gt;] GROUP BY time(&lt;interval&gt;)[,&lt;tag_key[s]&gt;]</code></pre></td></tr></table>
</div>
</div>
<h2 id="注意点">注意点</h2>

<p>在cq_query里 WHERE 条件里不需要额外指定时间范围, 因为influxdb会自动根据 group by 里的时间生成时间区间, 所有在 WHERE 条件里指定的时间都会被系统自动忽略.</p>

<h1 id="删除连续查询">删除连续查询</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">DROP CONTINUOUS QUERIES &#39;cq_30m&#39; on &#39;db&#39;</code></pre></td></tr></table>
</div>
</div>
<h1 id="开始时间">开始时间</h1>

<p>如果group by time(t)</p>

<ul>
<li>1m &lt; t &lt; 1d
这种情况下, 起始时间是 now() - t 之前的整点开始以 t 为间隔计算，包含当前时间在内的最近的时间点
如 :</li>
<li>5:00 开始, t 为1h , 5:00-1h=4:00, 则第一次查询为 4:00-4:59:999999</li>
<li>5:20 开始, t 为30m ,5:20-30m=4:00, 4:00+30m+30m=5:00, 则第一次查询为 5:00-5:29:999999</li>
<li>5:49 开始, t 为10m ,5:49-10m=5:00, 5:00+10m+10m+10m+10m=5:40, 则第一次查询为 5:40-5:49:999999</li>

<li><p>5:49 开始, t 为12m ,5:49-12m=5:00, 5:00+12m+12m+12m+12m=5:48, 则第一次查询为 5:48-5:59:999999</p></li>

<li><p>t &gt;= 1d
起始时间是 now() - t 之前的零点开始,以t为间隔进行计算, 得到的包含当前时间在内的最近的时间点
计算方式如上</p></li>
</ul>

<h1 id="偏移时间">偏移时间</h1>

<p>cq_basic_offset 为group by time(interval, cq_basic_offset) 控制起始-终止时间的偏移量的参数
一般, influxdb 默认使用UTC时间, 与中国时间差8小时, 所以可以偏移8小时, group by time(1d,8h)</p>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/database/" term="database" label="database" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/database/" term="database" label="database" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/influxdb/" term="influxdb" label="influxdb" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">influxdb-使用</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/influxdb%E5%AD%A6%E4%B9%A0-%E4%BD%BF%E7%94%A8/" />
            <id>https://blog.vgmdj.cn/posts/influxdb%E5%AD%A6%E4%B9%A0-%E4%BD%BF%E7%94%A8/</id>
            <updated>2018-12-15T14:30:58+00:00</updated>
            <published>2018-12-14T17:31:15+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[安装 服务端 推荐使用docker 进行安装
1  docker pull influxdb]]></summary>
            
                <content type="html"><![CDATA[<h1 id="安装">安装</h1>

<h2 id="服务端">服务端</h2>

<p>推荐使用docker 进行安装</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker pull influxdb</code></pre></td></tr></table>
</div>
</div>
<h2 id="客户端">客户端</h2>

<p>influx, 可以安装或使用docker客户端</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker run --rm influxdb influx -host &#39;xxx&#39;</code></pre></td></tr></table>
</div>
</div>
<h1 id="操作文档">操作文档</h1>

<h2 id="command">command</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">https://docs.influxdata.com/influxdb/v1.7/tools/shell/</code></pre></td></tr></table>
</div>
</div>
<h2 id="http">http</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">https://docs.influxdata.com/influxdb/v1.7/tools/api/</code></pre></td></tr></table>
</div>
</div>
<h1 id="基本操作">基本操作</h1>

<h2 id="时间格式">时间格式</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">influx -precision rfc3339
或

influx
&gt; precision rfc3339</code></pre></td></tr></table>
</div>
</div>
<h2 id="查询函数">查询函数</h2>

<ul>
<li>MEAN()-平均值</li>
<li>SUM()-总和</li>
<li>MIN()-最小值</li>
<li>MAX()-最大值</li>
<li>COUNT()-总个数</li>
<li>MEDIAN()-排序后的中值</li>
<li>SPREAD()-最大最小值的差值</li>
<li>DISTINCT()-字段去重</li>
<li>TOP(n)-前几名</li>
</ul>

<h2 id="数据保留策略">数据保留策略</h2>

<blockquote>
<p>SHOW RETENTION POLICIES ON &lsquo;db&rsquo;</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">name	duration	shardGroupDuration	replicaN	default
autogen	   0s		    168h0m0s		     1		    true</code></pre></td></tr></table>
</div>
</div>
<p>duration为数据的何留时长, 默认0s为无限制</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 创建新的策略
create retention policy &#34;name&#34; on &#34;db&#34; duration 30d replication 1 default

# 修改策略
alter retention policy &#34;name&#34; on &#34;db&#34; duration 60d replication 1 default

# 删除策略
drop retention policy &#34;name&#34; on &#34;db&#34;</code></pre></td></tr></table>
</div>
</div>
<p>需要注意的是, 如果创建或修改了新策略, 且设置为default, 那么新旧数据会分开存放, 新的策略里不会有旧的数据, 如果想要查询旧数据, 需要在measurement前加上策略名称</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">select * from &#34;autogen&#34;.db</code></pre></td></tr></table>
</div>
</div>
<h2 id="数据插入">数据插入</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">insert &#39;measurement.name&#39;,&#39;tag1.name&#39;=&#39;tag.value&#39;,&#39;tag2.name&#39;=&#39;tag2.value&#39; &#39;field1.name&#39;=&#39;field1.value&#39;,&#39;field2.name&#39;=&#39;field2.value&#39; timestamp</code></pre></td></tr></table>
</div>
</div>
<p>其中时间戳可以不填，默认为插入时间</p>

<h2 id="数据删除">数据删除</h2>

<p>influxdb 使用delete + where的方式并不是所有情况下都会生效
推荐的使用方式是使用过期策略来实现
如果真的是想删除其中的某一条或几条数据, 可以在 where 条件里使用时间来筛选</p>

<h2 id="用户管理">用户管理</h2>

<p>具体可以参见官方文档
&gt;<a href="https://docs.influxdata.com/influxdb/v1.7/administration/authentication_and_authorization/" target="_blank">https://docs.influxdata.com/influxdb/v1.7/administration/authentication_and_authorization/</a></p>

<p>常用的命令如下:</p>

<ul>
<li><p>查看用户</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">SHOW USERS</code></pre></td></tr></table>
</div>
</div></li>

<li><p>管理员有所有的权限, 创建新的管理员方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">CREATE USER &lt;username&gt; WITH PASSWORD &#39;&lt;password&gt;&#39; WITH ALL PRIVILEGES</code></pre></td></tr></table>
</div>
</div></li>

<li><p>给某个用户管理员权限</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">GRANT ALL PRIVILEGES TO &lt;username&gt;</code></pre></td></tr></table>
</div>
</div></li>

<li><p>改密码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">SET PASSWORD FOR &lt;username&gt; = &#39;&lt;password&gt;&#39;</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<p></p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/database/" term="database" label="database" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/database/" term="database" label="database" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/influxdb/" term="influxdb" label="influxdb" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">influxdb学习-总览</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/influxdb%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/" />
            <id>https://blog.vgmdj.cn/posts/influxdb%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/</id>
            <updated>2019-03-11T13:37:10+08:00</updated>
            <published>2018-12-08T18:05:20+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[简述 influxdb是用go编写的一种时序型数据库，调用使用http协议，特别适用于数据随时间进行更新，且几乎不更新或删除的场景，如实时监控、资产追踪等。]]></summary>
            
                <content type="html"><![CDATA[<h1 id="简述">简述</h1>

<p>influxdb是用go编写的一种时序型数据库，调用使用http协议，特别适用于数据随时间进行更新，且几乎不更新或删除的场景，如实时监控、资产追踪等。</p>

<h1 id="基本概念">基本概念</h1>

<ul>
<li>database
数据库, 类似于传统数据库里的概念</li>
<li>measurement
数据表, 类似于传统数据库里的table的概念</li>
<li>tag
标签, 类似于传统数据库中的有索引项</li>
<li>filed
没有索引属性的记录值</li>
<li>timestamp
时间戳, 每次数据都会有的属性, 是时序数据库中最重要的部分, 可以自己指定或系统生成</li>
<li>series
tags的排列组合</li>
<li>Retention policy
过期机制</li>
<li>points
表中的一行数据</li>
<li>shard
与retention policy相关联, 每一个存储策略下会存在许多 shard，每一个 shard 存储一个指定时间段内的数据，并且不重复。</li>
</ul>

<h1 id="备份">备份</h1>

<h2 id="备份内部-数据">备份内部数据</h2>

<p>即备份最基本的系统信息,用户信息等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">influxd backup /bakup_path</code></pre></td></tr></table>
</div>
</div>
<h2 id="备份数据库">备份数据库</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">influxd backup -database &#39;db&#39; -retention &#39;autogen&#39; -host localhost:8086 -since &#39;2006-01-02T15:04:05Z&#39; /backup_path</code></pre></td></tr></table>
</div>
</div>
<h2 id="恢复">恢复</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">influxd restore [ -metadir | -datadir ] &lt;path-to-meta-or-data-directory&gt; &lt;path-to-backup&gt;</code></pre></td></tr></table>
</div>
</div>
<h1 id="docker-备份">docker 备份</h1>

<p>在正常备份的基础上, 使用docker cp命令实现与本地的文件传输。
可先设置一个映射目录, 再进行备份或恢复操作</p>

<h1 id="时序型数据与传统关系型数据库对比">时序型数据与传统关系型数据库对比</h1>

<h2 id="优势">优势</h2>

<h2 id="劣势">劣势</h2>

<h2 id="适用场景与分析">适用场景与分析</h2>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/database/" term="database" label="database" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/database/" term="database" label="database" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/influxdb/" term="influxdb" label="influxdb" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">go语言学习-装机单</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E8%A3%85%E6%9C%BA%E5%8D%95/" />
            <id>https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E8%A3%85%E6%9C%BA%E5%8D%95/</id>
            <updated>2018-11-29T09:59:01+00:00</updated>
            <published>2018-11-28T18:32:15+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[开发装机单 GO语言后端工作者，常用开发工具集合]]></summary>
            
                <content type="html"><![CDATA[<h1 id="开发装机单">开发装机单</h1>

<p>GO语言后端工作者，常用开发工具集合</p>

<h1 id="语言">语言</h1>

<ul>
<li>go</li>
<li>python</li>
</ul>

<h1 id="编辑器">编辑器</h1>

<ul>
<li>goland</li>
<li>vim</li>
<li>atom

<ul>
<li>plugins: Markdown Preview Enhanced</li>
</ul></li>
</ul>

<h1 id="测试工具">测试工具</h1>

<ul>
<li>Postman</li>
<li>jmeter</li>
</ul>

<h1 id="chrome-plugin">chrome plugin</h1>

<ul>
<li>Infinity</li>
<li>AdBlocker</li>
<li>Proxy SwitchyOmega</li>
<li>JsonView</li>
<li>百度网盘不限速下载</li>
</ul>

<h1 id="构建工具">构建工具</h1>

<ul>
<li>make</li>
<li>protoc</li>
</ul>

<h1 id="git">git</h1>

<ul>
<li>gitkraken</li>
</ul>

<h1 id="文档作图">文档作图</h1>

<ul>
<li>Word</li>
<li>PowerPoint</li>
<li>Excel</li>
<li>OneNote</li>
<li>Xmind</li>
<li>OmniGraffle</li>
<li>Visio</li>
<li>Hugo</li>
</ul>

<h1 id="网络">网络</h1>

<ul>
<li>wireshark</li>
<li>shadowsocks</li>
<li>curl</li>
<li>telnet</li>
<li>tranceroute</li>
<li>openssl</li>
<li>frp</li>
</ul>

<h1 id="数据库">数据库</h1>

<ul>
<li>navicat</li>
<li>rdm</li>
<li>mysql-client</li>
<li>redis-cli</li>
<li>influx</li>
</ul>

<h1 id="docker">docker</h1>

<ul>
<li>centos</li>
<li>golang:1.12</li>
<li>mysql</li>
<li>redis</li>
<li>rabbitmq:3-management</li>
<li>influxdb</li>
<li>grafana</li>
</ul>

<h1 id="通讯">通讯</h1>

<ul>
<li>QQ</li>
<li>微信</li>
<li>钉钉</li>
<li>企业微信</li>
</ul>

<h1 id="音乐">音乐</h1>

<ul>
<li>QQ音乐</li>
<li>网易云音乐</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/golang/" term="Golang" label="Golang" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/golang/" term="Golang" label="Golang" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">linux 常用部署指令</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/linux%E5%B8%B8%E7%94%A8%E9%83%A8%E7%BD%B2%E6%8C%87%E4%BB%A4/" />
            <id>https://blog.vgmdj.cn/posts/linux%E5%B8%B8%E7%94%A8%E9%83%A8%E7%BD%B2%E6%8C%87%E4%BB%A4/</id>
            <updated>2018-11-28T15:11:12+00:00</updated>
            <published>2018-11-27T09:32:50+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[自动化部署 对于自动化部署的构建，常用的几个指令是：
 ssh 远程连接并执行一些指令 scp/rsync 文件传输]]></summary>
            
                <content type="html"><![CDATA[<h1 id="自动化部署">自动化部署</h1>

<p>对于自动化部署的构建，常用的几个指令是：</p>

<ul>
<li>ssh 远程连接并执行一些指令</li>
<li>scp/rsync 文件传输</li>
</ul>

<h1 id="shell">shell</h1>

<h2 id="login-shell">login shell</h2>

<p>简单理解，就是需要登录方式进入的shell，login shell 进入后会依次读取以下几类配置文件</p>

<ul>
<li>/etc/profile</li>
<li>~/.bash_profile, ~/.bash_login, ~/.profile (只读取其中一个配置文件, 匹配其中一个文件后不再读取其它文件, 读取顺序与显示顺序一致)</li>
</ul>

<p>login shell退出时读取并执行~/.bash_logout中的命令。</p>

<h2 id="non-login-shell">non-login shell</h2>

<p>non-login shell, 顾名思义, 不是通过登录的方式进入的shell环境, 如直接使用/usr/bin/bash , /usr/bin/sh 之类进入的shell.
non-login shell 进入后会读取配置文件~/.bashrc</p>

<h2 id="interactive-shell">interactive shell</h2>

<p>在控制台终端或者伪终端里，shell等待你的输入，并且立即执行你提交的命令。这种模式被称作交互式是因为shell与用户进行交互.</p>

<h2 id="non-interactive-shell">non-interactive shell</h2>

<p>使用shell 执行脚本文件, 或者通过管道的形式将输出转向shell程序。 那么脚本运行的环境属于非交互性shell.</p>

<h2 id="判断方式">判断方式</h2>

<ul>
<li>echo $0

<ul>
<li>如果为 -bash , 即第一个符号为-, 则表示该shell为 login shell.</li>
<li>如果为bash，即开头没有- 则代表为non-login shell</li>
</ul></li>
<li>echo $-

<ul>
<li>如果返回的为 himBH则为interactive shell</li>
<li>如果返回的为hB, 则为interactive shell</li>
</ul></li>
</ul>

<h2 id="组合情况及常见场景">组合情况及常见场景</h2>

<ul>
<li><p>login shell &amp; interactive shell<br>
ssh 远程服务器, 等待用户输入shell</p></li>

<li><p>login shell &amp; non-interactive shell<br>
ssh 远程服务器, 执行脚本</p></li>

<li><p>non-login shell &amp; interactive shell<br>
ssh 远程服务器, su 切换角色, 等待用户输入</p></li>

<li><p>non-login shell &amp; non-interactive shell<br>
ssh 远程服务器, su 切换角色, 执行脚本文件</p></li>
</ul>

<h1 id="指令">指令</h1>

<h2 id="ssh远程连接取环境变量">ssh远程连接取环境变量</h2>

<p>ssh ip 后跟一条指令，会将其在远程服务器上的执行结果显示回本地，如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">&gt; ssh 10.11.22.33 date
&gt; 2018年11月27日 星期二 16时38分24秒 CST</code></pre></td></tr></table>
</div>
</div>
<p>那么指令是取环境变量，那么会怎么样呢？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">&gt; ssh 10.11.22.33 &#39;echo $GOPATH&#39;
&gt;</code></pre></td></tr></table>
</div>
</div>
<p>显示为空，因为这种方式是 non-login non-interactive shell，只会读取用户目录下的 .bashrc文件，而在用户的.bashrc里，有这么一段内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># If not running interactively, don&#39;t do anything
 case $- in
     *i*) ;;
       *) return;;
 esac</code></pre></td></tr></table>
</div>
</div>
<p>通过注释，我们可以理解，这段的意思是，如果不是交互式shell运行，就会直接返回，不会加载其下的环境变量设置。
处理方式可以为，在这段代码的上面进行变量的声明。</p>

<h2 id="ssh穿越跳板机登录远程服务器">ssh穿越跳板机登录远程服务器</h2>

<p>编辑 ~/.ssh/config</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Host jp-*
	User root
	IdentityFile ~/.ssh/id_rsa
	ForwardAgent yes
	ProxyCommand ssh root@vgmdj.cn -W $(echo %h|awk -F &#39;jp-&#39; &#39;{print $2}&#39;):%p 2&gt; /dev/null</code></pre></td></tr></table>
</div>
</div>
<p>这里的意思是，对于jp-xxxxx，即目标机为xxxxx，使用跳板机 root@vgmdj.cn ，
连接xxxxx时，使用</p>

<ul>
<li>User 指定用户</li>
<li>IdentityFile 证书</li>
<li>ForwardAgent 启用agent转发</li>
<li>Port 指定连接的ssh端口</li>
<li>ProxyCommand 代理连接

<ul>
<li>%h 即Host的内容，这里改为 <code>$(echo %h|awk -F 'jp-' '{print $2}')</code>
即用awk将Host切分，只使用jp-后面的内容作为连接的地址</li>
</ul></li>
</ul>

<h2 id="scp-rsync">scp/rsync</h2>

<p>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。scp在夸机器复制的时候为了提高数据的安全性，使用了ssh连接和加密方式，如果机器之间配置了ssh免密码登录，那在使用scp的时候密码都不用输入。</p>

<p>一般而言，我们会选择使用rsync进行远程同步或拷贝。rsync和scp的区别在于：</p>

<p>rsync只对差异文件做更新，可以做增量或全量备份；而scp只能做全量备份。简单说就是rsync只传修改了的部分，如果改动较小就不需要全部重传，所以rsync备份速度较快；默认情况下，rsync通过比较文件的最后修改时间（mtime）和文件的大小（size）来确认哪些文件需要被同步过去。
rsync是分块校验+传输，scp是整个文件传输。rsync比scp有优势的地方在于单个大文件的一小部分存在改动时，只需传输改动部分，无需重新传输整个文件。如果传输一个新的文件，理论上rsync没有优势；
rsync不是加密传输，而scp是加密传输，使用时可以按需选择。</p>

<h2 id="rsync常用参数">rsync常用参数</h2>

<ul>
<li>-a 归档模式，表示以递归方式传输文件，并保持所有文件属性，相当于 -rlptgoD</li>
<li>-z 在传输过程中进行压缩</li>
<li>-v 详细信息输出</li>
<li>-b 创建备份,也就是对于目的已经存在有同样的文件名时,将老的文件重新命名为~filename.可以使用&ndash;suffix选项来指定不同的备份文件前缀</li>
<li>&ndash;backup-dir=DIR 将备份文件(如~filename)存放在指定目录下</li>
<li>&ndash;suffix=SUFFIX 定义备份文件前缀,默认是~</li>
<li>-u 仅仅进行更新,也就是跳过所有已经存在文件，只新增不存在的文件</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/linux/" term="linux" label="linux" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/linux/" term="linux" label="linux" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%91%BD%E4%BB%A4/" term="命令" label="命令" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E9%83%A8%E7%BD%B2/" term="部署" label="部署" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">go语言学习-docker编译</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-docker%E7%BC%96%E8%AF%91/" />
            <id>https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-docker%E7%BC%96%E8%AF%91/</id>
            <updated>2018-11-23T12:21:58+00:00</updated>
            <published>2018-11-23T11:49:12+08:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[前言 GO本身是支持交叉编译的，且很方便，只需设置几个环境变量即可，但是对于使用了CGO的代码来说，交叉编译就不可行了，替代方案就是使用docker来完成编译。
交叉编译 Go本身支持交叉编译，只需设置三个参数即可
 CGO_ENABLED 是否启用CGO GOOS 目标运行环境操作系统 GOARCH 目标运行环境]]></summary>
            
                <content type="html"><![CDATA[<h1 id="前言">前言</h1>

<p>GO本身是支持交叉编译的，且很方便，只需设置几个环境变量即可，但是对于使用了CGO的代码来说，交叉编译就不可行了，替代方案就是使用docker来完成编译。</p>

<h1 id="交叉编译">交叉编译</h1>

<p>Go本身支持交叉编译，只需设置三个参数即可</p>

<ul>
<li>CGO_ENABLED   是否启用CGO</li>
<li>GOOS          目标运行环境操作系统</li>
<li>GOARCH        目标运行环境</li>
</ul>

<h2 id="cgo-enabled">CGO_ENABLED</h2>

<p>如果使用了CGO是不支持交叉编译的，所以统一设置为0</p>

<h2 id="goos">GOOS</h2>

<p>GOOS 对应的系统参数是：</p>

<ul>
<li>darwin 对应Mac系统</li>
<li>linux  对应linux系统</li>
<li>windows 对应windows系统</li>
</ul>

<h2 id="goarch">GOARCH</h2>

<ul>
<li>386</li>
<li>amd64</li>
<li>arm
和自己的平台相关，一般使用386编译32位运行程序，amd64编译64位运行程序</li>
</ul>

<h2 id="举例">举例</h2>

<p>mac平台下，编译linux运行程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">export CGO_ENABLED=0
export GOOS=linux
export GOARCH=amd64</code></pre></td></tr></table>
</div>
</div>
<p>windows平台下，编译linux运行程序</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">SET CGO_ENABLED=0
SET GOOS=linux
SET GOARCH=amd64</code></pre></td></tr></table>
</div>
</div>
<h1 id="docker-编译">docker编译</h1>

<p>对于CGO是无法使用交叉编译的，那么此时最好的替代方案，基本就是使用docker来编译了。
原理上讲，就是使用对应平台的golang镜像，然后将代码和GOPATH都映射到容器里，最终在容器内编译。
分享一下自己的执行脚本 dgo</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="nv">dir</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>
<span class="nv">array</span><span class="o">=</span><span class="o">(</span><span class="si">${</span><span class="nv">dir</span><span class="p">//// </span><span class="si">}</span><span class="o">)</span>
<span class="nv">num</span><span class="o">=</span><span class="si">${#</span><span class="nv">array</span><span class="p">[@]</span><span class="si">}</span>
<span class="nv">project</span><span class="o">=</span><span class="si">${</span><span class="nv">array</span><span class="p">[</span><span class="nv">$num</span><span class="p">-1]</span><span class="si">}</span>

<span class="nb">echo</span> prepare to go install in <span class="nv">$dir</span>/src/<span class="nv">$1</span>

<span class="k">if</span> <span class="o">[</span> ! -d <span class="nv">$GOBASHPATH</span> <span class="o">]</span> <span class="p">;</span><span class="k">then</span>
    sudo docker run -it --rm -v <span class="nv">$dir</span>:/golang golang <span class="se">\
</span><span class="se"></span>    sh -c <span class="s2">&#34;</span><span class="s2">export GOPATH=/golang &amp;&amp; cd /golang/src/</span><span class="nv">$1</span><span class="s2"> &amp;&amp; go install</span><span class="s2">&#34;</span>
    <span class="nb">exit</span>
<span class="k">fi</span>

sudo docker run -it --rm -v <span class="nv">$dir</span>:/golang -v <span class="nv">$GOBASHPATH</span>:/gobashpath golang <span class="se">\
</span><span class="se"></span>sh -c <span class="s2">&#34;</span><span class="s2">export GOPATH=/golang:/gobashpath &amp;&amp; cd /golang/src/</span><span class="nv">$1</span><span class="s2"> &amp;&amp; go install</span><span class="s2">&#34;</span></code></pre></td></tr></table>
</div>
</div>
<p>如果是多个GOPATH，那么项目目录外的，就设置为GOBASHPATH，然后在项目目录下，运行脚本，之后进入bin目录下，就可以找到可执行文件。</p>

<h2 id="举例-1">举例</h2>

<p>项目目录：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">/vgmdj/test
  - bin
  - pkg
  - src
    - controller
    - model
    - test
      - main.go

/vgmdj/goextra
  - github.com
    - vgmdj
      - utils</code></pre></td></tr></table>
</div>
</div>
<p>如果controller里用到了 github.com/vgmdj/utils 包，那么就需要先设置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">GOBASHPATH=/vgmdj/goextra</code></pre></td></tr></table>
</div>
</div>
<p>然后在/vgmdj/test下执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">dgo test</code></pre></td></tr></table>
</div>
</div>
<h2 id="例2-无需gobashpath">例2-无需GOBASHPATH</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">/vgmdj/go
  - src
    - github.com
      - vgmdj
        - test
          - main.go</code></pre></td></tr></table>
</div>
</div>
<p>只需在/vgmdj/go下执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">dgo github.com/vgmdj/test</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/golang/" term="Golang" label="Golang" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/golang/" term="Golang" label="Golang" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">算法学习-二叉树遍历</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/" />
            <id>https://blog.vgmdj.cn/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/</id>
            <updated>2018-10-03T15:23:50+00:00</updated>
            <published>2018-10-02T15:23:50+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[二叉树 回顾整理二叉树遍历相关内容。 对于二叉树而言，其遍历有两种方式，一种是深度优先，即先优先向下进行遍历，一种是广度优先，逐层向下遍历。
源码地址 实现语言为 Golang <a href="https://github.com/vgmdj/go_practice/tree/master/algorithm/tree_traversal" target="_blank">https://github.com/vgmdj/go_practice/tree/master/algorithm/tree_traversal</a>]]></summary>
            
                <content type="html"><![CDATA[<h1 id="二叉树">二叉树</h1>

<p>回顾整理二叉树遍历相关内容。
对于二叉树而言，其遍历有两种方式，一种是深度优先，即先优先向下进行遍历，一种是广度优先，逐层向下遍历。</p>

<h1 id="源码地址">源码地址</h1>

<p>实现语言为 Golang
<a href="https://github.com/vgmdj/go_practice/tree/master/algorithm/tree_traversal" target="_blank">https://github.com/vgmdj/go_practice/tree/master/algorithm/tree_traversal</a></p>

<h1 id="二叉树结构">二叉树结构</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">type Tree struct {
	Val   int
	Left  *Tree
	Right *Tree
}</code></pre></td></tr></table>
</div>
</div>
<h1 id="深度优先搜索">深度优先搜索</h1>

<p>Deepth-First-Search DFS， 对于深度优先而言，又有三种方式，即前序，中序和后序。前中后序之间的前中后，指的是根结点的位置。</p>

<h2 id="前序递归">前序递归</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func PreOrder(root *Tree) []int {
var result []int
if root == nil {
  return result
}

result = append(result, root.Val)
result = append(result, PreOrder(root.Left)...)
result = append(result, PreOrder(root.Right)...)

return result

}</code></pre></td></tr></table>
</div>
</div>
<h2 id="前序非递归">前序非递归</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func PreOrderNonRecursive(root *Tree) []int {
	var result []int
	if root == nil {
		return result
	}

	stack := list.New()
	p := root

	for p != nil || stack.Len() != 0 {
		for p != nil {
			result = append(result, p.Val)
			stack.PushBack(p)
			p = p.Left
		}

		if stack.Len() != 0 {
			node := stack.Back()
			stack.Remove(node)

			p = node.Value.(*Tree).Right
		}
	}

	return result
}</code></pre></td></tr></table>
</div>
</div>
<h2 id="中序递归">中序递归</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func InOrder(root *Tree) []int {
	var result []int
	if root == nil {
		return nil
	}

	result = append(result, PreOrder(root.Left)...)
	result = append(result, root.Val)
	result = append(result, PreOrder(root.Right)...)

	return result

}</code></pre></td></tr></table>
</div>
</div>
<h2 id="中序非递归">中序非递归</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func InOrderNonRecursive(root *Tree) []int {
	var result []int
	if root == nil {
		return result
	}

	stack := list.New()
	p := root

	for p != nil || stack.Len() != 0 {
		for p != nil {
			stack.PushBack(p)
			p = p.Left

		}

		if stack.Len()  != 0 {
			node := stack.Back()
			stack.Remove(node)

			result = append(result, node.Value.(*Tree).Val)

			p = node.Value.(*Tree).Right

		}

	}

	return result
}</code></pre></td></tr></table>
</div>
</div>
<h2 id="后序递归">后序递归</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func PostOrder(root *Tree) []int {
	var result []int
	if root == nil {
		return nil
	}

	result = append(result, PreOrder(root.Left)...)
	result = append(result, PreOrder(root.Right)...)
	result = append(result, root.Val)

	return result

}</code></pre></td></tr></table>
</div>
</div>
<h2 id="后序非递归">后序非递归</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func PostOrderNonRecursive(root *Tree) []int {
	var result []int
	if root == nil {
		return result
	}

	stack := list.New()
	p := root
	lastVisit := new(Tree)

	for p != nil || stack.Len() != 0 {
		for p != nil {
			stack.PushBack(p)
			p = p.Left

		}

		if stack.Len() != 0 {
			node := stack.Back()
			if node.Value.(*Tree).Right != nil &amp;&amp; lastVisit != node.Value.(*Tree).Right {
				p = node.Value.(*Tree).Right
				continue
			}

			result = append(result, node.Value.(*Tree).Val)
			stack.Remove(node)
			lastVisit = node.Value.(*Tree)

		}

	}

	return result
}</code></pre></td></tr></table>
</div>
</div>
<h1 id="广度优先搜索-层次遍历">广度优先搜索（层次遍历）</h1>

<p>Breadth-First-Search BFS 或者说是 Level Traversal，对于广度优先而言，其基于队列的数据结构，可以很简单的实现出来</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func LevelTraversal(root *Tree) []int {
	var result []int
	if root == nil {
		return result
	}

	queue := list.New()
	queue.PushBack(root)

	for queue.Len() != 0 {
		node := queue.Front()
		nTree := node.Value.(*Tree)
		queue.Remove(node)
		if nTree == nil {
			continue
		}

		result = append(result, nTree.Val)
		queue.PushBack(nTree.Left)
		queue.PushBack(nTree.Right)

	}

	return result

}</code></pre></td></tr></table>
</div>
</div>
<p>需要注意在for循环里，不能直接用 node.Value.(*Tree) == nil 来判断，因为interface特性，会认为其不为 nil，哪怕nTree为nil。
详细内容，可以参考 <a href="/post/go语言学习-interface">go interface机制</a>，这里侧重算法，不再细讲。</p>

<h1 id="总结">总结</h1>

<ul>
<li>二叉树遍历分为两种，一种是深度优先，一种是广度优先</li>
<li>深度优先分为前，中，后序三种实现方式</li>
<li>深度优先可以使用递归和非递归两种方式实现</li>
<li>深度优先主要借助栈来实现</li>
<li>广度优先主要借助队列来实现</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E7%AE%97%E6%B3%95/" term="算法" label="算法" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E7%AE%97%E6%B3%95/" term="算法" label="算法" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">设计模式学习-代理模式</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
            <updated>2018-09-24T20:30:01+00:00</updated>
            <published>2018-09-24T16:29:48+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[代理模式(Proxy) 代理模式，为其他对象提供一种代理以控制对这个对象的访问。
主要类  subjuct - interface 主体接口 concreteSubject - 具体实现的主体 proxy - 实现主体的代理]]></summary>
            
                <content type="html"><![CDATA[<h2 id="代理模式-proxy">代理模式(Proxy)</h2>

<p>代理模式，为其他对象提供一种代理以控制对这个对象的访问。</p>

<h2 id="主要类">主要类</h2>

<ul>
<li>subjuct - interface 主体接口</li>
<li>concreteSubject - 具体实现的主体</li>
<li>proxy - 实现主体的代理</li>
</ul>

<h2 id="资料推荐">资料推荐</h2>

<p>书籍：《大话设计模式》，《设计模式之禅》
golang相关实现代码:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p>

<h2 id="优点">优点</h2>

<ul>
<li>职责清晰</li>
<li>高扩展性</li>
<li>智能化</li>
</ul>

<h2 id="与装饰模式对比">与装饰模式对比</h2>

<p>和装饰模式比较，同样是不改变原设计，而扩充新功能。装饰模式下，客户端来决定新功能的顺序，而代理模式则是在内部实现。</p>

<h2 id="例子">例子</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">type Subject interface {
	Request()
}

type ConcreteSubject struct {
}

func (cs *ConcreteSubject) Request() {
	fmt.Println(&#34;this is real request&#34;)
}

type Proxy struct {
	s Subject
}

func (p *Proxy) Request() {
	if p.s == nil {
		p.s = new(ConcreteSubject)
	}

	p.Before()
	p.s.Request()
	p.After()
}

func (p *Proxy) Before() {
	fmt.Println(&#34;预处理&#34;)
}

func (p *Proxy) After() {
	fmt.Println(&#34;后置处理&#34;)
}


proxy := new(Proxy)
proxy.Request()</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">设计模式学习-原型模式</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</id>
            <updated>2018-09-24T20:30:01+00:00</updated>
            <published>2018-09-24T16:29:48+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[原型模式(Prototype) 原型模式，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。 原型模式其实就是从一个对象再创建另一个可定制的对象，而且不需知道任何创建的细节。 需要注意的点是深拷贝和浅拷贝。]]></summary>
            
                <content type="html"><![CDATA[<h2 id="原型模式-prototype">原型模式(Prototype)</h2>

<p>原型模式，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
原型模式其实就是从一个对象再创建另一个可定制的对象，而且不需知道任何创建的细节。
需要注意的点是深拷贝和浅拷贝。</p>

<h2 id="资料推荐">资料推荐</h2>

<p>书籍：《大话设计模式》，《设计模式之禅》
golang相关实现代码:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p>

<h2 id="优点">优点</h2>

<ul>
<li>可以隐藏对象创建的细节</li>
<li>可以大大的提升性能</li>
</ul>

<h2 id="适用场景">适用场景</h2>

<ul>
<li>初始化信息基本不发生变化</li>
<li>需要根据一个类在运行时的状态动态的创建新的对象</li>
</ul>

<h2 id="例子">例子</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">type Resume struct {
	name      string
	sex       string
	age       int
	education map[string]string
	work      []WorkExperience
}

type WorkExperience struct {
	TimeStart string
	TimeEnd   string
	Company   string
}

func NewResume(name, sex string, age int) *Resume {
	return &amp;Resume{
		name:      name,
		sex:       sex,
		age:       age,
		education: make(map[string]string),
		work:      make([]WorkExperience, 0, 3),
	}
}

func (r *Resume) SetEducation(schoolName, schoolAddr string) {
	r.education[&#34;SchoolName&#34;] = schoolName
	r.education[&#34;SchoolAddr&#34;] = schoolAddr
}

func (r *Resume) AddWorkExperience(company, start, end string) {
	r.work = append(r.work, WorkExperience{
		TimeStart: start,
		TimeEnd:   end,
		Company:   company,
	})

}

func (r *Resume) Clone() *Resume {
	clone := *r

	clone.work = make([]WorkExperience, len(r.work))
	copy(clone.work, r.work)

	clone.education = make(map[string]string, len(r.education))
	for k, v := range r.education {
		clone.education[k] = v
	}

	return &amp;clone

}

resume := NewResume(&#34;test&#34;, &#34;man&#34;, 18)
resume.SetEducation(&#34;哈工大&#34;, &#34;哈尔滨&#34;)
resume.AddWorkExperience(&#34;华为&#34;, &#34;2016年&#34;, &#34;2017年&#34;)

resume2 := resume.Clone()
resume2.SetEducation(&#34;清华&#34;, &#34;北京&#34;)
resume2.AddWorkExperience(&#34;阿里&#34;, &#34;2017年&#34;, &#34;2018年&#34;)

//out:
//resumt:{test man 18 map[SchoolAddr:哈尔滨 SchoolName:哈工大] [{2016年 2017年 华为}]}
//resume2:{test man 18 map[SchoolAddr:北京 SchoolName:清华] [{2016年 2017年 华为} {2017年 2018年 阿里}]}</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Hugo博客建立</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/hugo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%8B/" />
            <id>https://blog.vgmdj.cn/posts/hugo%E5%8D%9A%E5%AE%A2%E5%BB%BA%E7%AB%8B/</id>
            <updated>2018-11-27T16:47:34+00:00</updated>
            <published>2018-09-12T11:10:51+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[简述 随着文章数量的增长，hexo的生成速度也越来越慢，最终还是决定转入golang编写的静态博客框架hugo，从体验上来讲，功能基本都一致，各种主题风格也都可以找到自己满意的，生成速度天差地远，go在这块还是比较6的。
hugo安装  mac下
1  brew install hugo   其他系统下 可以从github的release页面进行下载安装， <a href="https://github.com/gohugoio/hugo/releases" target="_blank">https://github.com/gohugoio/hugo/releases</a>
  hugo剩余环境建立 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27  新建博客文件夹 hugo new site blog 进入文件夹 cd blog 新建文章并修改 hugo new post/第一篇文章.]]></summary>
            
                <content type="html"><![CDATA[

<h1 id="简述">简述</h1>

<p>随着文章数量的增长，hexo的生成速度也越来越慢，最终还是决定转入golang编写的静态博客框架hugo，从体验上来讲，功能基本都一致，各种主题风格也都可以找到自己满意的，生成速度天差地远，go在这块还是比较6的。</p>

<h1 id="hugo安装">hugo安装</h1>

<ul>
<li><p>mac下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">brew install hugo</code></pre></td></tr></table>
</div>
</div></li>

<li><p>其他系统下
可以从github的release页面进行下载安装， <a href="https://github.com/gohugoio/hugo/releases" target="_blank">https://github.com/gohugoio/hugo/releases</a></p></li>
</ul>

<h1 id="hugo剩余环境建立">hugo剩余环境建立</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">新建博客文件夹
hugo new site blog

进入文件夹
cd blog

新建文章并修改
hugo new post/第一篇文章.md

下载主题
git clone https://github.com/vjeantet/hugo-theme-casper theme/casper

配置信息
cp theme/xxx/config.toml ./

修改配置文件
根据注释内容可以很好的进行修改

本地测试
hugo server       //启动后，可在1313端口预览访问

生成静态页面
hugo

发布部署，就是将public下的内容用于展示
可以将public下内容全部传到 github page仓库，再利用webhook进行更新服务器中的内容
也可以直接利用github的page</code></pre></td></tr></table>
</div>
</div>
<h1 id="hugo部署脚本">hugo部署脚本</h1>

<p>hugo没找到自动部署的方式，就自己写了一个，反正也不难
需要放在和config.toml同一级目录，即public上一级目录下，写完博客后，直接执行即可</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash"><span class="cp">#!/bin/bash
</span><span class="cp"></span><span class="c1"># 判断public文件夹是否存在</span>
<span class="nv">hugoPath</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>
<span class="nv">publicPath</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span><span class="s2">&#34;/public&#34;</span>
<span class="k">if</span> <span class="o">[</span> ! -d <span class="nv">$publicPath</span> <span class="o">]</span><span class="p">;</span><span class="k">then</span>
  <span class="nb">echo</span> public not exist
  <span class="nb">exit</span>
<span class="k">fi</span>

<span class="c1"># 进入public文件夹，并清空之前生成文件</span>
<span class="nb">cd</span> <span class="nv">$publicPath</span>
rm -r ./*

<span class="c1"># 回到根目录，并生成新的静态文件</span>
<span class="nb">cd</span> <span class="nv">$hugoPath</span>
hugo

<span class="c1"># 回到public，并进行提交</span>
<span class="nb">cd</span> <span class="nv">$publicPath</span>

<span class="c1">#添加所有修改</span>
git add -A .

<span class="c1"># 设置提交说明，格式为 Site updated: 2006-01-02 15:04:05</span>
<span class="nv">time</span><span class="o">=</span><span class="k">$(</span>date <span class="s2">&#34;+%Y-%m-%d %H:%M:%S&#34;</span><span class="k">)</span>
<span class="nv">commit</span><span class="o">=</span><span class="s2">&#34;Site updated:&#34;</span><span class="nv">$time</span>
<span class="nb">echo</span> <span class="nv">$commit</span>

<span class="c1">#提交</span>
git commit -m <span class="s2">&#34;</span><span class="nv">$commit</span><span class="s2">&#34;</span>

<span class="c1">#推送到master分支上</span>
git push origin master</code></pre></td></tr></table>
</div>
</div>
<p>创建完脚本以后，不要忘了加权限</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">chmod 777 xxx
xxx是脚本名，加不成功，用sudo以管理员身份来加权限</code></pre></td></tr></table>
</div>
</div>
<h1 id="hugo-makefile-自动部署">hugo makefile 自动部署</h1>

<p>需要注意的是make需要在3.81以上，一些系统自带的make需要升级一下</p>

<p>在pulic下建立好博客git仓库，在根目录下建立好博客源文件仓库后，可以再建立如下 makefile 来自动部署。</p>

<ul>
<li>make build 生成public下博文</li>
<li>make run 在生成博文并在 localhost:1313 下建立预览</li>
<li>make deploy 生成并自动部署到博客仓库</li>

<li><p>make src-deploy 提交本地修改到源文件仓库</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">time := `date &#39;+%Y-%m-%d %H:%M:%S&#39;`
commit := Site updated:$(time)

build : clean
	hugo

clean:
	@rm -rf public/*

commit : build
	@cd public
	@echo &#34;deploy blog file ,&#34;$(commit)
	@git add -A .
	@git commit -m &#34;$(commit)&#34;

push : commit
	@cd public
	@git push origin master

deploy: push
	@echo &#34;Deploy Success!&#34;

src-deploy:
	@echo &#34;deploy source file ,&#34;$(commit)
	@git add -A .
	@git commit -m &#34;$(commit)&#34;
	@git push origin master

run : clean
	hugo server


.PHONY:clean build commit push deploy source-deploy run
.ONESHELL:commit push</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h1 id="hexo-文章转入-hugo">hexo 文章转入 hugo</h1>

<p>hugo基本上兼容hexo的格式，只有很少一部分地方有些差异</p>

<ul>
<li><p>最近更改时间
hexo下用updated表示，hugo用lastmod表示</p></li>

<li><p>categories
hexo下可以 key:value形式表示，hugo下默认其为多个，所以要用 key:[value1,value2]表示，当然，也可以只写一个，但是[]必须要加</p></li>

<li><p>hugo 是content/post下放文章，static下放静态文件</p></li>

<li><p>hexo文章的链接是time+title+.html， hugo是 /post/title ,所以之前用hexo放到搜索引擎里的链接需要提交一下死链，不然会降低网站评分</p></li>

<li><p>图片的链接和hexo类似，只不过把图片文件夹放到static下，再把链接里的时间删除即可</p></li>

<li><p>分类名称，hexo使用原名称，hugo会使用转成小写的名称，设置 preserveTaxonomyNames = true 来保持原大小写</p></li>

<li><p>url转小写问题，使用 disablePathToLower = true 可以保持url链接的大小写</p></li>
</ul>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E7%AB%99%E7%82%B9%E5%BB%BA%E8%AE%BE/" term="站点建设" label="站点建设" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/github/" term="github" label="github" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/blog/" term="blog" label="blog" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/hugo/" term="hugo" label="hugo" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">go语言学习-module机制</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-module%E6%9C%BA%E5%88%B6/" />
            <id>https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-module%E6%9C%BA%E5%88%B6/</id>
            <updated>2018-08-28T11:23:58+00:00</updated>
            <published>2018-08-28T10:23:01+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[Module机制 Go Module是Go1.11正式推出的包管理机制，不同于以往基于GOPATH和Vendor的项目构建，其主要是通过$GOPATH/pkg/mod下的缓存包来对项目进行构建。 一如所有的Go新添加功能，Go Module可以通过GO111MODULE来控制是否启用，GO111MODULE有三种类型
 on 所有的构建，都使用Module机制 off 所有的构建，都不使用Module机制，而是使用GOPATH和Vendor auto 在GOPATH下的项目，不使用Module机制，不在GOPATH下的项目使用]]></summary>
            
                <content type="html"><![CDATA[<h1 id="module机制">Module机制</h1>

<p>Go Module是Go1.11正式推出的包管理机制，不同于以往基于GOPATH和Vendor的项目构建，其主要是通过$GOPATH/pkg/mod下的缓存包来对项目进行构建。
一如所有的Go新添加功能，Go Module可以通过GO111MODULE来控制是否启用，GO111MODULE有三种类型</p>

<ul>
<li>on 所有的构建，都使用Module机制</li>
<li>off 所有的构建，都不使用Module机制，而是使用GOPATH和Vendor</li>
<li>auto 在GOPATH下的项目，不使用Module机制，不在GOPATH下的项目使用</li>
</ul>

<h1 id="基本命令">基本命令</h1>

<ul>
<li><p>init 初始化module，名称要和路径相一致，即如果要对 github.com/vgmdj/utils 初始化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">go mod init github.com/vgmdj/utils</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<p>这样，别人如果引用了utils包，在构建时，就会找包里的go.mod，然后分析依赖进行缓存</p>

<ul>
<li>tidy 对当前引用的再一次整理，添加缺失，去掉多余</li>
<li>vendor 生成vendor目录，但是在module机制下，不会被使用</li>
<li>edit 对go.mod进行编辑，如果熟悉格式的话，也可以直接改文件</li>
</ul>

<h1 id="和dep区别">和dep区别</h1>

<ul>
<li>dep是解析所有的包引用，然后在$GOPATH/pkg/dep下进行缓存，再在项目下生成vendor，然后基于vendor来构建项目，无法脱离GOPATH，因为vendor必须在GOPATH下才能使用</li>
<li>mod是解析所有的包引用，然后在$GOPATH/pkg/mod下进行缓存，直接基于缓存包来构建项目，所以可以脱离GOPATH</li>
</ul>

<h1 id="适合场景">适合场景</h1>

<p>所有引用包都使用git服务器来托管，且不会出现大量本地包</p>

<h1 id="本地包引用问题">本地包引用问题</h1>

<p>对于本地包引用，推荐还是使用vendor的方式，一方面不会有版本错乱的问题，另一方面很多被墙包不容易被下载下来，如果映射到本地引用，那go.mod就不是那么纯净了
当然，如果是类似golang.org这种在github上备份的，使用replace反而是最好的解决方案</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">replace golang.org/x/sys =&gt; github.com/golang/sys</code></pre></td></tr></table>
</div>
</div>
<p><strong>replace</strong> 指令的使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  go mod edit -replace=old[@v]=new[@v]
  go mod edit -dropreplace=old[@v]

  举例：
  go mod edit -replace=github.com/vgmdj/utils=/home/vgmdj/utils
  go mod edit -replace=github.com/vgmdj/utils@master=/home/vgmdj/utils</code></pre></td></tr></table>
</div>
</div>
<p>如果old里的@v缺省的话，那就代表所有版本，如果new里的@v缺省的话，就表示使用的是本地引用，应该使用本地绝对路径来表示</p>

<p>如果想直接改go.mod的话，格式类似以下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">replace github.com/vgmdj/utils =&gt; /home/vgmdj/utils
replace github.com/vgmdj/utils master =&gt; /home/vgmdj/utils</code></pre></td></tr></table>
</div>
</div>
<h1 id="私有仓库引用问题">私有仓库引用问题</h1>

<p>对于私有包的引用，会出现如下错误</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Fetching https://gitee.com/xxx/gomodtest?go-get=1
Parsing meta tags from https://gitee.com/xxx/gomodtest?go-get=1 (status code 403)
Fetching https://gitee.com/xxx?go-get=1
Parsing meta tags from https://gitee.com/xxx?go-get=1 (status code 403)
Fetching https://gitee.com?go-get=1
Parsing meta tags from https://gitee.com?go-get=1 (status code 200)
build test: cannot find module for path gitee.com/banyan_tree_in_beijing/gomodtest</code></pre></td></tr></table>
</div>
</div>
<p>观察log可以发现，是使用https时，仓库不能正确的回应造成的
所以我们应该添加部署key，并更改git拉取的方式，即将https改为ssh方式来获取代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">git config --global url.&#34;git@gitee.com:“.insteadOf &#34;https://gitee.com/&#34;</code></pre></td></tr></table>
</div>
</div>
<p>重试，发现问题依旧，使用go get -v -u gitee.com/xxx/gomodtest ，问题相同
查资料发现，对于这种情况，推荐解决方式是在最后加 <strong>.git</strong> ，使用go get xxxxx.git，成功</p>

<p>重试go build，问题依旧，手动指定go.mod中的包，即在go.mod中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">require gitee.com/xxx/gomodtest.git master</code></pre></td></tr></table>
</div>
</div>
<p>重试go build， 可正确下载，但还是会使用https获取信息，猜测是go get读取的是import中的包引用，而不是go.mod中的require</p>

<p>在代码中同时指定git， 即</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">import &#34;gitee.com/xxx/gomodtest.git&#34;</code></pre></td></tr></table>
</div>
</div>
<p>可正确下载，且正确读取信息，但是会出现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">parsing go.mod: unexpected module path &#34;gitee.com/xxx/gomodtest&#34;</code></pre></td></tr></table>
</div>
</div>
<p>修改包的module名，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">go mod edit -module gitee.com/xxx/gomodtest.git</code></pre></td></tr></table>
</div>
</div>
<p>修改失败，不知是什么问题，module 变为“”
手动修改go.mod里 第一行 module ，改为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">module gitee.com/xxx/gomodtest.git</code></pre></td></tr></table>
</div>
</div>
<p>上传代码并重试，成功编译</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/golang/" term="Golang" label="Golang" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/golang/" term="Golang" label="Golang" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">设计模式学习-建造者模式</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
            <updated>2018-08-20T20:30:01+00:00</updated>
            <published>2018-08-20T16:29:48+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[建造者模式(Builder) 建造者模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
主要类 builder - 对构建过程进行抽象的接口 director- 实际构建一个使用builder接口的对象]]></summary>
            
                <content type="html"><![CDATA[<h2 id="建造者模式-builder">建造者模式(Builder)</h2>

<p>建造者模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>

<h2 id="主要类">主要类</h2>

<p>builder - 对构建过程进行抽象的接口
director- 实际构建一个使用builder接口的对象</p>

<h2 id="资料推荐">资料推荐</h2>

<p>书籍：《大话设计模式》，《设计模式之禅》
golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p>

<h2 id="优点">优点</h2>

<p>使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了。</p>

<h2 id="适用场景">适用场景</h2>

<p>适用于将一个复杂对象的构建与它的表示进行分离，使得同样的构建过程可以创建不同的表示的场景。
即在当创建复杂对象算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。</p>

<h2 id="例子">例子</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">type Builder interface {
	BuildHead()
	BuildBody()
	BuildArms()
	BuildLegs()
}

type Director struct {
	b Builder
}

func (d *Director) SetBuilder(b Builder) {
	d.b = b
}

func (d *Director) Build() {
	d.b.BuildHead()
	d.b.BuildBody()
	d.b.BuildArms()
	d.b.BuildLegs()
}

type ThinBuilder struct {
}

func (tb *ThinBuilder) BuildHead() {

}

func (tb *ThinBuilder) BuildBody() {

}

func (tb *ThinBuilder) BuildArms() {

}

func (tb *ThinBuilder) BuildLegs() {

}


tb := new(ThinBuilder)
d := new(Director)
d.SetBuilder(tb)
d.Build()</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">设计模式学习-装饰模式</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</id>
            <updated>2018-07-26T21:02:01+00:00</updated>
            <published>2018-07-26T18:03:47+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[装饰模式(Decorator) 装饰模式，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。 装饰模式是为已有功能动态地添加更多功能的一种方式。当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为，在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度，而这些新加往后东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。 装饰模式为此提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。]]></summary>
            
                <content type="html"><![CDATA[<h2 id="装饰模式-decorator">装饰模式(Decorator)</h2>

<p>装饰模式，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。
装饰模式是为已有功能动态地添加更多功能的一种方式。当系统需要新功能的时候，是向旧的类中添加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为，在主类中加入了新的字段，新的方法和新的逻辑，从而增加了主类的复杂度，而这些新加往后东西仅仅是为了满足一些只在某种特定情况下才会执行的特殊行为的需要。
装饰模式为此提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择地、按顺序地使用装饰功能包装对象了。</p>

<h2 id="资料推荐">资料推荐</h2>

<p>书籍：《大话设计模式》，《设计模式之禅》
golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p>

<h2 id="优点">优点</h2>

<p>装饰模式可以把类中的装饰功能从类中搬移去除，这样可以简化原有的类。
同时有效地把类的核心职责和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑。</p>

<h2 id="缺点">缺点</h2>

<p>会产生许多的装饰类，从而增加系统的复杂性。
较为灵活机动的同时，也意味着比较容易出错，且出错排查需要逐级调试，比较困难烦琐。</p>

<h2 id="和建-造者模式对比">和建造者模式对比</h2>

<p>建造者模式内部构造是稳定有序的，而装饰者模式构造过程是不稳定的。</p>

<h2 id="适用场景">适用场景</h2>

<p>原来类的使用场景和处理逻辑无需改变，新需求需要原来类添加一些功能。这时，更改原来的类违反了开闭原则，且新需求只在特定情况下才会需要，所以使用装饰者模式，对其进行装饰包装，使其能适用于新的特殊场景。</p>

<h2 id="例子-log修饰">例子-log修饰</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">type ILog interface {
	Println(string)
}

type Log struct {
}

func (l *Log) Println(s string) {
	fmt.Printf(&#34;%s\n&#34;, s)
}

type Decorator struct {
	component ILog
}

func (d *Decorator) SetLog(c ILog) {
	d.component = c
}

func (d *Decorator) Println(s string) {
	if d.component != nil {
		d.component.Println(s)
	}
}

type TimeLog struct {
	Decorator
}

func (tl *TimeLog) Println(s string) {
	fmt.Printf(&#34;[time:  %s] &#34;, time.Now().Format(&#34;2006-01-02 15:04:05&#34;))
	tl.component.Println(s)

}

type PathLog struct {
	Decorator
}

func (pl *PathLog) Println(s string) {
	fmt.Printf(&#34;[path: %s] &#34;, &#34;/path&#34;)
	pl.component.Println(s)

}

l := new(Log)
tl := new(TimeLog)
pl := new(PathLog)

tl.SetLog(l)
pl.SetLog(tl)

pl.Println(&#34;this is a log test&#34;)

//输出：
//[path: /path] [time:  2018-07-26 18:40:40] this is a log test</code></pre></td></tr></table>
</div>
</div>
<h2 id="例子-大话设计模式">例子-大话设计模式</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">type IPerson interface {
	Show()
}

type Person struct {
	Name string
}

func (p *Person) Show() {
	fmt.Printf(&#34;装扮的%s\n&#34;, p.Name)
}

type Finery struct {
	component IPerson
}

func (f *Finery) Decorate(c IPerson) {
	f.component = c
}

func (f *Finery) Show() {
	if f.component != nil {
		f.component.Show()
	}
}

type TShirts struct {
	Finery
}

func (t *TShirts) Show() {
	fmt.Printf(&#34;大T恤 &#34;)
	t.Finery.Show()
}

type BigTrouser struct {
	Finery
}

func (b *BigTrouser) Show() {
	fmt.Printf(&#34;垮裤 &#34;)
	b.Finery.Show()
}


p := &amp;Person{Name: &#34;test&#34;}
ts := new(TShirts)
bt := new(BigTrouser)

ts.Decorate(p)
bt.Decorate(ts)

bt.Show()

//输出：
//垮裤 大T恤 装扮的test</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">设计模式学习-观察者模式</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</id>
            <updated>2018-07-24T16:30:50+00:00</updated>
            <published>2018-07-24T13:44:23+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[观察者模式(Observer) 将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性，我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。 观察者模式所做的工作其实就是在解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体，从而使得各自的变化都不会影响另一边的变化。
 Subject(主题) 观察者感兴趣的抽象主题，条件达成后，可对所属主题的观察者进行通知。需要提供注册、删除、通知观察者的接口
 ConcreSubject(具体主题) 用于存放各ConcreObserver对象
 Observer(观察者) 为那些在目标发生改时需获得通知的对象定义一个更新接口。当它的状态发生改变时，向它的各个观察者发出通知
 ConcreObserver(具体观察者) 维护一个指向ConcreSubject对象的引用。存储有关状态，这些状态应与目标的状态保持一致。实现Observer的更新接口以使自身的状态与目标的状态保持一致]]></summary>
            
                <content type="html"><![CDATA[<h2 id="观察者模式-observer">观察者模式(Observer)</h2>

<p>将一个系统分割成一系列相互协作的类有一个很不好的副作用，那就是需要维护相关对象间的一致性，我们不希望为了维持一致性而使各类紧密耦合，这样会给维护、扩展和重用都带来不便。
观察者模式所做的工作其实就是在解除耦合，让耦合的双方都依赖于抽象，而不是依赖于具体，从而使得各自的变化都不会影响另一边的变化。</p>

<ul>
<li><p>Subject(主题)
观察者感兴趣的抽象主题，条件达成后，可对所属主题的观察者进行通知。需要提供注册、删除、通知观察者的接口</p></li>

<li><p>ConcreSubject(具体主题)
用于存放各ConcreObserver对象</p></li>

<li><p>Observer(观察者)
为那些在目标发生改时需获得通知的对象定义一个更新接口。当它的状态发生改变时，向它的各个观察者发出通知</p></li>

<li><p>ConcreObserver(具体观察者)
维护一个指向ConcreSubject对象的引用。存储有关状态，这些状态应与目标的状态保持一致。实现Observer的更新接口以使自身的状态与目标的状态保持一致</p></li>
</ul>

<h2 id="资料推荐">资料推荐</h2>

<p>书籍：《大话设计模式》，《设计模式之禅》
golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p>

<h2 id="使用场景">使用场景</h2>

<p>当多个对象对同一个事件感兴趣，但多个对象间相互独立</p>

<h2 id="优势">优势</h2>

<p>充分解除主题和观察者类之间的耦合，实现了表现层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种不同的表示层作为具体观察者角色。</p>

<h2 id="实际应用场景">实际应用场景</h2>

<p>交易订单处理</p>

<p>事件：下单成功
主题：订单处理
具体主题：下单成功处理
观察者：通知
具体观察者：短信通知
具体观察者：邮件通知
观察者：记录
具体观察者：支付记录
具体观察者：交易记录</p>

<p>事件：交易成功
主题：订单处理
具体主题：交易成功处理
观察者：通知
具体观察者：短信通知
具体观察者：邮件通知</p>

<h2 id="例子">例子</h2>

<ul>
<li><p>类实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">observer</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">Event</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Data</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Subject</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Register</span><span class="p">(</span><span class="nx">observer</span> <span class="nx">Observer</span><span class="p">)</span>
	<span class="nf">Destroy</span><span class="p">(</span><span class="nx">observer</span> <span class="nx">Observer</span><span class="p">)</span>

	<span class="nf">Notify</span><span class="p">(</span><span class="nx">event</span> <span class="nx">Event</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Observer</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Update</span><span class="p">(</span><span class="nx">event</span> <span class="nx">Event</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ConcreteSubject</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Observers</span> <span class="kd">map</span><span class="p">[</span><span class="nx">Observer</span><span class="p">]</span><span class="kd">struct</span><span class="p">{</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cs</span> <span class="o">*</span><span class="nx">ConcreteSubject</span><span class="p">)</span> <span class="nf">Register</span><span class="p">(</span><span class="nx">observer</span> <span class="nx">Observer</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">Observers</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">{</span>
		<span class="nx">cs</span><span class="p">.</span><span class="nx">Observers</span> <span class="p">=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="nx">Observer</span><span class="p">]</span><span class="kd">struct</span><span class="p">{</span><span class="p">}</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">cs</span><span class="p">.</span><span class="nx">Observers</span><span class="p">[</span><span class="nx">observer</span><span class="p">]</span> <span class="p">=</span> <span class="kd">struct</span><span class="p">{</span><span class="p">}</span><span class="p">{</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cs</span> <span class="o">*</span><span class="nx">ConcreteSubject</span><span class="p">)</span> <span class="nf">Destroy</span><span class="p">(</span><span class="nx">observer</span> <span class="nx">Observer</span><span class="p">)</span> <span class="p">{</span>
	<span class="nb">delete</span><span class="p">(</span><span class="nx">cs</span><span class="p">.</span><span class="nx">Observers</span><span class="p">,</span> <span class="nx">observer</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">cs</span> <span class="o">*</span><span class="nx">ConcreteSubject</span><span class="p">)</span> <span class="nf">Notify</span><span class="p">(</span><span class="nx">event</span> <span class="nx">Event</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">obs</span><span class="p">,</span> <span class="nx">_</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">cs</span><span class="p">.</span><span class="nx">Observers</span> <span class="p">{</span>
		<span class="nx">obs</span><span class="p">.</span><span class="nf">Update</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">ConcreteObserver</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ID</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">co</span> <span class="o">*</span><span class="nx">ConcreteObserver</span><span class="p">)</span> <span class="nf">Update</span><span class="p">(</span><span class="nx">event</span> <span class="nx">Event</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;this is observer %s and the event is %s \n&#34;</span><span class="p">,</span> <span class="nx">co</span><span class="p">.</span><span class="nx">ID</span><span class="p">,</span> <span class="nx">event</span><span class="p">.</span><span class="nx">Data</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div></li>

<li><p>使用测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ob1 := &amp;ConcreteObserver{ID: &#34;ob1&#34;}
ob2 := &amp;ConcreteObserver{ID: &#34;ob2&#34;}

sb := ConcreteSubject{}
sb.Register(ob1)
sb.Register(ob2)

event1 := Event{Data: &#34;event1&#34;}
sb.Notify(event1)

sb.Destroy(ob1)

event2 := Event{Data: &#34;event2&#34;}
sb.Notify(event2)</code></pre></td></tr></table>
</div>
</div></li>

<li><p>结果显示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">this is observer ob1 and the event is event1
this is observer ob2 and the event is event1
this is observer ob2 and the event is event2</code></pre></td></tr></table>
</div>
</div></li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">efk学习-ElasticSearch</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/efk%E5%AD%A6%E4%B9%A0-elasticsearch/" />
            <id>https://blog.vgmdj.cn/posts/efk%E5%AD%A6%E4%B9%A0-elasticsearch/</id>
            <updated>2018-07-12T14:30:58+00:00</updated>
            <published>2018-07-12T10:24:51+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[基本操作 增删改查 增删改查是数据库的基础操作方法。ES 虽然不是数据库，但是很多场合下，都被人们当做一个文档型 NoSQL 数据库在使用，原因自然是因为在接口和分布式架构层面的相似性。虽然在 Elastic Stack 场景下，数据的写入和查询，分别由 Fluntd(Logstash) 和 Kibana 代劳，作为测试、调研和排错时的基本功，还是需要了解一下 ES 的增删改查用法的。]]></summary>
            
                <content type="html"><![CDATA[<h1 id="基本操作">基本操作</h1>

<h2 id="增删改查">增删改查</h2>

<p>增删改查是数据库的基础操作方法。ES 虽然不是数据库，但是很多场合下，都被人们当做一个文档型 NoSQL 数据库在使用，原因自然是因为在接口和分布式架构层面的相似性。虽然在 Elastic Stack 场景下，数据的写入和查询，分别由 Fluntd(Logstash) 和 Kibana 代劳，作为测试、调研和排错时的基本功，还是需要了解一下 ES 的增删改查用法的。</p>

<ul>
<li><p>insert</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">curl -X POST http://127.0.0.1:9200/curllog-2018.07.12/testlog -d &#39;{&#34;user&#34;:&#34;vgmdj&#34;,&#34;msg&#34;:&#34;this is the first message into elasticsearch&#34;}&#39;

{&#34;_index&#34;:&#34;curllog-2018.07.12&#34;,&#34;_type&#34;:&#34;testlog&#34;,&#34;_id&#34;:&#34;AWSMZIsGDVyT1z9Mhc1z&#34;,&#34;_version&#34;:1,&#34;result&#34;:&#34;created&#34;,&#34;_shards&#34;:{&#34;total&#34;:2,&#34;successful&#34;:2,&#34;failed&#34;:0},&#34;created&#34;:true}</code></pre></td></tr></table>
</div>
</div></li>

<li><p>get</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">curl http://127.0.0.1:9200/curllog-2018.07.12/testlog/AWSMZIsGDVyT1z9Mhc1z

{&#34;_index&#34;:&#34;curllog-2018.07.12&#34;,&#34;_type&#34;:&#34;testlog&#34;,&#34;_id&#34;:&#34;AWSMZIsGDVyT1z9Mhc1z&#34;,&#34;_version&#34;:1,&#34;found&#34;:true,&#34;_source&#34;:{&#34;user&#34;:&#34;vgmdj&#34;,&#34;msg&#34;:&#34;this is the first message into elasticsearch&#34;}}</code></pre></td></tr></table>
</div>
</div></li>

<li><p>get all</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">curl http://127.0.0.1:9200/curllog-2018.07.12/testlog/_search

{&#34;took&#34;:4,&#34;timed_out&#34;:false,&#34;_shards&#34;:{&#34;total&#34;:5,&#34;successful&#34;:5,&#34;skipped&#34;:0,&#34;failed&#34;:0},&#34;hits&#34;:{&#34;total&#34;:1,&#34;max_score&#34;:1.0,&#34;hits&#34;:[{&#34;_index&#34;:&#34;curllog-2018.07.12&#34;,&#34;_type&#34;:&#34;testlog&#34;,&#34;_id&#34;:&#34;AWSMZIsGDVyT1z9Mhc1z&#34;,&#34;_score&#34;:1.0,&#34;_source&#34;:{&#34;user&#34;:&#34;vgmdj&#34;,&#34;msg&#34;:&#34;this is the third message into elasticsearch&#34;}}]}}</code></pre></td></tr></table>
</div>
</div></li>

<li><p>update</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">curl -X PUT http://127.0.0.1:9200/curllog-2018.07.12/testlog/AWSMZIsGDVyT1z9Mhc1z -d &#39;{&#34;user&#34;:&#34;vgmdj&#34;,&#34;msg&#34;:&#34;this is the second message into elasticsearch&#34;}&#39;

{&#34;_index&#34;:&#34;curllog-2018.07.12&#34;,&#34;_type&#34;:&#34;testlog&#34;,&#34;_id&#34;:&#34;AWSMZIsGDVyT1z9Mhc1z&#34;,&#34;_version&#34;:2,&#34;result&#34;:&#34;updated&#34;,&#34;_shards&#34;:{&#34;total&#34;:2,&#34;successful&#34;:2,&#34;failed&#34;:0},&#34;created&#34;:false}</code></pre></td></tr></table>
</div>
</div></li>

<li><p>patch</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">curl -X POST http://127.0.0.1:9200/curllog-2018.07.12/testlog/AWSMZIsGDVyT1z9Mhc1z/_update -d &#39;{&#34;doc&#34;:{&#34;msg&#34;:&#34;this is the third message into elasticsearch&#34;}}&#39;

{&#34;_index&#34;:&#34;curllog-2018.07.12&#34;,&#34;_type&#34;:&#34;testlog&#34;,&#34;_id&#34;:&#34;AWSMZIsGDVyT1z9Mhc1z&#34;,&#34;_version&#34;:3,&#34;result&#34;:&#34;updated&#34;,&#34;_shards&#34;:{&#34;total&#34;:2,&#34;successful&#34;:2,&#34;failed&#34;:0}}</code></pre></td></tr></table>
</div>
</div></li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/database/" term="database" label="database" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/database/" term="database" label="database" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/efk/" term="efk" label="efk" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">消息队列学习-RabbitMQ健康检查</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0-rabbitmq%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/" />
            <id>https://blog.vgmdj.cn/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AD%A6%E4%B9%A0-rabbitmq%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5/</id>
            <updated>2018-06-29T16:08:58+00:00</updated>
            <published>2018-06-18T23:50:51+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[Rest API 监测 需要注意的是RabbitMQ中对外提供的Rest API接口，是Management Plugin所提供的，如果没有安装这个插件的话，则需要使用amqp的方式
 vhost 检查 用于检测vhost的运行情况，如果正常，则会收到 “ok”
1 2 3 4 5  路径： /api/aliveness-test/{:vhost} 返回： { status: "ok" }]]></summary>
            
                <content type="html"><![CDATA[<h1 id="rest-api-监测">Rest API 监测</h1>

<p>需要注意的是RabbitMQ中对外提供的Rest API接口，是Management Plugin所提供的，如果没有安装这个插件的话，则需要使用amqp的方式</p>

<ul>
<li><p>vhost 检查
用于检测vhost的运行情况，如果正常，则会收到 “ok”</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">路径： /api/aliveness-test/{:vhost}
返回：
{
  status: &#34;ok&#34;
}</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<ul>
<li><p>queue检查
用于获取队列当前信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">路径： /api/{:vhost}/{:queue}
返回： 当前队列的所有信息（包含ready, unacked , total待各种信息）</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h1 id="amqp模拟检测">AMQP模拟检测</h1>

<p>对于AMQP的queue_declare()命令，如果设置passive=True，那么RabbitMQ在收到这个参数时就会明白，此时并不是真正的想要声明一个队列，如果队列已存在的话，会返回队列消息的总数，如果队列不存在的话，则会引发异常。
对于模拟检测来讲，passive一定要设为true，因为这不仅是获取队列消息总数的唯一方法，同时也是因为，如果没有传递该参数的话，检测程序会真实地尝试去声明该队列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">返回：

Queue struct{
    Name string     //队列名称
    Messages int    //ready状态的消息数量
    Consumers int   //队列消费者的数量

}</code></pre></td></tr></table>
</div>
</div>
<h1 id="确保消费者运行状态">确保消费者运行状态</h1>

<p>对于生产者而言，如果发送失败，则说明此时有异常出现，之后就可以尝试进行修复。
对于消费者而言，如果中途网络不稳定导致连接断掉，并不能直接就检测出此时的状态。
这时有两种方式进行监测，但是一般更推荐使用AMQP，直接去获取队列的消费者。</p>

<h2 id="基于amqp模拟检测">基于AMQP模拟检测</h2>

<p>基于AMQP协议，可以使用官方提供的 QueueDeclarePassive 方法来获取队列消费者的数量，如果数量出现异常，可自行进行处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">/*
QueueDeclarePassive is functionally and parametrically equivalent to
QueueDeclare, except that it sets the &#34;passive&#34; attribute to true. A passive
queue is assumed by RabbitMQ to already exist, and attempting to connect to a
non-existent queue will cause RabbitMQ to throw an exception. This function
can be used to test for the existence of a queue.
*/

func (ch *Channel) QueueDeclarePassive(name string, durable, autoDelete, exclusive, noWait bool, args Table) (Queue, error) {
	if err := args.Validate(); err != nil {
		return Queue{}, err
	}

	req := &amp;queueDeclare{
		Queue:      name,
		Passive:    true,
		Durable:    durable,
		AutoDelete: autoDelete,
		Exclusive:  exclusive,
		NoWait:     noWait,
		Arguments:  args,
	}
	res := &amp;queueDeclareOk{}

	if err := ch.call(req, res); err != nil {
		return Queue{}, err
	}

	if req.wait() {
		return Queue{
			Name:      res.Queue,
			Messages:  int(res.MessageCount),
			Consumers: int(res.ConsumerCount),
		}, nil
	}

	return Queue{Name: name}, nil
}</code></pre></td></tr></table>
</div>
</div>
<h2 id="基于rest-api-监测">基于Rest API 监测</h2>

<p>对于消费者的推荐编写方式是，在正确的处理完消息后再进行ack，那么在处理完成之前消息处于unacked状态，如果消费者忽然挂掉，消息会重新进入队列处于ready状态。</p>

<p>所以，可以通过监测当前队列下ready和unacked消息的数量来判断，如果ready超过阈值，而unacked仍为0,说明此时消费者已经不存在了，需要重新创建一个消费者。</p>

<p>至于阈值的创建范围，则可以根据实际的需要情况来设置。</p>

<h1 id="消息队列阈值基准经验法则">消息队列阈值基准经验法则</h1>

<p>通过日志文件，我们可以获得合理而又准确的信息，再对信息进行分析，则可以确定队列的平均处理速度。
也可以通过图形监控系统来监控队列，来获取近乎精确的平均未消费和未确认消息总数。
一般认为：</p>

<ul>
<li>高于正常情况20%-90%，属于正常波动，可设为warning</li>
<li>高于正常情况100%，则肯定已经出现了差错，应设为critical</li>
</ul>

<h1 id="重连">重连</h1>

<p>重新建立连接的方式，一般有两种，一种是程序直接退出，通过监控框架或程序来重启，再进行连接
一种是在程序中重试，尝试重新连接，此时原消费者不可用，应重新注册一个新连接下的消费者</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" term="消息队列" label="消息队列" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" term="消息队列" label="消息队列" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">efk学习-简介</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/efk%E5%AD%A6%E4%B9%A0-%E7%AE%80%E4%BB%8B/" />
            <id>https://blog.vgmdj.cn/posts/efk%E5%AD%A6%E4%B9%A0-%E7%AE%80%E4%BB%8B/</id>
            <updated>2018-06-10T14:30:58+00:00</updated>
            <published>2018-06-10T10:24:51+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[前言 通常日志由服务器生成，输出到不同的文件中，一般会有系统日志、 应用日志、安全日志。这些日志分散地存储在不同的机器上。 而当系统发生故障时，工程师需要登录到各个服务器上，使用 grep / sed / awk 等 Linux 脚本工具去日志里查找故障原因。在没有日志系统的情况下，首先需要定位处理请求的服务器，如果这台服务器部署了多个实例，则需要去每个应用实例的日志目录下去找日志文件。每个应用实例还会设置日志滚动策略（如：每天生成一个文件），还有日志压缩归档策略等。 这样一系列流程下来，对于我们排查故障以及及时找到故障原因，造成了比较大的麻烦。因此，如果我们能把这些日志集中管理，并提供集中检索功能，不仅可以提高诊断的效率，同时对系统情况有个全面的理解，避免事后救火的被动。]]></summary>
            
                <content type="html"><![CDATA[<h1 id="前言">前言</h1>

<p>通常日志由服务器生成，输出到不同的文件中，一般会有系统日志、 应用日志、安全日志。这些日志分散地存储在不同的机器上。
而当系统发生故障时，工程师需要登录到各个服务器上，使用 grep / sed / awk 等 Linux 脚本工具去日志里查找故障原因。在没有日志系统的情况下，首先需要定位处理请求的服务器，如果这台服务器部署了多个实例，则需要去每个应用实例的日志目录下去找日志文件。每个应用实例还会设置日志滚动策略（如：每天生成一个文件），还有日志压缩归档策略等。
这样一系列流程下来，对于我们排查故障以及及时找到故障原因，造成了比较大的麻烦。因此，如果我们能把这些日志集中管理，并提供集中检索功能，不仅可以提高诊断的效率，同时对系统情况有个全面的理解，避免事后救火的被动。</p>

<h1 id="简介">简介</h1>

<p>efk，一个集中式日志系统，elasticsearch-fluentd-kibana三者的结合，之前的经典组合是elk,即把logstash换成了fluentd
- ElasticSearch 全文搜索引擎
- Fluentd 日志收集工具
- Kibana 数据分析展示
- logstash 日志收集工具</p>

<h1 id="elasticsearch">ElasticSearch</h1>

<blockquote>
<p>Elasticsearch 来源于作者 Shay Banon 的第一个开源项目 Compass 库，而这个 Java 库最初的目的只是为了给 Shay 当时正在学厨师的妻子做一个菜谱的搜索引擎。2010 年，Elasticsearch 正式发布。至今已经成为 GitHub 上最流行的 Java 项目，不过 Shay 承诺给妻子的菜谱搜索依然没有面世……</p>
</blockquote>

<p>提供了REST API的操作接口，可以达到开箱即用</p>

<ul>
<li><p>Index
Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是 <strong>小写</strong>。</p></li>

<li><p>Document
Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。
Document 使用 JSON 格式表示，同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</p></li>

<li><p>Type
Document下的分组，可以通过Type来筛选Document，比如天气的Document里，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天），这种分组就叫做 Type，是一种虚拟的逻辑分组。</p></li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/database/" term="database" label="database" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/database/" term="database" label="database" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/efk/" term="efk" label="efk" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">js学习-总览</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/redis%E5%AD%A6%E4%B9%A0-lru/" />
            <id>https://blog.vgmdj.cn/posts/redis%E5%AD%A6%E4%B9%A0-lru/</id>
            <updated>2018-05-21T15:27:15+00:00</updated>
            <published>2018-05-21T10:46:12+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[过期策略 在使用redis作为缓存的场景下，内存淘汰策略决定的redis的内存使用效率。在大部分场景下，我们会采用LRU(Least Recently Used)来作为redis的淘汰策略。
LRU LRU Least Recently Used，即淘汰最久未使用的策略， 一般使用hashmap+双向链表作为实现方式，]]></summary>
            
                <content type="html"><![CDATA[<h1 id="过期策略">过期策略</h1>

<p>在使用redis作为缓存的场景下，内存淘汰策略决定的redis的内存使用效率。在大部分场景下，我们会采用LRU(Least Recently Used)来作为redis的淘汰策略。</p>

<h1 id="lru">LRU</h1>

<p>LRU Least Recently Used，即淘汰最久未使用的策略，
一般使用hashmap+双向链表作为实现方式，</p>

<h2 id="实现">实现</h2>

<h3 id="对于获取情况">对于获取情况</h3>

<ul>
<li>如果不存在，直接返回规定值或错误</li>
<li>如果存在，则返回结点存储的值，并将结点的优先级提升。实现上来讲的话，可以先删除这个结点，再重新加入。</li>
</ul>

<p>这就要求能快速找到结点的位置，所以一般考虑使用 hashmap来存储结点位置。</p>

<h3 id="对于存入情况">对于存入情况</h3>

<ul>
<li>如果结点已存在，则提升结点优先级。实现上来讲，可以先删除这个结点，再重新加入</li>
<li>如果结点不存在

<ul>
<li>且容量未满，则直接加入</li>
<li>且容量已满，则先加入这个结点，再删除优先级最低的结点</li>
</ul></li>
</ul>

<p>这就需要能快速的在头和尾进行添加和删除，同时能快速的从链表中摘除结点，所以一般考虑使用双向链表来实现。</p>

<h2 id="golang实现代码">golang实现代码</h2>

<ul>
<li><a href="https://github.com/vgmdj/go_practice/tree/master/leetcode/0146.LRU_Cache" target="_blank">https://github.com/vgmdj/go_practice/tree/master/leetcode/0146.LRU_Cache</a></li>
</ul>

<h1 id="redis-淘汰策略">Redis 淘汰策略</h1>

<p>redis 的 maxmemory_policy，即内存使用到设置容量后的淘汰策略</p>

<ul>
<li>noeviction: 如果缓存数据超过了maxmemory限定值,并且客户端正在执行的命令会导致内存分配,则向客户端返回错误响应.</li>
<li>allkeys-lru: 所有的缓存数据(包括没有超时属性的和具有超时属性的)都参与LRU算法淘汰.</li>
<li>volatile-lru: 只有超时属性的缓存数据才参与LRU算法淘汰.</li>
<li>allkeys-random: 所有的缓存数据(包括没有超时属性的和具有超时属性的)都参与淘汰, 但是采用随机淘汰,而不是用LRU算法进行淘汰.</li>
<li>volatile-random: 只有超时属性的缓存数据才参与淘汰,但是采用随机淘汰,而不是用LRU算法进行淘汰.</li>
<li>volatile-ttl: 只有超时属性的缓存数据才参与淘汰. 根据缓存数据的超时TTL进行淘汰,而不是用LRU算法进行淘汰.</li>
</ul>

<p>volatile-lru, volatile-random和volatile-ttl这三个淘汰策略使用的不是全量的缓存数据,所以有可能无法淘汰出足够的内存空间.</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/database/" term="database" label="database" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/database/" term="database" label="database" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/redis/" term="redis" label="redis" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">分布式学习-分布式事务</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" />
            <id>https://blog.vgmdj.cn/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</id>
            <updated>2018-05-14T16:08:28+00:00</updated>
            <published>2018-05-14T14:38:21+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[简述 分布式系统架构中，分布式事务问题是一个绕不过去的挑战。而微服务架构的流行，让分布式事务问题日益突出！ 对于单体应用而言，所有的数据库操作都在一起，可以很简单的使用本地事务，来保证数据的ACID。 但是对于分布式系统，系统由多个独立的服务组成，那么如何解决分布式调用时候数据的一致性就成了一个问题。 具体业务场景如下，比如一个业务操作，如果同时调用服务 A、B、C，需要满足要么同时成功；要么同时失败。A、B、C 可能是多个不同部门开发、部署在不同服务器上的远程服务。]]></summary>
            
                <content type="html"><![CDATA[<h1 id="简述">简述</h1>

<p>分布式系统架构中，分布式事务问题是一个绕不过去的挑战。而微服务架构的流行，让分布式事务问题日益突出！
对于单体应用而言，所有的数据库操作都在一起，可以很简单的使用本地事务，来保证数据的ACID。
但是对于分布式系统，系统由多个独立的服务组成，那么如何解决分布式调用时候数据的一致性就成了一个问题。
具体业务场景如下，比如一个业务操作，如果同时调用服务 A、B、C，需要满足要么同时成功；要么同时失败。A、B、C 可能是多个不同部门开发、部署在不同服务器上的远程服务。</p>

<h1 id="基础概念">基础概念</h1>

<h2 id="一致性模型">一致性模型</h2>

<ul>
<li><p>强一致性
当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。但是这种实现对性能影响较大。</p></li>

<li><p>弱一致性
系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。但会尽可能保证在某个时间级别（比如秒级别）之后，可以让数据达到一致性状态。</p></li>

<li><p>最终一致性
弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS是一个典型的最终一致性系统。</p></li>
</ul>

<h2 id="cap理论">CAP理论</h2>

<blockquote>
<p>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。</p>
</blockquote>

<p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。</p>

<ul>
<li><p>Consistency 一致性
一致性指“all nodes see the same data at the same time”，即更新操作成功并返回客户端完成后，所有节点在同一时间的数据完全一致。</p></li>

<li><p>Availability 可用性
可用性指“Reads and writes always succeed”，即服务一直可用，而且是正常响应时间。</p></li>
</ul>

<p>对于一个可用性的分布式系统，每一个非故障的节点必须对每一个请求作出响应。也就是，该系统使用的任何算法必须最终终止。当同时要求分区容忍性时，这是一个很强的定义：即使是严重的网络错误，每个请求必须终止。</p>

<p>好的可用性主要是指系统能够很好的为用户服务，不出现用户操作失败或者访问超时等用户体验不好的情况。可用性通常情况下可用性和分布式数据冗余，负载均衡等有着很大的关联。</p>

<ul>
<li>Partition Tolerance分区容错性
分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或网络分区故障的时候，仍然能够对外提供满足一致性和可用性的服务。</li>
</ul>

<p>分区容错性和扩展性紧密相关。在分布式应用中，可能因为一些分布式的原因导致系统无法正常运转。好的分区容错性要求能够使应用虽然是一个分布式系统，而看上去却好像是在一个可以运转正常的整体。比如现在的分布式系统中有某一个或者几个机器宕掉了，其他剩下的机器还能够正常运转满足系统需求，或者是机器之间有网络异常，将分布式系统分隔未独立的几个部分，各个部分还能维持分布式系统的运作，这样就具有好的分区容错性。</p>

<h2 id="base理论">BASE理论</h2>

<blockquote>
<p>eBay的架构师Dan Pritchett源于对大规模分布式系统的实践总结，在ACM上发表文章提出BASE理论，BASE理论是对CAP理论的延伸，核心思想是即使无法做到强一致性（Strong Consistency，CAP的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性（Eventual Consitency）。
BASE是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency）。</p>
</blockquote>

<ul>
<li><p>基本可用（Basically Available）
基本可用是指分布式系统在出现故障的时候，允许损失部分可用性，即保证核心可用。
电商大促时，为了应对访问量激增，部分用户可能会被引导到降级页面，服务层也可能只提供降级服务。这就是损失部分可用性的体现。</p></li>

<li><p>软状态（ Soft State）
软状态是指允许系统存在中间状态，而该中间状态不会影响系统整体可用性。分布式存储中一般一份数据至少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication的异步复制也是一种体现。</p></li>

<li><p>最终一致性（ Eventual Consistency）
最终一致性是指系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p></li>
</ul>

<p>ACID是传统数据库常用的设计理念，追求强一致性模型。BASE支持的是大型分布式系统，提出通过牺牲强一致性获得高可用性。
ACID和BASE代表了两种截然相反的设计哲学
在分布式系统设计的场景中，系统组件对一致性要求是不同的，因此ACID和BASE又会结合使用。</p>

<h2 id="分布式事务">分布式事务</h2>

<blockquote>
<p>分布式事务是指会涉及到操作多个数据库的事务。其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。分布式事务处理的关键是必须有一种方法可以知道事务在任何地方所做的所有动作，提交或回滚事务的决定必须产生统一的结果（全部提交或全部回滚）</p>
</blockquote>

<p>在分布式系统中，各个节点之间在物理上相互独立，通过网络进行沟通和协调。由于存在事务机制，可以保证每个独立节点上的数据操作可以满足ACID。但是，相互独立的节点之间无法准确的知道其他节点中的事务执行情况。所以从理论上讲，两台机器理论上无法达到一致的状态。如果想让分布式部署的多台机器中的数据保持一致性，那么就要保证在所有节点的数据写操作，要不全部都执行，要么全部的都不执行。但是，一台机器在执行本地事务的时候无法知道其他机器中的本地事务的执行结果。所以他也就不知道本次事务到底应该commit还是 roolback。所以，常规的解决办法就是引入一个“协调者”的组件来统一调度所有分布式节点的执行。</p>

<h2 id="二阶提交协议-two-phase-commitment-protocol">二阶提交协议（Two Phase Commitment Protocol）</h2>

<h2 id="三阶提交协议-three-phase-commitment-protocol">三阶提交协议（Three Phase Commitment Protocol）</h2>

<h2 id="paxos算法">Paxos算法</h2>

<h2 id="raft算法">Raft算法</h2>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" term="分布式系统" label="分布式系统" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" term="分布式系统" label="分布式系统" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">微服务学习-总览</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/" />
            <id>https://blog.vgmdj.cn/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/</id>
            <updated>2018-05-11T21:08:58+00:00</updated>
            <published>2018-05-11T14:31:31+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[简述 使用基于微服务的方式使得应用程序开发变得更快更容易管理，它只需要较少的人力就能实现更多的功能，可以更快更容易地部署。把应用程序设计成一套微服务，更加容易在多台具有负载均衡的服务器上运行，使其能够轻松应对需求高峰、由于时间推移而平稳增长的需求和由于硬件或者软件问题导致的宕机事故。
微服务，从本质意义上看，还是SOA架构。但内涵有所不同，微服务并不绑定某种特殊的技术，在一个微服务的系统中，可以有Java编写的服务，也可以有Python编写的服务，他们是靠Restful架构风格统一成一个系统的。]]></summary>
            
                <content type="html"><![CDATA[<h1 id="简述">简述</h1>

<p>使用基于微服务的方式使得应用程序开发变得更快更容易管理，它只需要较少的人力就能实现更多的功能，可以更快更容易地部署。把应用程序设计成一套微服务，更加容易在多台具有负载均衡的服务器上运行，使其能够轻松应对需求高峰、由于时间推移而平稳增长的需求和由于硬件或者软件问题导致的宕机事故。</p>

<p>微服务，从本质意义上看，还是SOA架构。但内涵有所不同，微服务并不绑定某种特殊的技术，在一个微服务的系统中，可以有Java编写的服务，也可以有Python编写的服务，他们是靠Restful架构风格统一成一个系统的。</p>

<p>最粗浅的理解就是将微服务之间的交互看作是各种字符串的传递，各种语言都可以很好的处理字符串，所以微服务本身与具体技术实现无关，扩展性强。另一个不同是微服务架构本身很轻，底层也有类似于SOA的总线，不过非常轻薄，现在看到的就两种方式：MQ和HTTP，而HTTP都不能完全等同于总线，而仅仅是个信息通道。</p>

<p>所以，基于这种简单的的协议规范，无论是兼容老旧系统，还是上线新业务，都可以随着时代的步伐，滚动升级。比如：你去年还在使用.NET技术，今年就可以平滑的过度到Go了，而且系统已有服务不用改动。所以微服务架构，既保护用户已有投资，又很容易向新技术演进。
本次研究主要是学习相关内容，并根据实际案例进行重构开发。</p>

<h1 id="单体与微服务">单体与微服务</h1>

<p>单体应用在项目的早期阶段是可以良好运行的，但随着时间的推移，就会逐渐暴露出难以忍受的缺点</p>

<ul>
<li>应用程序趋于复杂使得基本代码难以理解</li>
<li>应用程序启动编译等变成问题，任意一个小的变动都需要整体的重新编译，使大量时间处于等待，降低效率</li>
<li>不同模块存在资源需求冲突时，单体应用可能难以扩展。例如，一个模块可能会执行 CPU 密集型图像处理逻辑，理想情况下是部署在 Amazon EC2 Compute Optimized 实例中。另一个模块可能是一个内存数据库，最适合部署到 EC2 Memory-optimized 实例。然而，由于这些模块被部署在一起，就必须在硬件选择上做出妥协</li>
<li>较低的可靠性。因为所有模块都运行在同一进程中。任何模块的一个 bug，比如内存泄漏，都可能会拖垮整个进程。此外，由于应用程序的所有实例都是相同的，该错误将影响到整个应用的可用性。</li>
<li>单体应用使得采用新框架和语言变得非常困难。例如，我们假设您有 200 万行代码使用了 XYZ 框架编写。如果使用较新的 ABC 框架来重写整个应用，这将非常昂贵（在时间和成本方面），即使框架非常好。因此，这对于采用新技术是一个非常大的障碍。在项目开始时，您无论选择何种新技术都会感到困扰。</li>
</ul>

<p>单体应用存在种种的缺陷，而采用现在所谓的微服务架构模式，就可以解决这些问题</p>

<h1 id="微服务优点">微服务优点</h1>

<p>微服务架构模式有许多非常好的地方。</p>

<ul>
<li><p>第一，它解决了复杂问题。它把可能会变得庞大的单体应用程序分解成一套服务。虽然功能数量不变，但是应用程序已经被分解成可管理的块或者服务。每个服务都有一个明确定义边界的方式，如远程过程调用（RPC）驱动或消息驱动 API。微服务架构模式强制一定程度的模块化，实际上，使用单体代码来实现是极其困难的。因此，使用微服务架构模式，<strong>个体服务能被更快地开发，并更容易理解与维护</strong>。</p></li>

<li><p>第二，这种架构使得每个服务都可以由一个团队独立专注开发。开发者 <strong>可以自由选择任何符合服务 API 契约的技术</strong>。当然，更多的组织是希望通过技术选型限制来避免完全混乱的状态。然而，这种自由意味着开发人员不再有可能在这种自由的新项目开始时使用过时的技术。当编写一个新服务时，他们可以选择当前的技术。此外，由于服务较小，使用当前技术重写旧服务将变得更加可行。</p></li>

<li><p>第三，微服务架构模式可以实现每个微服务 <strong>独立部署</strong>。开发人员根本不需要去协调部署本地变更到服务。这些变更一经测试即可立即部署。比如，UI 团队可以执行 A|B 测试，并快速迭代 UI 变更。微服务架构模式使得持续部署成为可能。</p></li>

<li><p>最后，微服务架构模式使得每个服务能够 <strong>独立扩展</strong>。您可以仅部署满足每个服务的容量和可用性约束的实例数目。此外，您可以使用与服务资源要求最匹配的硬件。例如，您可以在 EC2 Compute Optimized 实例上部署一个 CPU 密集型图像处理服务，并且在 EC2 Memory-optimized 实例上部署一个内存数据库服务。</p></li>
</ul>

<h1 id="微服务缺点">微服务缺点</h1>

<p>与其他技术一样，微服务架构模式也存在着缺点。</p>

<ul>
<li><p>微服务一个主要缺点是由于微服务是一个分布式系统，其使得整体变得复杂。开发者需要选择和实现基于消息或者 RPC 的进程间 <strong>通信机制</strong> 。此外，由于目标请求可能很慢或者不可用，他们必须要编写代码来处理局部故障。虽然这些并不是很复杂、高深，但模块间通过语言级方法/过程调用相互调用，这比单体应用要复杂得多。</p></li>

<li><p>微服务的另一个挑战是 <strong>分区数据库架构</strong>。更新多个业务实体的业务事务是相当普遍的。这些事务在单体应用中的实现显得微不足道，因为单体只存在一个单独的数据库。在基于微服务的应用程序中，您需要更新不同服务所用的数据库。通常不会选择分布式事务，不仅仅是因为 CAP 定理。他们根本不支持如今高度可扩展的 NoSQL 数据库和消息代理。您最后不得不使用基于最终一致性的方法，这对于开发人员来说更具挑战性。</p></li>

<li><p><strong>测试</strong> 微服务应用程序也很复杂。例如，使用现代框架如 Spring Boot，只需要编写一个测试类来启动一个单体 web 应用程序并测试其 REST API。相比之下，一个类似的测试类对于微服务来说需要启动该服务及其所依赖的所有服务，或者至少为这些服务配置存根。再次声明，虽然这不是一件高深的事情，但不要低估了这样做的复杂性。</p></li>

<li><p>微服务架构模式的另一个主要挑战是实现了跨越 <strong>多服务变更</strong>。例如，我们假设您正在实现一个变更服务 A、服务 B 和 服务 C 的需求，其中 A 依赖于 B，且 B 依赖于 C。在单体应用程序中，您可以简单地修改相应的模块、整合变更并一次性部署他们。相反，在微服务中您需要仔细规划和协调出现的变更至每个服务。例如，您需要更新服务 C，然后更新服务 B，最后更新服务 A。幸运的是，大多数变更只会影响一个服务，需要协调的多服务变更相对较少。</p></li>

<li><p><strong>部署</strong> 基于微服务的应用程序也是相当复杂的。一个单体应用可以很容易地部署到基于传统负载均衡器的一组相同服务器上。每个应用程序实例都配置有基础设施服务的位置（主机和端口），比如数据库和消息代理。相比之下，微服务应用程序通常由大量的服务组成。每个服务都有多个运行时实例。还有更多的移动部件需要配置、部署、扩展和监控。此外，您还需要实现服务发现机制，使得服务能够发现需要与之通信的任何其他服务的位置（主机和端口）。因此，要成功部署微服务应用程序，需要求开发人员能高度控制部署方式和高度自动化。
自动化微服务部署的另一个方式是开发自己的 PaaS (platform as a service)。一个普遍的起点是使用集群方案，如 Kubernetes，与 Docker 等容器技术相结合。</p></li>
</ul>

<h1 id="微服务系统底座">微服务系统底座</h1>

<p>一个完整的微服务系统，它的底座最少要包含以下功能：
- 注册发现
- 负载均衡
- 部署和升级
- 事件调度机制
- 资源管理，如：底层的虚拟机，物理机和网络管理
- 日志和审计，主要是日志的汇总，分类和查询
- 监控和告警，主要是监控每个服务的状态，必要时产生告警
- 消息总线，轻量级的MQ或HTTP</p>

<h1 id="参考">参考</h1>

<ul>
<li><a href="https://github.com/DocsHome/microservices" target="_blank">https://github.com/DocsHome/microservices</a></li>
<li><a href="http://www.infoq.com/cn/articles/what-complete-micro-service-system-should-include" target="_blank">http://www.infoq.com/cn/articles/what-complete-micro-service-system-should-include</a></li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" term="微服务" label="微服务" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" term="微服务" label="微服务" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">容器学习-k8s插件</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0-k8s%E6%8F%92%E4%BB%B6/" />
            <id>https://blog.vgmdj.cn/posts/%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0-k8s%E6%8F%92%E4%BB%B6/</id>
            <updated>2018-05-01T14:30:58+00:00</updated>
            <published>2018-05-01T14:52:51+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[应用插件 安装完k8s后，仅仅只是第一步，我们还需要一系列的插件来提供对集群的管理，以提高效率
 traefik ingress，提供负载均衡和统一的对外暴露端口 heapster插件，提供监控系统 dashboard插件，用于显示当前资源使用情况 EFK插件，ElasticSearch+Fluentd+Kibana，用于日志的收集分析和搜索]]></summary>
            
                <content type="html"><![CDATA[<h2 id="应用插件">应用插件</h2>

<p>安装完k8s后，仅仅只是第一步，我们还需要一系列的插件来提供对集群的管理，以提高效率</p>

<ul>
<li>traefik ingress，提供负载均衡和统一的对外暴露端口</li>
<li>heapster插件，提供监控系统</li>
<li>dashboard插件，用于显示当前资源使用情况</li>
<li>EFK插件，ElasticSearch+Fluentd+Kibana，用于日志的收集分析和搜索</li>
</ul>

<h2 id="配置dashboard">配置dashboard</h2>

<p>yaml文件可以通过kubernetes github仓库里的官方推荐来安装</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">https://raw.githubusercontent.com/kubernetes/dashboard/master/src/deploy/recommended/kubernetes-dashboard.yaml</code></pre></td></tr></table>
</div>
</div>
<p>也可以通过我修改后的yaml文件来配置，做的修改只是把镜像换成了国内可访问的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">https://github.com/vgmdj/k8s-config/blob/master/addons/dashboard/kubernetes-dashboard.yaml</code></pre></td></tr></table>
</div>
</div>
<h2 id="配置-heapster插件">配置 heapster插件</h2>

<p>下载配置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">https://github.com/vgmdj/k8s-config/tree/master/addons/heapster</code></pre></td></tr></table>
</div>
</div>
<p>直接在文件夹里执行即可</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">kubectl create -f .</code></pre></td></tr></table>
</div>
</div>
<h2 id="efk插件">EFK插件</h2>

<p>同上</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">https://github.com/vgmdj/k8s-config/tree/master/addons/elasticsearch-fluentd-kibana</code></pre></td></tr></table>
</div>
</div>
<h2 id="traefik-ingress">traefik-ingress</h2>

<p>配置同上，traefik Annotate需要根据实际的环境进行配置</p>

<ul>
<li><p>kubernetes.io/ingress.class: traefik
Ingress声明，这里声明了ingress后端采用traefik实现，而不是nginx的controller</p></li>

<li><p>ingress.kubernetes.io/whitelist-source-range: &ldquo;1.2.3.0/24, fe80::/16&rdquo;
配置访问白名单，支持ipv4和ipv6</p></li>

<li><p>ingress.kubernetes.io/auth-type: basic
http认证模式，此处为basic模式</p></li>

<li><p>ingress.kubernetes.io/auth-secret: mysecret
basic认证的对应的username和password，这里对应的traefik所在kubernetes命名空间里的secrets</p></li>

<li><p><strong>traefik.frontend.rule.type: PathPrefixStrip</strong>
如果说host对应的是nginx的server_name, 那么加上这条PathPrefixStrip后，path 就对应nginx里的 location，如果不加的话，则表示，只有定义的path才会进行反向代理</p></li>

<li><p>traefik.frontend.priority: &ldquo;3&rdquo;
配置前端的权重，值越高则优先匹配</p></li>

<li><p>traefik.frontend.passHostHeader: &ldquo;false&rdquo;
关闭传入Hearder</p></li>

<li><p>traefik.protocol=https
使用https协议</p></li>

<li><p>traefik.frontend.entryPoints=http,https
同时支持http和https，默认只支持http</p></li>

<li><p>traefik.ingress.kubernetes.io/app-root: &ldquo;/index.html&rdquo;
全部请求都重定向到首页</p></li>

<li><p>traefik.ingress.kubernetes.io/load-balancer-method: drr
后端服务负载策略，默认是wrr-加权循环调度算法，drr-差额循环队列</p></li>

<li><p>traefik.backend.healthcheck.path=/health
traefik的监控检查路径</p></li>

<li><p>traefik.backend.healthcheck.interval=5s
健康检查的时间间隔</p></li>

<li><p>traefik.backend.circuitbreaker: &ldquo;NetworkErrorRatio() &gt; 0.5&rdquo;
监测某台节点上的服务错误率达到50%时，自动下线该节点。</p></li>

<li><p>traefik.backend.circuitbreaker: &ldquo;LatencyAtQuantileMS(50.0) &gt; 50&rdquo;
监测某台节点上服务的延时大于50ms时，自动下线该节点。</p></li>

<li><p>traefik.backend.circuitbreaker: &ldquo;ResponseCodeRatio(500, 600, 0, 600) &gt; 0.5&rdquo;
监测某台节点上服务返回状态码为[500-600]在[0-600]区间占比超过50%时，自动下线该节点。</p></li>
</ul>

<h2 id="插件部署节点选择">插件部署节点选择</h2>

<p>使用nodeSelector的方式选择node节点，下面是加label和删除label的指令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">加
kubectl label nodes &lt;node-name&gt; key=value

改
kubectl label nodes &lt;node-name&gt; key=value --overwirte

删
kubectl label nodes &lt;node-name&gt; key-

全能
kubectl edit node &lt;node-name&gt;</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" term="分布式系统" label="分布式系统" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/k8s/" term="k8s" label="k8s" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" term="分布式系统" label="分布式系统" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">容器学习-k8s搭建</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0-k8s%E6%90%AD%E5%BB%BA/" />
            <id>https://blog.vgmdj.cn/posts/%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0-k8s%E6%90%AD%E5%BB%BA/</id>
            <updated>2018-04-26T14:30:58+00:00</updated>
            <published>2018-04-26T14:28:51+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[kubernetes 学习 目标，搭建好环境，使k8s集群运行起来，在其上部署一个服务，并可以正常访问 当然，单单一个k8s搭建完成还是不够的，还需要一系统的应用来保证服务的高可用，如负载均衡，多master防单点故障等 会在之后进行分析]]></summary>
            
                <content type="html"><![CDATA[<h1 id="kubernetes-学习">kubernetes 学习</h1>

<p>目标，搭建好环境，使k8s集群运行起来，在其上部署一个服务，并可以正常访问
当然，单单一个k8s搭建完成还是不够的，还需要一系统的应用来保证服务的高可用，如负载均衡，多master防单点故障等
会在之后进行分析</p>

<h1 id="搭建">搭建</h1>

<h2 id="源码包">源码包</h2>

<p>第一步，先从github上把源码下载到本地，再按照文档的要求一步一步搭建
  源码地址： <a href="https://github.com/kubernetes/kubernetes" target="_blank">https://github.com/kubernetes/kubernetes</a>
  安装过程可以看：　<a href="https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/" target="_blank">https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/</a></p>

<h2 id="完成目标">完成目标</h2>

<p>根据官方文档走，最终搭建成功后，应该最终情况为</p>

<ul>
<li>一个master节点，上面运行着etcd提供k8s数据管理, apiserver, scheduler等提供k8s管控</li>
<li>n个node节点，其上主要运行服务</li>
</ul>

<p>从这里也可以看出，官方不推荐把服务也运行在master上的原因，单master结点，etcd还只在其上，一但master结点压力太大挂掉，虽然不影响node上服务的运行，但将失去变更调控的能力。
当然生产环境高可用肯定不能只这样保证，但如果没那么高的需求，这样的一个简单的配置也是可用的</p>

<h2 id="过程">过程</h2>

<h3 id="使用apt-yum安装kubeadm">使用apt/yum安装kubeadm</h3>

<p>这里第一步需要添加kubernetes的密钥，但是这个下载链接是被墙的，这里我放在自己服务器上，有需要的可以<a href="/kubernetes/apt-key.gpg">下载</a>，之后apt-key add apt-key.gpg即可
同时，apt源也需要更换成中科大的kubernetes源
ps: 之前阿里云源更新不及时，可以会造成版本不一致，现在两者都是最新版本了，就没什么顾虑了。截至到目前为止，都是1.10.1</p>

<ul>
<li><p>ubuntu下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">apt-get update &amp;&amp; apt-get install -y apt-transport-https curl
curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -
cat &lt;&lt;EOF &gt; /etc/apt/sources.list.d/kubernetes.list
deb http://mirrors.ustc.edu.cn/kubernetes/apt/ kubernetes-xenial main
EOF
apt-get update
apt-get install -y kubelet kubeadm kubectl</code></pre></td></tr></table>
</div>
</div></li>

<li><p>centos下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo
[kubernetes]
name=Kubernetes
baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64
enabled=1
gpgcheck=0
repo_gpgcheck=0
gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg
  http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg
EOF
setenforce 0
yum install -y kubelet kubeadm kubectl
systemctl enable kubelet &amp;&amp; systemctl start kubelet</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h3 id="master-节点配置">master 节点配置</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">kubeadm init --pod-network-cidr=10.244.0.0/16

echo export KUBECONFIG=/etc/kubernetes/admin.conf &gt;&gt; /etc/profile
source /etc/profile</code></pre></td></tr></table>
</div>
</div>
<p>注意，这里有两个点要注意，一个是要加&ndash;pod-network-cidr=10.244.0.0/16，在官方文档的第二步没有出现，等我做到第三步了再出现，有点坑，还得kubeadm reset 重置一下，再来一遍init(也可以在配置文件kube-controller-manager.yaml里加上后，再重启服务，总体感觉不如reset + init来的利索)
另一点，就是这里的init一般情况下基本都成功不了，会卡在下载镜像这一步，原因还是墙的问题，如果国内没梯子出现下面这句，就不用等了，等了也是白等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">This often takes around a minute; or longer if the control plane images have to be pulled.</code></pre></td></tr></table>
</div>
</div>
<p>通过log可以看出，这是在docker pull的时候卡住了，这里分享一个解决方案</p>

<ul>
<li>先在master上建立一个docker registry</li>
<li>再使用国内源把要下载的镜像下下来，保存好后再传到master上，然后tag改名</li>
<li>所有需要的images都在/etc/kubernetes/manifest/*.yaml下</li>
</ul>

<h3 id="flannel-配置">flannel 配置</h3>

<p>先设置cni的前置条件，CNI（Container Network Interface）是CNCF旗下的一个项目，由一组用于配置Linux容器的网络接口的规范和库组成，同时还包含了一些插件。CNI仅关心容器创建时的网络分配，和当容器被删除时释放网络资源。通过此链接浏览该项目：<a href="https://github.com/containernetworking/cni" target="_blank">https://github.com/containernetworking/cni</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">sysctl net.bridge.bridge-nf-call-iptables=1</code></pre></td></tr></table>
</div>
</div>
<p>再配置flannel</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/v0.9.1/Documentation/kube-flannel.yml</code></pre></td></tr></table>
</div>
</div>
<p>这里推荐先把yml文件下载下来，把其中的镜像源替换成国内源</p>

<ul>
<li><p>状态验证</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">此时可以使用
kubectl get pods --all-namespaces</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<p>来查看当前pod情况，如果flannel正常，就可以配置node节点了</p>

<h3 id="node-节点配置">node 节点配置</h3>

<p>先把之前下载的镜像</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">docker save k8s.gcr.io/xxx &gt; xxx.tar

scp xxx.tar root@xxx:~/

切到node上后，

docker load &lt; xxx.tar</code></pre></td></tr></table>
</div>
</div>
<p>镜像加载完后，照着master上成功后，出现的命令，在node上来一下就好了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">kubeadm join --token &lt;token&gt; &lt;master-ip&gt;:&lt;master-port&gt; --discovery-token-ca-cert-hash sha256:&lt;hash&gt;</code></pre></td></tr></table>
</div>
</div>
<h1 id="遇到的问题">遇到的问题</h1>

<p>总的来说，现在k8s搭建还是很简单的，主要遇到的问题，主要是GFW问题，再有就是版本不一致带来的问题
- docker 代理配置</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># mkdir /etc/systemd/system/docker.service.d
# echo &#39;[Service]
Environment=&#34;HTTP_PROXY=socks5://xx.xx.xx.xx:1080/&#34;  &#34;HTTPS_PROXY=socks5://xx.xx.xx.xx:1080/&#34; &#34;NO_PROXY=localhost,127.0.0.1&#34; &#39; &gt; \
/etc/systemd/system/docker.service.d/http-proxy.conf

systemctl daemon-reload
systemctl restart docker</code></pre></td></tr></table>
</div>
</div>
<ul>
<li><p>network not ready</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">runtime network not ready: NetworkReady=false reason:NetworkPluginNotReady message:docker: network plugin is not</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">mkdir /etc/cni/net.d
echo &#39;{
&#34;name&#34;: &#34;cbr0&#34;,
&#34;type&#34;: &#34;flannel&#34;,
&#34;delegate&#34;: {
&#34;isDefaultGateway&#34;: true
}
}&#39; &gt; /etc/cni/net.d/10-flannel.conf </code></pre></td></tr></table>
</div>
</div></li>

<li><p>kubeadm join err</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[ERROR CRI]: unable to check if the container runtime at &#34;/var/run/dockershim.sock&#34; is running: fork/exec /opt/golang/bin/crictl -r /var/run/dockershim.sock info: no such file or directory</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<p>crictl 当前仍然不稳定，如果是使用推荐的go get 的方式来安装的，感觉问题反而更大。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">That bug-fix is only applicable after release v1.10. Currently you can try it in all v1.10.0 beta versions, v1.10.0 rc version and v1.11.0 alpha version.</code></pre></td></tr></table>
</div>
</div>
<ul>
<li><p>kubeadm init后，kube-dns状态异常
进入描述查看，发现message：0/1 nodes are available: 1 node(s) were not ready.
发现问题是 node not ready ，再去解决node 问题，dns正常</p></li>

<li><p>源码编译 make 失败
原因，内存不足，如果想要make编译，需要8G内存应该
<a href="https://github.com/kubernetes/kubernetes/issues/42599" target="_blank">https://github.com/kubernetes/kubernetes/issues/42599</a></p></li>

<li><p>crictl 冲突</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">[WARNING FileExisting-crictl]: crictl not found in system path</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<p>解决方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">go get github.com/kubernetes-incubator/cri-tools/cmd/crictl</code></pre></td></tr></table>
</div>
</div>
<ul>
<li>kubeadm init时卡住
解决方式如上</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" term="分布式系统" label="分布式系统" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/k8s/" term="k8s" label="k8s" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" term="分布式系统" label="分布式系统" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">微信开发问题小结</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/" />
            <id>https://blog.vgmdj.cn/posts/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/</id>
            <updated>2018-05-16T09:26:01+00:00</updated>
            <published>2018-04-23T16:23:50+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[前言 微信公众号开发告一段落，在这里总结一下期间遇到的各种问题]]></summary>
            
                <content type="html"><![CDATA[<h1 id="前言">前言</h1>

<p>微信公众号开发告一段落，在这里总结一下期间遇到的各种问题</p>

<h1 id="oauth2-授权重定向两次问题">oauth2 授权重定向两次问题</h1>

<p>每次从微信那边来的重定向，都有两次，一次什么信息都不带，一次则是正常的含有code和state的跳转，这样就带来了一系列的问题，包含让error信息混乱，加大并发压力等
使用第三方代理域名或者是用nginx做反向代理，在向微信服务器发送请求的时候，微信回调时，会认为你的域名请求不一致，会回调两次，重定向你的服务器两次。
解决方式也很简单</p>

<ul>
<li>更改正式域名，不使用反向代理就会回调一次</li>

<li><p>加参数使其只返回一次</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">请求里加上&amp;connect_redirect=1

func AuthCodeURL(appId, redirectURI, scope, state string) string {
	return &#34;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&#34; + url.QueryEscape(appId) +
		&#34;&amp;redirect_uri=&#34; + url.QueryEscape(redirectURI) +
		&#34;&amp;response_type=code&amp;scope=&#34; + url.QueryEscape(scope) +
		&#34;&amp;state=&#34; + url.QueryEscape(state) +
		&#34;#wechat_redirect&#34;
}

改为
func AuthCodeURL(appId, redirectURI, scope, state string) string {
	return &#34;https://open.weixin.qq.com/connect/oauth2/authorize?appid=&#34; + url.QueryEscape(appId) +
		&#34;&amp;redirect_uri=&#34; + url.QueryEscape(redirectURI) +
		&#34;&amp;response_type=code&amp;scope=&#34; + url.QueryEscape(scope) +
		&#34;&amp;state=&#34; + url.QueryEscape(state) +
		“&amp;connect_redirect=1” +
		&#34;#wechat_redirect&#34;
}</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h1 id="服务器连接不上">服务器连接不上</h1>

<p>错误描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ssh_exchange_identification: read: Connection reset by peer</code></pre></td></tr></table>
</div>
</div>
<p>解决尝试：</p>

<ul>
<li>能ping通</li>
<li>安全组22端口可用</li>
<li>/etc/hosts.allow 和 /etc/hosts.deny均为 注释，无新添加项<br /></li>
<li>使用外部服务器中转，即先连其他服务器，再从这台服务器上连接原服务器，可正常登录</li>
</ul>

<p>猜测原因：
在其他服务器可连，且hosts.allow和hosts.deny均为默认项，则不是服务器禁止
判断为云服务器商拉黑ip
在云服务商文档处查看，设置白名单，问题解决
<a href="https://help.aliyun.com/knowledge_detail/37914.html" target="_blank">阿里云ip被拦截问题处理</a></p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E5%B7%A5%E4%BD%9C/" term="工作" label="工作" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91/" term="微信开发" label="微信开发" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%B7%A5%E4%BD%9C/" term="工作" label="工作" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">计算机网络学习-常见问题集</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E9%9B%86/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E9%9B%86/</id>
            <updated>2018-04-12T19:38:16+00:00</updated>
            <published>2018-04-12T15:37:05+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[tcp 为什么不是两次握手或者是四次握手 主旨就是握手过程中，商议A与B之间的初始通信序列号
 A告诉B自己序列号 B告诉A，收到且发送自己序列号 A告诉B，初始成功  如果两次，无法保证成功，四次则多了，具体可见： <a href="https://www.zhihu.com/question/24853633" target="_blank">https://www.zhihu.com/question/24853633</a>
 如果是两次握手，B没法确认连接已建立，如果A向B发数据，那么data+ack，可以正常进行；如果是B向A发数据，B不知道A是否已接收这次的SEQ，所以没法确认是发送data还是重传SEQ。 如果是两次握手，发生数据延迟，A向B发送的第一次请求在实际请求过期后，才传给B，B收到请求并进行确认，并给A发数据，由于A此次请求已过期，所以不会理会，那么这次B的资源，即服务器资源会产生很大的浪费。]]></summary>
            
                <content type="html"><![CDATA[<h1 id="tcp">tcp</h1>

<h2 id="为什么不是两次握手或者是四次握手">为什么不是两次握手或者是四次握手</h2>

<p>主旨就是握手过程中，商议A与B之间的初始通信序列号</p>

<ul>
<li>A告诉B自己序列号</li>
<li>B告诉A，收到且发送自己序列号</li>
<li>A告诉B，初始成功</li>
</ul>

<p>如果两次，无法保证成功，四次则多了，具体可见：
<a href="https://www.zhihu.com/question/24853633" target="_blank">https://www.zhihu.com/question/24853633</a></p>

<ul>
<li>如果是两次握手，B没法确认连接已建立，如果A向B发数据，那么data+ack，可以正常进行；如果是B向A发数据，B不知道A是否已接收这次的SEQ，所以没法确认是发送data还是重传SEQ。</li>
<li>如果是两次握手，发生数据延迟，A向B发送的第一次请求在实际请求过期后，才传给B，B收到请求并进行确认，并给A发数据，由于A此次请求已过期，所以不会理会，那么这次B的资源，即服务器资源会产生很大的浪费。</li>
</ul>

<h2 id="第三次握手能不能带数据">第三次握手能不能带数据</h2>

<p>结论是可以携带数据，但一般不会出现这种情况。
详细内容可见
 <a href="http://www.0xffffff.org/2015/04/15/36-The-TCP-three-way-handshake-with-data/" target="_blank">http://www.0xffffff.org/2015/04/15/36-The-TCP-three-way-handshake-with-data/</a></p>

<h2 id="为什么不是三次挥手或五次挥手">为什么不是三次挥手或五次挥手</h2>

<p>三次会有浪费或无法确认的情况发生，五次则多了，具体可见：
<a href="https://www.zhihu.com/question/63264012/answer/298264454" target="_blank">https://www.zhihu.com/question/63264012/answer/298264454</a></p>

<ul>
<li>如果是三次挥手，把第二次和第三次请求进行合并，B此时如果还有数据要发送，A就不会知道B是否知道A想要关闭请求，A就会重复发送FIN请求。</li>
<li>如果是三次挥手，把第四次请求去掉，那么假如B没收到A的ack，那么B就不知道是要关闭还是重发FIN。</li>
</ul>

<h2 id="服务端只监听一个端口-如何唯一确定一个tcp连接">服务端只监听一个端口，如何唯一确定一个tcp连接</h2>

<p>tcp中使用四元组（客户端IP，客户端PORT，服务端IP，服务端PORT）来唯一确定连接的双方</p>

<h2 id="服务端怎么避免tcp长连接造成的资源浪费">服务端怎么避免tcp长连接造成的资源浪费</h2>

<ul>
<li>tcp KeepAliveTimeout 请求等待超时时长设置</li>
<li>tcp MaxKeepAliveRequests 最大请求数量设置</li>
</ul>

<h2 id="tcp-time-out状态的作用是什么">tcp TIME_OUT状态的作用是什么</h2>

<p>TIME_OUT 状态保持时长为2MSL，其主要作用是</p>

<ul>
<li>确保发送最后一次ACK，假使客户端发送的ACK没有送达，服务端由于TCP的重传机制，会再次发送FIN，以确保能收到ACK。如果此时客户端已重置为CLOSED，则收到服务端的FIN，会回复一个RST，那么服务端就会认为发生了一个错误。</li>
<li>使之前的数据包都在网络上因过期而消失
假如之前有数据包因各种原因而没有到达服务端 ，此时如果新创建一个连接，还是使用这个四元组，那么之前的数据包到达服务端后，就会被当成正常的数据进行处理，服务端会对这个“正常”的数据包进行回复，而客户端此时也无法分辨出是否正常，就会造成新建立连接的数据错乱。<br>
而如果有TIME_OUT的状态，则网络上的数据消失之前，都不会再复用这个socket（ip+port），此时无论是之前的客户端的数据，还是服务端的数据到达另一端后，都会被回复RST，从而确保数据的正常可靠。</li>
</ul>

<h2 id="tcp-出现大量的close-wait状态">tcp 出现大量的CLOSE_WAIT状态</h2>

<p>CLOSE_WAIT状态是接收到 主动关闭请求的FIN后变成的状态，之后在处理完数据发送FIN后，变更为LAST_ACK，所以出现的原因一般是由于程序中没有对TCP连接进行关闭处理造成的。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" term="计算机网络" label="计算机网络" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" term="计算机网络" label="计算机网络" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">mysql学习-索引</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/mysql%E5%AD%A6%E4%B9%A0-%E7%B4%A2%E5%BC%95/" />
            <id>https://blog.vgmdj.cn/posts/mysql%E5%AD%A6%E4%B9%A0-%E7%B4%A2%E5%BC%95/</id>
            <updated>2018-04-17T17:45:31+00:00</updated>
            <published>2018-04-06T10:00:49+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[索引 索引是存储引擎找到记录的一种数据结构，而索引优化是对查询性能优化最有效的手段。其类似于一本书的目录部分，如果想在一本书中找到某个特定主题，一般会先看书中的“索引部分”，找到对应的页码。
在MySQL中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。
索引可以包含一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。]]></summary>
            
                <content type="html"><![CDATA[<h1 id="索引">索引</h1>

<p>索引是存储引擎找到记录的一种数据结构，而索引优化是对查询性能优化最有效的手段。其类似于一本书的目录部分，如果想在一本书中找到某个特定主题，一般会先看书中的“索引部分”，找到对应的页码。</p>

<p>在MySQL中，存储引擎用类似的方法使用索引，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。</p>

<p>索引可以包含一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为MySQL只能高效地使用索引的最左前缀列。创建一个包含两个列的索引，和创建两个只包含一列的索引是大不相同的。</p>

<h1 id="索引类型">索引类型</h1>

<h2 id="根据功能划分">根据功能划分</h2>

<ul>
<li><p>UNIQUE
唯一索引，不可以出现相同值，但是可以有NULL值</p></li>

<li><p>INDEX
普通索引，可以出现相同值</p></li>

<li><p>PRIMARY KEY
主键索引，不允许出现相同的值,且不能为NULL值,一个表只能有一个primary_key索引</p></li>

<li><p>FULLTEXT INDEX
全文索引，可以针对值中的某个单词设置索引,但是只有myisam以及英文支持,并且效率不高，特殊场景下使用</p></li>
</ul>

<h2 id="根据数据结构划分">根据数据结构划分</h2>

<ul>
<li><p>B-Tree索引
一般来说， B-Tree 索引的物理文件大多都是以 Balance Tree 的结构来存储的，也就是所有实际需要的数据都存放于 Tree 的 Leaf Node ，而且到任何一个 Leaf Node 的最短路径的长度都是完全相同的，在CREATE TABLE和其他语句中都会使用到该关键字，所以我们大家都称之为 B-Tree 索引。当然，各种存储引擎的底层存储结构可能存在不同，如大多数引擎包括MySQL使用的是B+Tree， NDB集群存储引擎内部使用的是T-TREE结构，但它们都是BTREE。
可以在 <a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html" target="_blank">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a> 上看到B-Tree的可视化操作过程</p></li>

<li><p>Hash索引
基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个hash code，这是一个较小的值，并且不同键值的行计算出的hash code也不一样。哈希索引将所有的hash code存储在索引中，同时在哈希表中保存指向每个数据行的指针。
在MySQL中，只有Memory引擎支持Hash索引，同时Hash索引也是Memory引擎的默认索引类型。</p></li>
</ul>

<h2 id="b-tree索引-和-hash索引对比">B-Tree索引 和 Hash索引对比</h2>

<ul>
<li>如果是等值查询，那么哈希索引明显有绝对优势，因为Hash表查找是O(1)的时间复杂度；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</li>
<li>如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；</li>
<li>同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</li>
<li>哈希索引也不支持多列联合索引的最左匹配规则；</li>
<li>B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</li>
</ul>

<h2 id="b-tree-和-b-tree-比较">B-Tree 和 B+Tree 比较</h2>

<p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p>

<h2 id="innodb-与-myisam-比较">InnoDB 与 MyISAM 比较</h2>

<ul>
<li>InnoDB 支持事务，MyISAM 不支持事务</li>
<li>InnoDB 支持外键，而 MyISAM 不支持</li>
<li>InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。</li>
<li>InnoDB 不保存表的具体行数，执行 <code>select count(*) from table</code> 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快</li>
<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限</li>
</ul>

<h1 id="索引的优缺点">索引的优缺点</h1>

<h2 id="优点">优点</h2>

<ul>
<li>索引大大减少了服务器需要扫描的数据量</li>
<li>索引可以帮助服务器避免排序和临时表</li>
<li>索引可以将随机I/O变为顺序I/O</li>
</ul>

<h2 id="缺点">缺点</h2>

<ul>
<li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li>
<li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度</li>
</ul>

<h1 id="索引的适用范围及限制-b-tree索引">索引的适用范围及限制（B-Tree索引）</h1>

<h2 id="有效范围">有效范围</h2>

<ul>
<li>全值匹配</li>
<li>匹配最左前缀</li>
<li>匹配列前缀</li>
<li>匹配范围值</li>
<li>精确匹配某一列并范围匹配另外一列</li>
<li>只访问索引的查询</li>
<li>空值查询，使用<strong>is null</strong>可以使用到索引</li>
</ul>

<h2 id="使用限制">使用限制</h2>

<ul>
<li>如果MySQL估计使用索引比全表扫描慢，则不使用

<ul>
<li>value 均匀分布在1-100,查询 &lsquo;where value &gt; 1 and value &lt; 100&rsquo;时，不使用索引反而更好</li>
</ul></li>
<li>like 模糊查找有一定限制

<ul>
<li>like &lsquo;%3&rsquo; 不会使用索引</li>
<li>like &lsquo;3%&rsquo; 会使用索引</li>
</ul></li>
<li>对于MEMORY/HEAP表，where条件中不使用“=”进行索引列，那么不会用到索引</li>
</ul>

<h2 id="设计索引原则">设计索引原则</h2>

<ul>
<li>尽量使用选择性高的列，即在重复度高的列上建立索引，不要在重复度低的列上建立索引</li>
<li>利用最左前缀，多个列的独立索引相比联合索引会带来更多的空间和计算资源上的消耗，所以如果能匹配上最左前缀，就使用多列索引，而不要使用多个列索引</li>
<li>利用很少的列尽量不要建立索引，因为虽然索引可以带来搜索效率上的提升，但同时需要占用额外的空间，以及修改时的额外开销</li>
<li>主键尽量使用较短的数据类型，可以有效地减少索引的磁盘占用，提高索引的缓存效果</li>
</ul>

<h1 id="索引策略">索引策略</h1>

<h2 id="使用独立的列">使用独立的列</h2>

<p>独立的列是指索引列不能是表达式的一部分，也不能是函数的参数</p>

<ul>
<li><p>下列查询无法使用索引actor_id</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<p>应改为</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">SELECT actor_id FROM sakila.actor WHERE actor_id = 4;

如果一定要用表达式，也应该是：
SELECT actor_id FROM sakila.actor WHERE actor_id = 5-1;</code></pre></td></tr></table>
</div>
</div>
<ul>
<li><p>常见错误</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) &lt;= 10;</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h2 id="前缀索引和索引选择性">前缀索引和索引选择性</h2>

<p>如果要索引一个很长的字符列，这会让索引变得大且慢。一种方案是使用hash索引，但hash索引有时候还不够，这个时候就可以考虑使用前缀索引。</p>

<h3 id="优缺点">优缺点</h3>

<p>使用前缀索引，可以大大节约索引空间，从而提高索引效率，但同时也会降低索引的选择性，同时不能在 ORDER BY 或 GROUP BY 中使用前缀索引，也不能把它们用作覆盖索引。</p>

<h3 id="prefix-length确定">prefix_length确定</h3>

<p>使用前缀索引的关键在于选择合知的prefix_length，从而尽可能提高索引选择性，即假如对于字符长度10的一半就可以唯一确定这个字符，那么使用前缀索引，prefix_length=5,就可以达到使用索引的应有效果，可以大大节约空间和提高效率
前缀长度的确定方式，就是计算完整列的选择性，并使前缀的选择性接近于完整的选择性。</p>

<ul>
<li><p>完整列的选择性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">select count(distinct city)/count(*) from sakila.city_demo;</code></pre></td></tr></table>
</div>
</div></li>

<li><p>不同前缀长度下的选择性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">select count(distinct left(city,3))/count(*) as sel3,
count(distinct left(city,4))/count(*) as sel4,
count(distinct left(city,5))/count(*) as sel5,
count(distinct left(city,6))/count(*) as sel6,
count(distinct left(city,7))/count(*) as sel7
from sakila.city_demo;</code></pre></td></tr></table>
</div>
</div></li>

<li><p>比较结果，选择长度和选择性都比较合适的情况建立前缀索引</p></li>
</ul>

<h3 id="适用场景">适用场景</h3>

<ul>
<li>字符串列(varchar,char,text等)，需要进行全字段匹配</li>
<li>字符串本身可能比较长，而且前几个字符就开始不相同。比如我们对中国人的姓名使用前缀索引就没啥意义，因为中国人名字都很短，另外对收件地址使用前缀索引也不是很实用，因为一方面收件地址一般都是以XX省开头，也就是说前几个字符都是差不多的，而且收件地址进行检索一般都是like ’%xxx%’，不会用到前匹配。相反对外国人的姓名可以使用前缀索引，因为其字符较长，而且前几个字符的选择性比较高。同样电子邮件也是一个可以使用前缀索引的字段。</li>
<li>前一半字符的索引选择性就已经接近于全字段的索引选择性。如果整个字段的长度为20，索引选择性为0.9，而我们对前10个字符建立前缀索引其选择性也只有0.5，那么我们需要继续加大前缀字符的长度，但是这个时候前缀索引的优势已经不明显，没有太大的建前缀索引的必要了。</li>
</ul>

<h2 id="多列索引">多列索引</h2>

<p>所谓的多列索引，并不是指为多个列建立独立的索引，而是建立一个包含相关列的多列索引（联合索引）。
在一次查询中，MySQL只能使用一个索引，同时，若表中索引过多，会影响INSERT及UPDATE性能，简单说就是会影响数据写入性能。因为更新数据的同时，也要同时更新索引。
再者，建立多个独立单列索引，在进行查询时，数据库通常会进行索引合并（index merge）操作，这会耗费大量的计算资源，更优的做法是尽量去除索引合并，改为使用多列索引</p>

<h2 id="选择合适的顺序-b-tree">选择合适的顺序（B-Tree）</h2>

<p>使用多列索引时，也要注意索引的顺序问题，即需要注意最左匹配原则。
那么如何选取一个索引顺序，下面列举出所有可能有影响的条件：</p>

<ul>
<li>列的选择性</li>
<li>列的长度</li>
<li>排序和分组情况</li>
</ul>

<p>选取 <a href="https://segmentfault.com/q/1010000000342176" target="_blank">https://segmentfault.com/q/1010000000342176</a> 中的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">对于联合索引（a,b,c)，只有
(a), (a,b), (a,b,c)起作用

优: select * from test where a=10 and b&gt;50 差: select * from test where
b=50

优: select * from test order by a 差: select * from test order by b 差:
select * from test order by c

优: select * from test where a=10 order by a 优: select * from test
where a=10 order by b 差: select * from test where a=10 order by c

优: select * from test where a&gt;10 order by a 差: select * from test
where a&gt;10 order by b 差: select * from test where a&gt;10 order by c

优: select * from test where a=10 and b=10 order by a 优: select * from
test where a=10 and b=10 order by b 优: select * from test where a=10
and b=10 order by c

优: select * from test where a=10 and b=10 order by a 优: select * from
test where a=10 and b&gt;10 order by b 差: select * from test where a=10
and b&gt;10 order by c</code></pre></td></tr></table>
</div>
</div>
<h2 id="聚簇索引">聚簇索引</h2>

<p>聚簇索引并不是一种单独的索引类型，而是一种数据的存储方式，它的数据行实际上存放在索引的叶子页（leaf page）中，术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引，除此之外的表上的每个非聚簇索引都是二级索引，又叫辅助索引（secondary indexes）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">以InnoDB来说，每个InnoDB表具有一个特殊的索引称为聚集索引。如果您的表上定义有主键，该主键索引是聚集索引。
如果你不定义为您的表的主键时，MySQL取第一个唯一索引（unique）而且只含非空列（NOT NULL）作为主键，InnoDB使用它作为聚集索引。
如果没有这样的列，InnoDB就自己产生一个这样的ID值，它有六个字节，而且是隐藏的，使其作为聚簇索引。</code></pre></td></tr></table>
</div>
</div>
<p>聚簇索引的使用优点：</p>

<ul>
<li>可以把相关数据保存在一起。因为数据和索引存放在一起，所以在读取时，只用读取少量的数据页就能获取某个用户的全部邮件</li>
<li>数据的访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点</li>
</ul>

<p>聚簇索引的使用缺点：</p>

<ul>
<li>聚簇索引最大限度提高了 I/O 密集型应用的性能，但是如果数据全部放在内存，就没必要用聚簇索引</li>
<li>插入速度严重依赖于插入顺序，按主键的顺序插入是最快的</li>
<li>更新操作代价很高，因为每个被更新的行都会移动到新的位置</li>
<li>当插入到某个已满的页中，存储引擎会将该页分裂成两个页面来容纳该行，页分裂会导致表占用更多的磁盘空间</li>
<li>如果行比较稀疏，或者由于页分裂导致数据存储不连续时，聚簇索引可能导致全表扫描速度变慢</li>
</ul>

<h2 id="覆盖索引-innodb">覆盖索引（innoDB）</h2>

<p>通常索引的添加方式，都是根据WHERE条件来进行创建合适的索引，不过这只是索引优化的一个方面，设计优秀的索引要考虑的方面要更多，对于其中的一个场景，如果索引的叶子节点中已经包含要查询的数据，那么还有什么必要再回表查询呢？
覆盖索引的定义，如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”
对于InnoDB而言，其二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">select * 不好的地方就在于，
一方面一般情况下不会用到所有的字段，会造成资源的浪费
另一方面去除了本可以使用覆盖索引大大提升效率的情况</code></pre></td></tr></table>
</div>
</div>
<h2 id="使用索引扫描来做排序">使用索引扫描来做排序</h2>

<p>MySQL有两种方式可以生成有序的结果： 通过排序操作，或者是通过索引顺序扫描</p>

<ul>
<li>只有当索引的列顺序和ORDER BY子句完全一致，并且所有列的排序方向（正序或倒序）都一样时，MySQL才能够使用索引来对结果做排序</li>
<li>如果查询需要关联多张表，则只有当ORDER BY子句引用的字段全部为第一个表时，才能使用索引做排序</li>
<li>ORDER BY子句和查找型查询的限制是一样的，需要满足索引的最左前缀的要求</li>

<li><p>前导列为常量的时候，即WHERE或JOIN子句中对这些列指定了常量，就可以“弥补”索引的不足</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">表结构：
CREATE TABLE rental{
...
PRIMARY KEY(rental_id),
UNIQUE KEY rental_date(rental_date, inventory_id, customer_id),
KEY idx_fk_inventory_id(inventory_id),
KEY idx_fk_customer_id(customer_id),
KEY idx_fk_staff_id(staff_id),
...
};

查询语句：
EXPLAIN SELECT rental_id, staff_id FROM sakila.rental
-&gt; WHERE rental_date = &#39;2005-05-5&#39;
-&gt; ORDER BY inventory_id, customer_id

结果：
     type: ref
possible_keys: rental_date
      key: rental_date
     rows: 1
    extra: using where</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h2 id="删除低质量的索引">删除低质量的索引</h2>

<p>所谓的低质量索引，是指那些冗余、重复、未使用的索引</p>

<ul>
<li>冗余的情况是指，如果已经有了联合索引（a，b），再建立独立索引a，索引a则是冗余的情况</li>
<li>重复的索引是指建立主键索引、唯一索引、普通索引里的两个或三个，实际MySQL里的唯一限制和主键限制都是依靠索引实现的，因此，再此基础上，再加索引，就会造成索引重复</li>
<li>未使用的索引可以通过两个工具来定位。一是打开Percona Server或MariaDB中的userstates服务器变量，运行一段时间后，再查询INFORMATION_SCHEMA.INDEX_STATISTICS追查每个索引的使用频率;二是通过Percona Toolkit中的pt-index-usage，该工具可以读取查询日志，并对日志中的每条查询进行EXPLAIN操作，然后打印出关于索引和查询的报告</li>
</ul>

<h1 id="参考内容">参考内容</h1>

<ul>
<li>《高性能MySQL》</li>
<li>《深入浅出MySQL》</li>
<li><a href="https://blog.csdn.net/oChangWen/article/details/54024063" target="_blank">hash索引和B-Tree索引的区别</a></li>
<li><a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank">https://dev.mysql.com/doc/refman/5.7/en/</a></li>
<li><a href="http://www.cnblogs.com/studyzy/p/4310653.html" target="_blank">http://www.cnblogs.com/studyzy/p/4310653.html</a></li>
<li><a href="https://tech.meituan.com/mysql-index.html" target="_blank">https://tech.meituan.com/mysql-index.html</a></li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/database/" term="database" label="database" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/database/" term="database" label="database" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/mysql/" term="mysql" label="mysql" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">go语言学习-并发控制</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/" />
            <id>https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</id>
            <updated>2019-05-06T16:54:58+00:00</updated>
            <published>2018-04-01T09:57:51+08:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[介绍 人们多把go比作21世纪的C语言，第一是因为Go语言设计简单，第二就是因为，21世纪最重要的就是并行程序设计，而Go从语言层面就支持了并行 这里我们主要从高并发下可能出现的问题和go的解决方案这个方向上进行归纳
参考  《Go语言实战》 《Go并发编程实战-第二版》 《Programming in Go》 《Effective Go》]]></summary>
            
                <content type="html"><![CDATA[<h1 id="介绍">介绍</h1>

<p>人们多把go比作21世纪的C语言，第一是因为Go语言设计简单，第二就是因为，21世纪最重要的就是并行程序设计，而Go从语言层面就支持了并行
这里我们主要从高并发下可能出现的问题和go的解决方案这个方向上进行归纳</p>

<h1 id="参考">参考</h1>

<ul>
<li>《Go语言实战》</li>
<li>《Go并发编程实战-第二版》</li>
<li>《Programming in Go》</li>
<li>《Effective Go》</li>
</ul>

<h1 id="基础知识">基础知识</h1>

<h2 id="进程-process-线程-thread-和协程-coroutine">进程（process）、线程（thread）和协程（coroutine）</h2>

<ul>
<li><p>进程是Unix及其衍生操作系统的根本，因为所有代码都是在进程中执行的。通常，我们把一个程序的执行称为一个进程，即程序和进程是一对概念，它们分别描述了一个程序的静态形式和动态特征。同时，进程是操作系统进行资源分配的最小单位。</p></li>

<li><p>线程是进程的一个实体，是CPU分派和调度的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。</p></li>

<li><p>协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。</p></li>

<li><p>goroutine 是 golang 在语言级别实现的一种协程，拥有协程的所有特性，由 go 的运行时(runtime) 管理，</p></li>
</ul>

<h2 id="进程与子进程">进程与子进程</h2>

<p>进程可以使用系统调用fork创建若干个新的进程。前者称为后者的父进程，后者被称为前者的子进程。每个子进程都源自父进程的一个副本，可以获得父进程的数据段、堆和栈的副本，并与父进程共享代码段。</p>

<p>当父进程意外退出时，子进程会变成孤儿进程，被init接管，子进程退出后的clean工作也由init进程完成。</p>

<p>当子进程退出时，父进程会清理子进程退出后的资源，如果父进程是阻塞等待，那么父进程会解除阻塞，继续执行。</p>

<p>僵尸进程的处理，僵尸进程一定是父进程未退出，且不管退出的子进程所造成的。那么其中的一种常见的补救方式就是杀死父进程，这样子进程由init进程接管来处理清理工作。</p>

<ul>
<li><p>init进程
init进程是内核启动的第一个用户级进程。init有许多很重要的任务，比如像启动getty（用于用户登录）、实现运行级别、以及处理孤儿进程。</p></li>

<li><p>孤儿进程
一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作。</p></li>

<li><p>僵尸进程
一个子进程在其父进程还没有调用wait()或waitpid()的情况下退出。这个子进程就是僵尸进程。任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，这就会造成新的进程无法被创建。
但是如果子进程的父进程已经先结束了，那么该进程就不会变成僵尸进程， 因为此时会被init进程接管，由init成为它的父进程</p></li>

<li><p>守护进程(Daemon)
一个守护进程的父进程是init进程，因为它真正的父进程在fork出子进程后就先于子进程exit退出了，所以它是一个由init继承的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是标准出错设备stderr的输出都需要特殊处理。
守护进程的名称通常以d结尾，比如sshd、xinetd、crond等</p></li>
</ul>

<h2 id="线程-协程与goroutine的区别">线程、协程与goroutine的区别</h2>

<ul>
<li>线程和进程都是由操作系统进行调度的，而协程是用户态的轻量级线程，由用户来控制调度</li>
<li>goroutine与协程相比，goroutine自己实现了调度器，及golang自己在协程上封装一层，实现了一部分控制，而协程则完全需要自己去做调度控制</li>
<li>操作系统会在物理处理器上调度线程来运行，而 Go 语言的运行时会在逻辑处理器上调度 goroutine来运行。每个逻辑处理器都分别绑定到单个操作系统线程。Go语言的运行时默认会为每个可用的物理处理器分配一个逻辑处理器。</li>
<li>如果创建一个 goroutine 并准备运行，这个 goroutine 就会被放到调度器的全局运行队列中。之后，调度器就将这些队列中的 goroutine 分配给一个逻辑处理器，并放到这个逻辑处理器对应的本地运行队列中。本地运行队列中的 goroutine 会一直等待直到自己被分配的逻辑处理器执行。当goroutine执行一个阻塞的系统调用时，调度器会将这个线程与处理器分离，并创建一个新线程，将其绑定到该逻辑处理器上。之后，调度器会从本地运行队列里选择另一个 goroutine 来运行。一旦被阻塞的系统调用执行完成并返回，对应的 goroutine 会放回到本地运行队列，而之前的线程会保存好，以便之后可以继续使用。</li>
</ul>

<h2 id="进程间通信和线程间通信">进程间通信和线程间通信</h2>

<ul>
<li>进程间通信 管道，信号，消息队列，共享内存，信号量和套接字</li>
<li>在go中，线程间可以通过互斥锁或信道来实现访问控制</li>
</ul>

<h2 id="串行程序和并发程序">串行程序和并发程序</h2>

<ul>
<li>串行程序特指只能被顺序执行的指令列表</li>
<li>并发程序则是可以被并发执行的两个及以上的串行程序的综合体</li>
</ul>

<h2 id="并发-concurrency-程序和并行-parallelism-程序">并发（Concurrency）程序和并行（Parallelism）程序</h2>

<ul>
<li>并发程序是指可以被同时发起执行的程序，可以串行处理也可以并行处理。</li>
<li>并行程序则被设计成可以在并行的硬件上执行的并发程序，着重点在要同时进行处理。</li>
</ul>

<p>并发程序代表了所有可以实现并发行为的程序，它是一个比较宽泛的概念，其中包含了并行程序</p>

<h2 id="csp模型">CSP模型</h2>

<p>Go语言的并发同步模型来自 <strong>通信顺序进程</strong>（Communicating Sequential Processes）这么一个消息传递模型，其通过在goroutine之间传递数据来传递消息，而不是对数据进行加锁来实现同步访问。</p>

<h2 id="mpg-模型">MPG 模型</h2>

<ul>
<li>M (Machine)，用于代表内核线程，M 主要用于与内核映射，并负责运行 G</li>
<li>P (processor)，代表一个 G 运行所需的资源（上下文环境）</li>
<li>G (Goroutine)，代表一个 Go 代码片段，是对其的一个封装</li>
</ul>

<p>当 M 因系统调用而阻塞（准确的说，是它运行的 G 进入了系统调用）的时候，运行时系统就会将该 M 和与之关联的 P 分享开来。这时，如果这个 P 的可运行 G 队列中还有未被运行的 G，那么运行进系统就会找到一个空闲的 M，或创建一个新的 M，并与该 P 关联以满足这些 G 的需要。</p>

<h2 id="io-模型">IO 模型</h2>

<ul>
<li>阻塞 IO (Blocking IO, BIO)，任何一个系统调用都会产生一个由用户态到内核态切换，再从内核态到用户态的切换过程。而进程上下文切换是通过系统中断来实现的，需要保存当前进程的上下文状态，这是一个成本很高的过程。</li>
<li>非阻塞 IO (Non-blocking IO, NIO)，即需要由用户不停地询问内核某种操作是否准备就绪。也就是我们常说的轮询(Polling)，这也是一个比较浪费 CPU 的过程。</li>
<li>IO 复用，主要依赖操作系统提供的 select 和 poll 机制。这里同样会阻塞进程，但是这里进程是阻塞在 select 和 poll 两个系统调上，而不是阻塞在真正的 IO 操作上，另外还有一点不同于阻塞 IO 的是，尽管看起来 IO 复用阻塞了两次，但第一次阻塞是在 select 上时，select 可以监控多个套接口 IO 操作是否准备完成，而不是像阻塞 IO 那样，一次只能监控一个套接口。</li>
<li>信号驱动 IO，信号驱动 IO 就是说我们可以通过 sigaction 系统调用注册一个信号处理程序，然后主程序可以继续向下执行，当我们所监控的套接口的 IO 操作准备就绪时，由内核通知触发前面注册的信号处理程序执行，然后将我们所需要的数据从内核空间拷贝到用户空间。</li>
<li>异步 IO (Asynchronous IO, AIO)，与信号驱动 IO 最主要的区别就是信号驱动 IO 是内核通知我们何时可以进行IO操作，而异步 IO 则是告诉我们 IO 操作何时完成。具体来说，就是信号驱动 IO 中，当内核通知信号处理程序时，信号处理程序仍然需要阻塞在从内核空间缓冲区拷贝数据到用户空间缓存区这个阶段。而异步 IO 则是等IO 操作完成后，由内核告诉我们，可以进行下面的操作了。</li>
</ul>

<h1 id="channel">Channel</h1>

<p>基于原子函数和互斥锁都能工作，但是依靠它们都不会让编写并发程序变得更简单，更不容易出错，或者更有趣。
在 Go 语言里，你不仅可以使用原子函数和互斥锁来保证对共享资源的安全访问以及消除竞争状态，还可以使用通道，通过发送和接收需要共享的资源，在 goroutine 之间做同步。</p>

<p>当一个资源需要在 goroutine 之间共享时，通道在 goroutine 之间架起了一个管道，并提供了确保同步交换数据的机制。</p>

<h2 id="有缓冲的通道">有缓冲的通道</h2>

<p>有缓冲的通道(buffered channel)是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的 条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。</p>

<h2 id="无缓冲的通道">无缓冲的通道</h2>

<p>无缓冲的通道(unbuffered channel)是指在接收前没有能力保存任何值的通道。这种类型的通 道要求发送 goroutine 和接收 goroutine 同时准备好，才能完成发送和接收操作。如果两个 goroutine 没有同时准备好，通道会导致先执行发送或接收操作的 goroutine 阻塞等待。这种对通道进行发送 和接收的交互行为本身就是同步的。其中任意一个操作都无法离开另一个操作单独存在。</p>

<h2 id="有无缓冲的区别">有无缓冲的区别</h2>

<p>有缓冲的通道和无缓冲的通道之间的一个很大的不同，那就是无缓冲的通道保证进行发送和接收的 goroutine 会在同一时间进行数据交换，而有缓冲的通道没有这种保证。
以缓冲为1为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// 无缓冲的整型通道
unbuffered := make(chan int)
unbuffered &lt;- 1
fmt.Printf(&#34;ok&#34;)</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// 有缓冲的通道
buffered := make(chan int, 1)
buffered &lt;- 1
fmt.Printf(&#34;ok&#34;)</code></pre></td></tr></table>
</div>
</div>
<p>对比两段代码，即可发现，对于无缓冲的通道，由于没有接收方，所以会一直阻塞等待，并不会运行到 “ok”；
而有缓冲的通道，由于有缓冲区的存在，则不会阻塞，可以直接运行下一句并打印出 “ok”</p>

<h1 id="小结">小结</h1>

<ul>
<li>并发是指 goroutine 运行的时候是相互独立的。</li>
<li>使用关键字 go 创建 goroutine 来运行函数。</li>
<li>goroutine 在逻辑处理器上执行，而逻辑处理器具有独立的系统线程和运行队列。</li>
<li>竞争状态是指两个或者多个 goroutine 试图访问同一个资源。</li>
<li>原子函数和互斥锁提供了一种防止出现竞争状态的办法。</li>
<li>通道提供了一种在两个 goroutine 之间共享数据的简单方法。</li>
<li>无缓冲的通道保证同时交换数据，而有缓冲的通道不做这种保证。</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/golang/" term="Golang" label="Golang" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/golang/" term="Golang" label="Golang" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">程序员进化之路-技术提升</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF-%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/" />
            <id>https://blog.vgmdj.cn/posts/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%BF%9B%E5%8C%96%E4%B9%8B%E8%B7%AF-%E6%8A%80%E6%9C%AF%E6%8F%90%E5%8D%87/</id>
            <updated>2018-03-31T23:53:58+00:00</updated>
            <published>2018-03-31T23:18:51+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[前言 不知不觉已经毕业快两年了，但是感觉现在的实力还是很差，仍然需要不停的学习，锻炼。 而要想快速进步，一个明确的大目标和一个个细化的小目标是必不可少的，经历了一段时间的探索，目前来讲，个人职业发展的规划很简单，紧抱google大腿，以go为主开发语言，在后端领域扑腾，专注web开发100年。 那么修炼之路也就很明确了。]]></summary>
            
                <content type="html"><![CDATA[<h1 id="前言">前言</h1>

<p>不知不觉已经毕业快两年了，但是感觉现在的实力还是很差，仍然需要不停的学习，锻炼。
而要想快速进步，一个明确的大目标和一个个细化的小目标是必不可少的，经历了一段时间的探索，目前来讲，个人职业发展的规划很简单，紧抱google大腿，以go为主开发语言，在后端领域扑腾，专注web开发100年。
那么修炼之路也就很明确了。</p>

<h1 id="基础">基础</h1>

<h2 id="数据结构-算法">数据结构 + 算法</h2>

<ul>
<li><p>算法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">对于以下算法无变形基本问题可以做到手写无误
二分搜索 Binary Search
分治 Divide Conquer
宽度优先搜索 Breadth First Search
深度优先搜索 Depth First Search
回溯法 Backtracking
双指针 Two Pointers
动态规划 Dynamic Programming
扫描线 Scan-line algorithm
快排 Quick Sort</code></pre></td></tr></table>
</div>
</div></li>

<li><p>数据结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">栈 Stack
队列 Queue
链表 Linked List
数组 Array
哈希表 Hash Table
二叉树 Binary Tree  
堆 Heap
并查集 Union Find
字典树 Trie</code></pre></td></tr></table>
</div>
</div></li>

<li><p>练习方式： leetcode</p></li>
</ul>

<h2 id="操作系统">操作系统</h2>

<ul>
<li>书籍：

<ul>
<li>《鸟哥的linux私房菜》</li>
</ul></li>
</ul>

<h2 id="网络">网络</h2>

<ul>
<li>书籍：

<ul>
<li>《计算机网络-自顶向下》</li>
<li>《http权威指南》</li>
<li>《https权威指南》</li>
</ul></li>
</ul>

<h1 id="golang">golang</h1>

<h2 id="源码学习">源码学习</h2>

<h2 id="设计理念">设计理念</h2>

<ul>
<li>并发处理模型</li>
<li>gc原理</li>
</ul>

<p>书籍：</p>

<ul>
<li>《深入解析go》</li>
<li>《go语言学习笔记》</li>
<li>《go并发编程实战》</li>
</ul>

<h1 id="数据库">数据库</h1>

<h2 id="基本设计与操作">基本设计与操作</h2>

<h2 id="性能优化">性能优化</h2>

<h2 id="底层结构-索引">底层结构（索引）</h2>

<p>书籍：</p>

<ul>
<li>《高性能MySQL》</li>
<li>《MySQL必知必会》</li>
<li>《Redis实战》</li>
</ul>

<h1 id="消息队列">消息队列</h1>

<ul>
<li>rabbitmq</li>
<li>zookeeper</li>
</ul>

<h1 id="设计模式">设计模式</h1>

<p>书籍：</p>

<ul>
<li>《大话设计模式》</li>
<li>《设计模式之禅》</li>
</ul>

<h1 id="基础工具">基础工具</h1>

<h2 id="git">git</h2>

<ul>
<li><a href="https://github.com/livoras/blog/issues/7#issue-105082853" target="_blank">https://github.com/livoras/blog/issues/7#issue-105082853</a></li>
</ul>

<h1 id="分布式系统">分布式系统</h1>

<ul>
<li>docker</li>
<li>k8s</li>
</ul>

<h1 id="架构能力">架构能力</h1>

<p>书籍：</p>

<ul>
<li>《亿级流量网站架构》</li>
<li>《微服务设计》</li>
<li>《图解服务器端网络架构》</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/" term="职业发展" label="职业发展" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/" term="职业发展" label="职业发展" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">go语言学习-interface</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-interface/" />
            <id>https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-interface/</id>
            <updated>2018-05-21T15:27:15+00:00</updated>
            <published>2018-03-30T15:41:12+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[前言 跳槽季，同事离职后接手他代码，发现了一些自定义error的小问题，在这里做个记录总结。]]></summary>
            
                <content type="html"><![CDATA[<h1 id="前言">前言</h1>

<p>跳槽季，同事离职后接手他代码，发现了一些自定义error的小问题，在这里做个记录总结。</p>

<h1 id="interface">interface</h1>

<p>interface是一组method签名的组合，通过interface我们可以定义对象的一组行为。
实现这一组行为的类的对象，同属于该interface类型。通过这一特性，可以使面向对象和内容组织的实现变得非常方便。</p>

<h1 id="interface的使用">interface的使用</h1>

<p>interface在go的设计模式中被大量使用，可以在 <a href="/tags/设计模式/">golang设计模式</a> 中查看更多内容
下面是一个小例子，Ti是interface, Ts1和Ts2都实现了Ti，New()函数根据输入值返回Ti，这样我们在使用Ti时，只用关注它的函数，而不用去管其中具体是怎么实现的，有利于模块间的充分解耦</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">type Ti interface {
	SetValue(value int)
	Test()
}

type Ts1 struct {
	Value int
}

func (ts *Ts1) SetValue(value int) {
	ts.Value = value + 1
}

func (ts *Ts1) Test() {
	fmt.Printf(&#34;ts1&#39;s value is %d\n&#34;, ts.Value)
}

type Ts2 struct {
	Value int
}

func (ts *Ts2) SetValue(value int) {
	ts.Value = value + 2
}

func (ts *Ts2) Test() {
	fmt.Printf(&#34;ts2&#39;s value is %d\n&#34;, ts.Value)
}

func New(tn int) Ti {
	switch tn {
	default:
		return nil
	case 1:
		return new(Ts1)
	case 2:
		return new(Ts2)

	}
}

func main() {
  //t1 use New() Ti to create Ts1
  	t1 := New(1)
  	t1.SetValue(3)
  	t1.Test()

  //t2 use New() Ti to create Ts2
  	t2 := New(2)
  	t2.SetValue(2)
  	t2.Test()
}</code></pre></td></tr></table>
</div>
</div>
<h1 id="interface的底层结构">interface的底层结构</h1>

<p>interface并不是一个指针，它的底层实现由两部分组成，一个是类型，一个值，也就是类似于：(Type, Value)。只有当类型和值都是nil，即interface为 (nil,nil) 的时候，才等于nil。
所以interface与nil判断的时候，要先判断是否是interface类型，再判断interface的类型和值是什么。有点拗口，接下来判断时，interface类型就是interface，interface的值就以(type, value)来表示</p>

<h1 id="interface的nil">interface的nil</h1>

<p>我们使用 &ldquo;==&rdquo; 来判断两个对象是否相等，如果 &ldquo;==&rdquo; 的结果为true， 那么我们就认为两对象类型相同且值相等，一般情况下，两类型不同的对象间不能进行比较
那么，如果类型为interface时， &ldquo;==&rdquo; 的判断，会出现什么情况呢</p>

<h2 id="普通比较判断">普通比较判断</h2>

<blockquote>
<p>fmt.Println(t1 == t2, t1.(*Ts1).Value == t2.(*Ts2).Value)</p>
</blockquote>

<p>结果为 false , true。 这点很好理解，因为t1和t2的类型不同，一个是Ts1，一个是Ts2
这就下面代码性质差不多，只不过下面这样写编译会出错，提示类型不同，不能进行比较</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">tt1 := new(Ts1)
tt2 := new(Ts2)
fmt.Println(tt1 == tt2)</code></pre></td></tr></table>
</div>
</div>
<h2 id="有interface与nil参与的时候">有interface与nil参与的时候</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func NewTs1() *Ts1 {
	return nil
}</code></pre></td></tr></table>
</div>
</div>
<p>创建一个新函数，用于返回*Ts1类型的nil，上面的New()函数在使用&rsquo;3&rsquo;作为输入时，返回的是Ti类型的(nil,nil)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">	//t use New() Ti to create (nil,nil)
	t := New(3)
	fmt.Println(t == nil)

	//t use NewTs1() *Ts1 to make t = nil, now t Ti = (*Ts1,nil)
	t = NewTs1()
	fmt.Println(t == nil)

	//ts use NewTs1() *Ts1 to create nil, not interface type *Ts1, value nil
	ts := NewTs1()
	fmt.Println(ts == nil)</code></pre></td></tr></table>
</div>
</div>
<p>t第一次赋值后，t与nil比较时，t的类型是Ti - interface类型，值为(nil,nil)
第二次赋值后，t与nil比较时,t的类型还是Ti，值是指向了*Ts1类型的nil，即(*Ts1, nil)，所以不相等
ts与nil比较时，ts类型是*Ts1，值为nil
注意，这里的ts不是interface类型，而是实现了interface的*Ts1类型</p>

<p>实际上第二次赋值后的t就相当于这里的tis</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  var tis Ti            //类型是Ti， interface
	var ts1 *Ts1 = nil    
	tis = ts1            //值是ts1，ts1是*Ts1类型，值是nil</code></pre></td></tr></table>
</div>
</div>
<blockquote>
<p>fmt.Println(tis,tis == nil) //nil, false
fmt.Println(tis == t)  //true</p>
</blockquote>

<h1 id="实例-自定义error">实例-自定义error</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">type MsgError struct{}

func (msgErr *MsgError) Error() string {
	return &#34;err&#34;
}

func NewError() error {
	var err *MsgError = nil
	if false {
		return &amp;MsgError{}
	}

	return err
}

func main() {
	err := NewError()
	if err != nil{
		fmt.Println(err.Error())
		return
	}

}</code></pre></td></tr></table>
</div>
</div>
<p>这时，err怎么都不会与nil相等，因为类型是error，值是(*MsgError,nil)，nil是(nil，nil)
同样的错误，不同的写法还有</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func NewErr()*MsgError{
	return nil
}

func main() {
	err := errors.New(&#34;errors&#34;)

	err = NewErr()
	if err != nil{
		fmt.Println(err.Error())
		return
	}

}</code></pre></td></tr></table>
</div>
</div>
<h1 id="完整的代码例子">完整的代码例子</h1>

<p>interface</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>

<span class="kd">type</span> <span class="nx">Ti</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">SetValue</span><span class="p">(</span><span class="nx">value</span> <span class="kt">int</span><span class="p">)</span>
	<span class="nf">Test</span><span class="p">(</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Ts1</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Value</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ts</span> <span class="o">*</span><span class="nx">Ts1</span><span class="p">)</span> <span class="nf">SetValue</span><span class="p">(</span><span class="nx">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ts</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">value</span> <span class="o">+</span> <span class="mi">1</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ts</span> <span class="o">*</span><span class="nx">Ts1</span><span class="p">)</span> <span class="nf">Test</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;ts1&#39;s value is %d\n&#34;</span><span class="p">,</span> <span class="nx">ts</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Ts2</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">Value</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ts</span> <span class="o">*</span><span class="nx">Ts2</span><span class="p">)</span> <span class="nf">SetValue</span><span class="p">(</span><span class="nx">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">ts</span><span class="p">.</span><span class="nx">Value</span> <span class="p">=</span> <span class="nx">value</span> <span class="o">+</span> <span class="mi">2</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">ts</span> <span class="o">*</span><span class="nx">Ts2</span><span class="p">)</span> <span class="nf">Test</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;ts2&#39;s value is %d\n&#34;</span><span class="p">,</span> <span class="nx">ts</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">tn</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">Ti</span> <span class="p">{</span>
	<span class="k">switch</span> <span class="nx">tn</span> <span class="p">{</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="k">return</span> <span class="kc">nil</span>
	<span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
		<span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Ts1</span><span class="p">)</span>
	<span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
		<span class="k">return</span> <span class="nb">new</span><span class="p">(</span><span class="nx">Ts2</span><span class="p">)</span>

	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewTs1</span><span class="p">(</span><span class="p">)</span> <span class="o">*</span><span class="nx">Ts1</span> <span class="p">{</span>
	<span class="k">return</span> <span class="kc">nil</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">//t1 use New() Ti to create Ts1
</span><span class="c1"></span>	<span class="nx">t1</span> <span class="o">:=</span> <span class="nf">New</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
	<span class="nx">t1</span><span class="p">.</span><span class="nf">SetValue</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
	<span class="nx">t1</span><span class="p">.</span><span class="nf">Test</span><span class="p">(</span><span class="p">)</span>      <span class="c1">//ts1&#39;s value is 4
</span><span class="c1"></span>
	<span class="c1">//t2 use New() Ti to create Ts2
</span><span class="c1"></span>	<span class="nx">t2</span> <span class="o">:=</span> <span class="nf">New</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="nx">t2</span><span class="p">.</span><span class="nf">SetValue</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
	<span class="nx">t2</span><span class="p">.</span><span class="nf">Test</span><span class="p">(</span><span class="p">)</span>      <span class="c1">//ts2&#39;s value is 4
</span><span class="c1"></span>
	<span class="c1">//t1 == t2 t1.Value == t2.Value
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t1</span> <span class="o">==</span> <span class="nx">t2</span><span class="p">,</span> <span class="nx">t1</span><span class="p">.</span><span class="p">(</span><span class="o">*</span><span class="nx">Ts1</span><span class="p">)</span><span class="p">.</span><span class="nx">Value</span> <span class="o">==</span> <span class="nx">t2</span><span class="p">.</span><span class="p">(</span><span class="o">*</span><span class="nx">Ts2</span><span class="p">)</span><span class="p">.</span><span class="nx">Value</span><span class="p">)</span>      <span class="c1">//false true
</span><span class="c1"></span>
	<span class="c1">//tt1 := new(Ts1)
</span><span class="c1"></span>	<span class="c1">//tt2 := new(Ts2)
</span><span class="c1"></span>	<span class="c1">//fmt.Println(tt1 == tt2)    //invalid operation: tt1 == tt2 (mismatched types *Ts1 and *Ts2)
</span><span class="c1"></span>
	<span class="c1">//t use New() Ti to create nil
</span><span class="c1"></span>	<span class="nx">t</span> <span class="o">:=</span> <span class="nf">New</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>      <span class="c1">//true
</span><span class="c1"></span>
	<span class="c1">//t use NewTs1() *Ts1 to make t = nil
</span><span class="c1"></span>	<span class="nx">t</span> <span class="p">=</span> <span class="nf">NewTs1</span><span class="p">(</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="p">(</span><span class="o">*</span><span class="nx">Ts1</span><span class="p">)</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>     <span class="c1">//false, true
</span><span class="c1"></span>
	<span class="kd">var</span> <span class="nx">tis</span> <span class="nx">Ti</span>
	<span class="kd">var</span> <span class="nx">ts1</span> <span class="o">*</span><span class="nx">Ts1</span> <span class="p">=</span> <span class="kc">nil</span>
	<span class="nx">tis</span> <span class="p">=</span> <span class="nx">ts1</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">tis</span><span class="p">,</span> <span class="nx">tis</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">t</span> <span class="o">==</span> <span class="nx">tis</span><span class="p">)</span>     <span class="c1">//nil, false, true
</span><span class="c1"></span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h1 id="参考资料">参考资料</h1>

<ul>
<li><a href="https://golang.org/doc/faq#nil_error" target="_blank">https://golang.org/doc/faq#nil_error</a></li>
<li><a href="https://my.oschina.net/goal/blog/194233?p=2&amp;temp=1526895266744" target="_blank">https://my.oschina.net/goal/blog/194233?p=2&amp;temp=1526895266744</a></li>
<li><a href="https://my.oschina.net/chai2010/blog/117923" target="_blank">https://my.oschina.net/chai2010/blog/117923</a></li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/golang/" term="Golang" label="Golang" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/golang/" term="Golang" label="Golang" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">go语言学习-map</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-map/" />
            <id>https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-map/</id>
            <updated>2018-03-30T15:23:58+00:00</updated>
            <published>2018-03-30T13:23:51+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[环境 go版本 1.10
Map go语言中的map类型底层使用的是链式哈希表结构,且go中的map非线程安全，不能放在多个goroutine中，只能自己维护线程安全。 如果想要线程安全的 map，可以使用sync 包里的 Map 。]]></summary>
            
                <content type="html"><![CDATA[<h2 id="环境">环境</h2>

<p>go版本 1.10</p>

<h2 id="map">Map</h2>

<p>go语言中的map类型底层使用的是链式哈希表结构,且go中的map非线程安全，不能放在多个goroutine中，只能自己维护线程安全。
如果想要线程安全的 map，可以使用sync 包里的 Map 。</p>

<h2 id="go-map一般操作">go map一般操作</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">//创建map
a := make(map[string]string)
//存入
a[&#34;first&#34;] = &#34;first&#34;
//读取
fmt.Println(a[&#34;first&#34;])</code></pre></td></tr></table>
</div>
</div>
<p>需要注意的是，并不是所有的类型都可以作为key值，在Go的语言规范中已精确定义，只有能比较是否相等的类型才可以作为key值，key的类型可以是：
- 布尔值
- 数字
- 字符串
- 指针
- 通道
- 接口类型
- 结构体</p>

<p>只包含上述类型的数组。
不能是：
- slice
- map
- function
Key类型只要能支持==和!=操作符，即可以做为Key，当两个值==时，则认为是同一个Key。</p>

<h2 id="go-map并发线程操作">go map并发线程操作</h2>

<ul>
<li><p>结构</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">var counter = struct{
sync.RWMutex
m map[string]int
}{m: make(map[string]int)}</code></pre></td></tr></table>
</div>
</div></li>

<li><p>读</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">counter.RLock()
n := counter.m[&#34;some_key&#34;]
counter.RUnlock()
fmt.Println(&#34;some_key:&#34;, n)</code></pre></td></tr></table>
</div>
</div></li>

<li><p>写</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">counter.Lock()
counter.m[&#34;some_key&#34;]++
counter.Unlock()</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h2 id="go-map的遍历">go map的遍历</h2>

<p>go语言中map存放是无序的，即如果对一个map进行输出，其并不会按照输入的顺序，而是随机的
那么如果想要实现map的一个有序的输出，就需要指定一组确立顺序的key</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">import &#34;sort&#34;

var m map[int]string
var keys []int
for k := range m {
    keys = append(keys, k)
}
sort.Ints(keys)
for _, k := range keys {
    fmt.Println(&#34;Key:&#34;, k, &#34;Value:&#34;, m[k])
}</code></pre></td></tr></table>
</div>
</div>
<h2 id="go-map结构">go map结构</h2>

<p>map实现可在/runtime/hashmap.go里查看</p>

<h3 id="header">header</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// A header for a Go map.
type hmap struct {
	// Note: the format of the Hmap is encoded in ../../cmd/internal/gc/reflect.go and
	// ../reflect/type.go. Don&#39;t change this structure without also changing that code!
	count     int // # live cells == size of map.  Must be first (used by len() builtin)
	flags     uint8
	B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
	noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
	hash0     uint32 // hash seed

	buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
	oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
	nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)

	extra *mapextra // optional fields
}</code></pre></td></tr></table>
</div>
</div>
<ul>
<li>count 提供给len()使用，用来记录map的大小，可以统计kv对的个数</li>
<li>B map的容量，表示当前可以放入 loadFactor * 2^B 个item，2^B 即为buckets的数量</li>
<li>buckets 桶，指向实际存储空间</li>
<li>oldbuckets 只有在扩容时使用，其余情况下为空。如果当前哈希表正在扩容中，则oldbuckets不为空，并且buckets大小是oldbuckets大小的两倍。</li>
<li>noverflow 溢出桶的大小</li>
</ul>

<p>由注释我们可以看到，这是Go map的header，map类型就是一个hash表的结构，数据被发放进buckets数组中，每个bucket包含有8个键值对，当溢出时，将再生成一个bucket，并将之链接到之前的bucket上</p>

<h3 id="bucket">bucket</h3>

<p>这里是map中每个bucket的结构，可以看出，是一个 8个单位长度的uint8数组</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// A bucket for a Go map.
type bmap struct {
	// tophash generally contains the top byte of the hash value
	// for each key in this bucket. If tophash[0] &lt; minTopHash,
	// tophash[0] is a bucket evacuation state instead.
	tophash [bucketCnt]uint8
	// Followed by bucketCnt keys and then bucketCnt values.
	// NOTE: packing all the keys together and then all the values together makes the
	// code a bit more complicated than alternating key/value/key/value/... but it allows
	// us to eliminate padding which would be needed for, e.g., map[int64]int8.
	// Followed by an overflow pointer.
}</code></pre></td></tr></table>
</div>
</div>
<p>bucketCnt 定义</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">const(
  // Maximum number of key/value pairs a bucket can hold.
  	bucketCntBits = 3
  	bucketCnt     = 1 &lt;&lt; bucketCntBits
)</code></pre></td></tr></table>
</div>
</div>
<p>可以从tophash的注释中看出，这里的key value存入顺序，不是key/value/key/value/&hellip; ， 而是key/key/key/key/value/value/value/value，这是因为考虑到map[int64]int8这种情况，存在64和8两种大小，考虑到字节对齐，会浪费很多存储空间</p>

<h2 id="map-操作解析">map 操作解析</h2>

<h3 id="确定buckets">确定buckets</h3>

<p>hash表的bucket确定方式，一般为key值求hash后，用hash值对总的buckets数取余，即hash mod (2^B)，可优化为以下操作</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// bucketShift returns 1&lt;&lt;b, optimized for code generation.
func bucketShift(b uint8) uintptr {
	if sys.GoarchAmd64|sys.GoarchAmd64p32|sys.Goarch386 != 0 {
		b &amp;= sys.PtrSize*8 - 1 // help x86 archs remove shift overflow checks
	}
	return uintptr(1) &lt;&lt; b
}

// bucketMask returns 1&lt;&lt;b - 1, optimized for code generation.
func bucketMask(b uint8) uintptr {
	return bucketShift(b) - 1
}

h *hmap
hash % (1 &lt;&lt; h.B)
=&gt; hash &amp; bucketMask(h.B)</code></pre></td></tr></table>
</div>
</div>
<h3 id="增量扩容">增量扩容</h3>

<p>为什么会增量扩容呢？主要是缩短map容器的响应时间。假如我们直接将map用作某个响应实时性要求非常高的web应用存储，如果不采用增量扩容，当map里面存储的元素很多之后，扩容时系统就会卡往，导致较长一段时间内无法响应请求。不过增量扩容本质上还是将总的扩容时间分摊到了每一次哈希操作上面。
扩容会建立一个大小是原来2倍的新的表，将旧的bucket搬到新的表中之后，并不会将旧的bucket从oldbucket中删除，而是加上一个已删除的标记。
正是由于这个工作是逐渐完成的，这样就会导致一部分数据在old table中，一部分在new table中， 所以对于hash table的insert, remove, lookup操作的处理逻辑产生影响。只有当所有的bucket都从旧表移到新表之后，才会将oldbucket释放掉。
扩容的填充因子是多少呢？如果grow的太频繁，会造成空间的利用率很低， 如果很久才grow，会形成很多的overflow buckets，查找的效率也会下降。 这个平衡点如何选取呢(在go中，这个平衡点是有一个宏控制的(#define LOAD 6.5), 它的意思是这样的，如果table中元素的个数大于table中能容纳的元素的个数， 那么就触发一次grow动作。那么这个6.5是怎么得到的呢？原来这个值来源于作者的一个测试程序，遗憾的是没能找到相关的源码，不过作者给出了测试的结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// Maximum average load of a bucket that triggers growth is 6.5.
// Represent as loadFactorNum/loadFactDen, to allow integer math.
	loadFactorNum = 13
	loadFactorDen = 2</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Picking loadFactor: too large and we have lots of overflow
buckets, too small and we waste a lot of space. I wrote
a simple program to check some stats for different loads:
(64-bit, 8 byte keys and values)
loadFactor    %overflow  bytes/entry     hitprobe    missprobe
      4.00         2.13        20.77         3.00         4.00
      4.50         4.05        17.30         3.25         4.50
      5.00         6.85        14.77         3.50         5.00
      5.50        10.55        12.94         3.75         5.50
      6.00        15.27        11.67         4.00         6.00
      6.50        20.90        10.79         4.25         6.50
      7.00        27.14        10.15         4.50         7.00
      7.50        34.03         9.73         4.75         7.50
      8.00        41.10         9.40         5.00         8.00

%overflow   = percentage of buckets which have an overflow bucket
bytes/entry = overhead bytes used per key/value pair
hitprobe    = # of entries to check when looking up a present key
missprobe   = # of entries to check when looking up an absent key

Keep in mind this data is for maximally loaded tables, i.e. just
before the table grows. Typical tables will be somewhat less loaded.</code></pre></td></tr></table>
</div>
</div>
<h3 id="增删改查">增删改查</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">未完待续</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/golang/" term="Golang" label="Golang" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/golang/" term="Golang" label="Golang" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">服务器安全防护</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4/" />
            <id>https://blog.vgmdj.cn/posts/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4/</id>
            <updated>2018-03-27T15:23:58+00:00</updated>
            <published>2018-03-27T13:23:51+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[服务器安全 一段时间没去打理我的服务器，只是搭个ss，当科学工具用，今天忽然收到服务商的电话，说是服务器上存在不合法行为，还吓我一跳，觉着现在都查这么严格，自建梯子都不行了。实际在管理平台上一看日志，才知道说是服务器存在安全问题，应该是已经被黑掉，在不停的试探别的ip的22端口，总计被监测到400多万次行为，看来当真是有挺长一段时间没管理了。。。
主要被攻击方式 从日志中可以看到，应该主要是扫描加暴力破解的方式，所以理所当然的应对手段就是，开启防火墙，改ssh端口，改mysql端口，开启安全组，之前是觉着被攻击的机率太低了，现在看来，再低机率也不应该懈怠]]></summary>
            
                <content type="html"><![CDATA[<h2 id="服务器安全">服务器安全</h2>

<p>一段时间没去打理我的服务器，只是搭个ss，当科学工具用，今天忽然收到服务商的电话，说是服务器上存在不合法行为，还吓我一跳，觉着现在都查这么严格，自建梯子都不行了。实际在管理平台上一看日志，才知道说是服务器存在安全问题，应该是已经被黑掉，在不停的试探别的ip的22端口，总计被监测到400多万次行为，看来当真是有挺长一段时间没管理了。。。</p>

<h2 id="主要被攻击方式">主要被攻击方式</h2>

<p>从日志中可以看到，应该主要是扫描加暴力破解的方式，所以理所当然的应对手段就是，开启防火墙，改ssh端口，改mysql端口，开启安全组，之前是觉着被攻击的机率太低了，现在看来，再低机率也不应该懈怠</p>

<h2 id="开启防火墙">开启防火墙</h2>

<h3 id="注意点">注意点</h3>

<ul>
<li>防火墙开启后，应该先打开相应端口</li>
<li>一旦出现问题，可以使用页面版的远程登录，进行逆操作恢复</li>
</ul>

<h3 id="ubuntu默认支持ufw防火墙">ubuntu默认支持ufw防火墙</h3>

<ul>
<li><p>开关服务</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">sudo ufw enable

关闭命令
sudo ufw disable</code></pre></td></tr></table>
</div>
</div></li>

<li><p>开关端口</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">开启 8080端口
sudo ufw allow 53

关闭 8080端口
sudo ufw deny 8080</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h3 id="centos-7-0默认使用的是firewall作为防火墙">CentOS 7.0默认使用的是firewall作为防火墙</h3>

<ul>
<li><p>开关服务</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">开启
sudo systemctl start firewalld.service

关闭
sudo systemctl stop firewalld.service

禁用
sudo systemctl disable firewalld.service</code></pre></td></tr></table>
</div>
</div></li>

<li><p>开关端口</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">查看状态
sudo firewall-cmd --state

查看端口
firewall-cmd --zone=public --list-ports

开放端口
firewall-cmd --zone=public --add-port=80/tcp --permanent

删除端口
firewall-cmd --zone= public --remove-port=80/tcp --permanent</code></pre></td></tr></table>
</div>
</div></li>

<li><p>更新状态</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">sudo firewall-cmd --reload</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h3 id="如果想使用iptables作为防火墙-需要配置一下">如果想使用iptables作为防火墙，需要配置一下</h3>

<ul>
<li><p>服务切换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">systemctl stop firewalld.service #停止firewall

systemctl disable firewalld.service #禁止firewall开机启动

systemctl restart iptables.service #重启防火墙使配置生效

systemctl enable iptables.service #设置防火墙开机启动

最后重启系统使设置生效即可</code></pre></td></tr></table>
</div>
</div></li>

<li><p>服务开关</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">开启
service iptables start

关闭
service iptables stop</code></pre></td></tr></table>
</div>
</div></li>

<li><p>永久开关</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">永久关闭防火墙:

chkconfig iptables off



永久关闭后启用:
chkconfig iptables on</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h2 id="修改ssh端口号">修改ssh端口号</h2>

<ul>
<li><p>修改/etc/ssh/sshd_config</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">去掉端口注释，并添加新端口
# Port 22
Port 222</code></pre></td></tr></table>
</div>
</div></li>

<li><p>重启服务</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">/etc/init.d/sshd restart
或
systemctl restart sshd</code></pre></td></tr></table>
</div>
</div></li>

<li><p>测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ssh -p 222 ip</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h2 id="关闭密码登录">关闭密码登录</h2>

<ul>
<li><p>修改/etc/ssh/sshd_config</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 以下两项设置允许使用常用客户端免密登录
RSAAuthentication yes           #开启rsa验证
PubkeyAuthentication yes        #开启公钥验证

# 允许root账户登录
PermitRootLogin yes

# 不允许密码登录
PasswordAuthentication no</code></pre></td></tr></table>
</div>
</div></li>

<li><p>重启服务</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">/etc/init.d/sshd restart</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h2 id="关闭不需要的服务和端口">关闭不需要的服务和端口</h2>

<p>服务器操作系统在安装时，会启动一些不需要的服务，这样会占用系统的资源，而且也会增加系统的安全隐患。对于一段时间内完全不会用到的服务器，可以完全关闭;对于期间要使用的服务器，也应该关闭不需要的服务，如Telnet等。另外，还要关掉没有必要开的TCP端口。</p>

<h2 id="自定义端口">自定义端口</h2>

<p>不使用默认的端口，而是使用自定义的端口号
如：</p>

<ul>
<li>mysql 3306 =&gt; 6033</li>
<li>rabbit 5672 =&gt; 2765</li>
<li>redis 6379 =&gt; 9736</li>
</ul>

<blockquote>
<p>端口映射只是举例，应以自己实际情况为准</p>
</blockquote>

<h2 id="定期对服务器进行备份">定期对服务器进行备份</h2>

<p>为防止不能预料的系统故障或用户不小心的非法操作，必须对系统进行安全备份。除了对全系统进行每月一次的备份外，还应对修改过的数据进行每周一次的备份。同时，应该将修改过的重要系统文件存放在不同服务器上，以便出现系统崩溃时(通常是硬盘出错)，可以及时地将系统恢复到正常状态。</p>

<h2 id="监测系统日志">监测系统日志</h2>

<p>通过运行系统日志程序，系统会记录下所有用户使用系统的情形，包括最近登录时间、使用的账号、进行的活动等。日志程序会定期生成报表，通过对报表进行分析，可以知道是否有异常现象。</p>

<h2 id="修改安全组策略">修改安全组策略</h2>

<ul>
<li>限制对外开放端口</li>
<li>限制来访问ip</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E7%AB%99%E7%82%B9%E5%BB%BA%E8%AE%BE/" term="站点建设" label="站点建设" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AE%89%E5%85%A8/" term="安全" label="安全" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">mysql学习-事务</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/mysql%E5%AD%A6%E4%B9%A0-%E4%BA%8B%E5%8A%A1/" />
            <id>https://blog.vgmdj.cn/posts/mysql%E5%AD%A6%E4%B9%A0-%E4%BA%8B%E5%8A%A1/</id>
            <updated>2018-03-22T17:23:50+00:00</updated>
            <published>2018-03-22T15:23:50+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[定义 事务(transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。同时，事务也是恢复和并发控制的基本单位。
事务特性(acid) 四大特性  原子性(atomicity) 原子性是指事务包含的所有操作要么全部操作，要么全部不做，事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。
 一致性(consistency) 一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。 拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性
 隔离性(isolation) 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。 即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
 持久性(durability) 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。]]></summary>
            
                <content type="html"><![CDATA[<h1 id="定义">定义</h1>

<p>事务(transaction)是用户定义的一个数据库操作序列，这些操作要么全做，要么全不做，是一个不可分割的工作单位。同时，事务也是恢复和并发控制的基本单位。</p>

<h1 id="事务特性-acid">事务特性(acid)</h1>

<h2 id="四大特性">四大特性</h2>

<ul>
<li><p>原子性(atomicity)
　原子性是指事务包含的所有操作要么全部操作，要么全部不做，事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p></li>

<li><p>一致性(consistency)
一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性</p></li>

<li><p>隔离性(isolation)
隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。</p></li>

<li><p>持久性(durability)
持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p></li>
</ul>

<h2 id="区分数据库的原子性和一致性">区分数据库的原子性和一致性</h2>

<p>如果从逻辑设计上，A转账给B 1000元，那么A扣1000,B加1000，这个转账操作起码要有两个事务：</p>

<p>1、查A现有账户，然后扣1000,更新A账户（A=A-1000）</p>

<p>2、查B现有账户，然后加1000,更新B账户 (B=B+1000)</p>

<p>原子性是说，如果提交时，1,2都操作了，要么成功，要么失败回滚
而所谓的一致性，一定是两个结果的比较，才能有是否 <strong>一致</strong> 一说，更多的体现的是预期的结果和数据库最终结果是否是一致的。</p>

<ul>
<li>如果把事务开始前和事务完成后称为一致性状态，1，2语句后但未进行提交时，崩溃了，那么此时全未提交，仍满足原子性，数据库会放弃未提交的事务，以满足一致性，让数据库中实际数据和预期的结果（未执行到提交成功）一致</li>
<li>而如果在提交成功后，还未来得及由脏页刷回磁盘就发生故障，那么如果没有任何机制，预期结果（成功提交）和实际数据就会不一致，所以数据库就会使用redo log file进行恢复，以使预期和数据库数据一致，来满足一致性</li>
<li>如果对于A=A-1000操作而言，先读A的值，再进行计算减1000后的值，再更新A为计算后的值，如果没有任何机制，在计算前发生了一个更新操作，在执行更新A=A-1000后，这个更新就会被覆盖，所以会有不同的隔离级别来保证结果符合预期。</li>
</ul>

<h1 id="mysql日志">mysql日志</h1>

<p>在mysql中有重做日志（redo log）、回滚日志（undo log）、二进制日志（binlog）、错误日志（errorlog）、慢查询日志（slow query log）、一般查询日志（general log），中继日志（relay log）六种。而在与事务息息相关的是redo log， undo log, 正确的理解这两种log，对于理解事务的有着很大的帮助。</p>

<h2 id="redo-log">redo log</h2>

<p>持久性要求只要事务提交，那么数据库中的改变就是永久的。在mysql中是使用redo log（重做日志）实现事务的持久性，即事务ACID中的D。</p>

<p>redo log 由两部分组成，一是内存中的重做日志缓冲（redo log buffer），其是易失的。二是重做日志文件（redo log file），其是持久的。</p>

<p>redo log file的写入规则有三种，
- Master Thread 每秒一次执行刷新log buffer到redo log file
- 事务在提交时，执行刷新
- 当buffer可用空间少于一半时，进行刷新</p>

<p>对应到一个事务的流程中，就是在事务开始时，会先将每一个操作都提交到redo log buffer中，事务过程中，buffer中的内容可能会在Master Thread刷新时或者由于buffer空间减小到一半时刷新入redo log file中。在最终提交时，会确认将所有的操作写入到redo log file中，再修改内存数据页，形成脏页，由后台慢慢刷回到磁盘中，并更新刷入点（Checkpoint），这就是所谓的预写式日志（Write-Ahead Logging）。</p>

<p>在发生故障时，会重新生成Checkpoint后的脏页，再等待慢慢刷回磁盘</p>

<h2 id="undo-log">undo log</h2>

<p>undo log用于回滚,其实现方式为，在事务执行之前，先保留一份原始数据存进undo log里，如果数据修改过程中出现异常，那么就会使用undo log实现回滚操作，以保证数据的一致性</p>

<h1 id="事务隔离">事务隔离</h1>

<h2 id="事务的四大隔离等级">事务的四大隔离等级</h2>

<ul>
<li><p>Read uncommitted (未提交读)：最低级别，任何情况都无法保证
如果一个事务已经开始写数据，则另外一个事务不能同时进行写操作，但允许其他事务读此行数据。即事务中的修改，即使没有提交，对其他事务也都是可见的。
这样就避免了更新丢失，却可能出现脏读，因为修改的事务也许在提交前还会有其他的很多修改，所以另一个事务的数据读取会错乱。
从性能上讲，read uncommitted并没有比其他的三个级别好太多，但却缺少其他隔离级别带来的好处，所以除非是有真的要使用的理由，在实际应用中一般不使用。</p></li>

<li><p>Read committed (提交读)：可避免脏读的发生
一个事务开始时，只能读到已经提交的事务所做的修改。即，一个事务从开始到提交之前所做的修改，对其他事务而言，都是不可见的。
该隔离级别避免了脏读，但是却可能出现不可重复读，即两个事务同时开启，事务A读取数据后，事务B对数据进行修改后提交，事务A再次读取，会发现跟前一次读取的内容不一样了
read committed, 也被称为 unrepeatable read是大多数数据库默认的隔离级别</p></li>

<li><p>Repeatable read (可重复读)：可避免脏读、不可重复读的发生
同一个事务多次读取的同一个记录，结果是一样的。这时读取的应该是一开始保留下来的快照。
读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。这样避免了不可重复读取和脏读，但是有时可能出现幻象读。
repeatable read 是mysql的默认隔离级别</p></li>

<li><p>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生
两个事务完全独立，其中一个事务做的操作，对于另外一个事务不产生任何影响
数据库事务加了锁，所有事务串行执行，避免了上述所有问题，但是性能上影响很大</p></li>
</ul>

<h2 id="并发下事务可能出现的问题">并发下事务可能出现的问题</h2>

<p>在多个事务并发做数据库操作的时候，如果没有有效的避免机制，就会出现种种问题。</p>

<ul>
<li><p>1、丢失更新
两个不同事务同时获得相同数据，然后在各自事务中同时修改了该数据，那么先提交的事务更新会被后提交事务的更新给覆盖掉，那么先提交的更新就会被丢失掉</p></li>

<li><p>2、脏读（未提交读）
事务A读取了未提交的数据，事务B的回滚，导致了事务A的数据不一致，导致了事务A的脏读</p></li>

<li><p>3、不可重复读
一个事务在自己没有更新数据库数据的情况，同一个查询操作执行两次或多次的结果应该是一致的；如果不一致，就说明为不可重复读。
如果事务A读取第一次后，事务B对数据进行修改并提交，事务A再次读取后，数据就会不一致</p></li>

<li><p>4、 幻读（Phantom Read）
事务A读的时候读出了15条记录，事务B在事务A执行的过程中增加了1条，事务A再读的时候就变成了16条，这种情况就叫做幻影读。
幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。</p></li>
</ul>

<h2 id="隔离级别的例子">隔离级别的例子</h2>

<p>现在有一个数据项X，执行以下操作
1、事务B一直对其进行读操作
2、事务A将其从1依次改到10
3、事务C将其从10依次改到20
4、事务B结束读操作</p>

<p>那么不同隔离级别下，去除重复值后，B所能看到的为：</p>

<ul>
<li>read uncommitted下： 1～20</li>
<li>read committed下: 1,10,20</li>
<li>repeatable read下： 1</li>
<li>serializable下： 因B操作未提交，所以无法按照以上顺序执行</li>
</ul>

<p>总的来说，事务隔离级别越高，越能保证数据的完整性和一致性，但是付出的代价却是并发的性能。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/database/" term="database" label="database" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/database/" term="database" label="database" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/mysql/" term="mysql" label="mysql" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">mysql学习-锁</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/mysql%E5%AD%A6%E4%B9%A0-%E9%94%81/" />
            <id>https://blog.vgmdj.cn/posts/mysql%E5%AD%A6%E4%B9%A0-%E9%94%81/</id>
            <updated>2018-04-23T17:21:51+00:00</updated>
            <published>2018-03-22T11:22:49+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[锁 并发任务的顺序实现，最终还是要落到锁上，由锁来控制实现。
 根据锁的粒度划分，有行级锁，表级锁，页级锁三种
 根据锁的类型划分，可以分为共享锁，互拆锁
 根据锁的并发控制方式来划分，可以分为悲观锁和乐观锁，当然这种划分主要是从应用层面上来讲的
  表级锁 表锁是MySQL中最基本的锁策略，并且是开销最小的策略。使用表锁，在使用前会锁定整张锁，在对表中信息进行更改（增加、删除、修改）时，会先去获得写锁，其他对于表的锁的获取都会被阻塞。另外，写锁比读锁有更高的优先级，所以在一个写锁可能被插入到所有读锁队列之前，反之，读锁却不能插入到写锁的前面。
行级锁 行锁拥有最小的粒度，可以最大程度的支持并发处理，但同时也会带来最大的锁开销，包括获得锁、检查锁是否已经解除、释放锁等。
共享锁 被加锁的对象可以被持锁事务读取，但是不能被修改，其他事务也可以在上面再加共享锁。
1  select * from table where ? lock in share mode   互斥锁 被加锁的对象只能被持有锁的事务读取和修改，其他事务无法在该对象上加其他锁，也不能读取和修改该对象
1 2 3 4  select * from table where ?]]></summary>
            
                <content type="html"><![CDATA[

<h1 id="锁">锁</h1>

<p>并发任务的顺序实现，最终还是要落到锁上，由锁来控制实现。</p>

<ul>
<li><p>根据锁的粒度划分，有行级锁，表级锁，页级锁三种</p></li>

<li><p>根据锁的类型划分，可以分为共享锁，互拆锁</p></li>

<li><p>根据锁的并发控制方式来划分，可以分为悲观锁和乐观锁，当然这种划分主要是从应用层面上来讲的</p></li>
</ul>

<h2 id="表级锁">表级锁</h2>

<p>表锁是MySQL中最基本的锁策略，并且是开销最小的策略。使用表锁，在使用前会锁定整张锁，在对表中信息进行更改（增加、删除、修改）时，会先去获得写锁，其他对于表的锁的获取都会被阻塞。另外，写锁比读锁有更高的优先级，所以在一个写锁可能被插入到所有读锁队列之前，反之，读锁却不能插入到写锁的前面。</p>

<h2 id="行级锁">行级锁</h2>

<p>行锁拥有最小的粒度，可以最大程度的支持并发处理，但同时也会带来最大的锁开销，包括获得锁、检查锁是否已经解除、释放锁等。</p>

<h2 id="共享锁">共享锁</h2>

<p>被加锁的对象可以被持锁事务读取，但是不能被修改，其他事务也可以在上面再加共享锁。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">select * from table where ? lock in share mode</code></pre></td></tr></table>
</div>
</div>
<h2 id="互斥锁">互斥锁</h2>

<p>被加锁的对象只能被持有锁的事务读取和修改，其他事务无法在该对象上加其他锁，也不能读取和修改该对象</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">select * from table where ? for update;
insert into table values (…);
update table set ? where ?;
delete from table where ?;</code></pre></td></tr></table>
</div>
</div>
<p>对于增删改也是用的互斥锁是因为，MySQL Server会根据where条件，读取第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回，并加锁 (current read)。待MySQL Server收到这条加锁的记录之后，会再发起一个Update请求，更新这条记录。一条记录操作完成，再读取下一条记录，直至没有满足条件的记录为止。因此，Update操作内部，就包含了一个当前读。同理，Delete操作也一样。Insert操作会稍微有些不同，简单来说，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一个当前读。</p>

<h2 id="悲观锁">悲观锁</h2>

<p>应用层面的并发控制方式
每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁</p>

<h2 id="乐观锁">乐观锁</h2>

<p>应用层面的并发控制方式
每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁</p>

<p>两种锁各有优缺点，不可认为一种好于另一种，像乐观锁适用于写比较少的情况下，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果经常产生冲突，上层应用会不断的进行retry，这样反倒是降低了性能，所以这种情况下用悲观锁就比较合适</p>

<h2 id="mvcc">mvcc</h2>

<p>Multiversion concurrency control 即多版本并发控制，乐观锁的一种实现，一般使用时间戳或版本号来标识一次修改，在修改时，验证之前是否已有其他修改提交</p>

<table>
<thead>
<tr>
<th align="left">事务A</th>
<th align="left">事务B</th>
<th align="left">备注</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left">start transaction;</td>
<td align="left"></td>
<td align="left"></td>
</tr>

<tr>
<td align="left">select a,version from test where id=1;</td>
<td align="left"></td>
<td align="left">a=0, version=0</td>
</tr>

<tr>
<td align="left"></td>
<td align="left">update test set a=1, version=1 where id=1;</td>
<td align="left">a=1, version=1</td>
</tr>

<tr>
<td align="left">update test set a=2 where version=0;</td>
<td align="left"></td>
<td align="left">发现冲突，更新失败</td>
</tr>

<tr>
<td align="left">rollback</td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody>
</table>

<h2 id="死锁">死锁</h2>

<p>两个事务需求的资源被对方所持有，进入了相互等待状态</p>

<ul>
<li>T1时 事务A锁定a，事务B锁定b</li>
<li>T2时 事务A执行锁定b，但被事务B持有，进入等待
  事务B执行锁定a，但被事务A持有，进入等待</li>

<li><p>形成死锁</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">事务A
start transaction
update a
update b
commit

事务B
start transaction
update b
update a
commit</code></pre></td></tr></table>
</div>
</div></li>
</ul>
]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/database/" term="database" label="database" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/database/" term="database" label="database" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/mysql/" term="mysql" label="mysql" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">mysql学习-总览</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/mysql%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/" />
            <id>https://blog.vgmdj.cn/posts/mysql%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/</id>
            <updated>2018-03-21T17:23:50+00:00</updated>
            <published>2018-03-21T15:23:50+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[简述 数据库(Database,简称DB): 长期存储在计算机内、有组织的、可共享的大量数据的集合 数据库管理系统(Database Management System，简称DBMS)： 位于用户与操作系统之间的一层数据管理软件，是一个大型复杂的软件系统，mysql就是一个开源的RDBMS 因所有的关系型数据库操作及功能都很类似，所以深入研究Mysql，可知识迁移到其他数据库中
书籍推荐： 《高性能mysql》、《深入浅出MYSQL》、《MySQL性能调优与架构设计》]]></summary>
            
                <content type="html"><![CDATA[<h2 id="简述">简述</h2>

<p>数据库(Database,简称DB): 长期存储在计算机内、有组织的、可共享的大量数据的集合
数据库管理系统(Database Management System，简称DBMS)： 位于用户与操作系统之间的一层数据管理软件，是一个大型复杂的软件系统，mysql就是一个开源的RDBMS
因所有的关系型数据库操作及功能都很类似，所以深入研究Mysql，可知识迁移到其他数据库中</p>

<h2 id="书籍推荐">书籍推荐：</h2>

<p>《高性能mysql》、《深入浅出MYSQL》、《MySQL性能调优与架构设计》</p>

<h2 id="分类与区别">分类与区别</h2>

<h3 id="关系型数据库优缺点">关系型数据库优缺点</h3>

<p>采用关系模型来组织数据的数据库
优点：</p>

<ul>
<li>可以通过事务来保证数据的一致性，对于安全性能很高的数据访问要求得以实现</li>
<li>通过sql语句，可以方便的在一个或多个表之间作复杂的数据查询</li>
</ul>

<p>缺点：</p>

<ul>
<li>与非关系型数据库相比，读写性能较差</li>
<li>难以进行水平扩展</li>
</ul>

<h3 id="非关系型数据库优缺点">非关系型数据库优缺点</h3>

<p>优点：</p>

<ul>
<li>基于键值对，不需要sql的筛选，读写性能很高</li>
<li>因基于键值对，数据之间没有耦合性，易于水平扩展</li>
</ul>

<p>缺点：</p>

<ul>
<li>不支持事务，无法保证数据的一致性</li>
<li>难以应对关系复杂的情况</li>
</ul>

<h2 id="go的orm">go的orm</h2>

<ul>
<li><p>xorm</p>

<ul>
<li>源码地址： <a href="https://github.com/jinzhu/gorm" target="_blank">https://github.com/jinzhu/gorm</a></li>
<li>首页地址： <a href="http://gorm.io/" target="_blank">http://gorm.io/</a></li>
</ul></li>

<li><p>gorm</p>

<ul>
<li>源码地址： <a href="https://github.com/go-xorm/xorm" target="_blank">https://github.com/go-xorm/xorm</a></li>
<li>首页地址： <a href="http://xorm.io/" target="_blank">http://xorm.io/</a></li>
</ul></li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/database/" term="database" label="database" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/database/" term="database" label="database" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/mysql/" term="mysql" label="mysql" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">数据库学习</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/" />
            <id>https://blog.vgmdj.cn/posts/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/</id>
            <updated>2018-03-20T00:23:50+00:00</updated>
            <published>2018-03-20T00:23:50+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[定义 数据库(Database,简称DB): 长期存储在计算机内、有组织的、可共享的大量数据的集合 数据库管理系统(Database Management System，简称DBMS)： 位于用户与操作系统之间的一层数据管理软件，是一个大型复杂的软件系统，mysql就是一个开源的RDBMS
介绍]]></summary>
            
                <content type="html"><![CDATA[<h1 id="定义">定义</h1>

<p>数据库(Database,简称DB): 长期存储在计算机内、有组织的、可共享的大量数据的集合
数据库管理系统(Database Management System，简称DBMS)： 位于用户与操作系统之间的一层数据管理软件，是一个大型复杂的软件系统，mysql就是一个开源的RDBMS</p>

<h1 id="介绍">介绍</h1>

<p><img src="https://upload-images.jianshu.io/upload_images/228680-448d468546343fa9?imageMogr2/auto-orient/" alt="数据库分类" /></p>

<h2 id="关系型数据库">关系型数据库</h2>

<h2 id="简介">简介</h2>

<p>虽然网状数据库和层次数据库已经很好的解决了数据的集中和共享问题，但是在数据库独立性和抽象级别上扔有很大欠缺。用户在对这两种数据库进行存取时，仍然需要明确数据的存储结构，指出存取路径。而关系型数据库就可以较好的解决这些问题。</p>

<p>关系型数据库模型是把复杂的数据结构归结为简单的二元关系（即二维表格形式）。在关系型数据库中，对数据的操作几乎全部建立在一个或多个关系表格上，通过对这些关联的表格分类、合并、连接或选取等运算来实现数据库的管理。</p>

<p>关系型数据库诞生40多年了，从理论产生发展到现实产品，例如：Oracle和MySQL，Oracle在数据库领域上升到霸主地位，形成每年高达数百亿美元的庞大产业市场。</p>

<h3 id="主流数据库">主流数据库</h3>

<ul>
<li>Mysql</li>
<li>Oracle</li>
<li>Access</li>
<li>SqlServer</li>
<li>PostgreSql</li>
</ul>

<h2 id="非关系型数据库">非关系型数据库</h2>

<h3 id="简介-1">简介</h3>

<p>NoSQL，泛指非关系型的数据库。随着互联网web2.0网站的兴起，传统的关系数据库在应付web2.0网站，特别是超大规模和高并发的SNS类型的web2.0纯动态网站已经显得力不从心，暴露了很多难以克服的问题，而非关系型的数据库则由于其本身的特点得到了非常迅速的发展。NoSql数据库在特定的场景下可以发挥出难以想象的高效率和高性能，它是作为对传统关系型数据库的一个有效的补充。</p>

<p>NoSQL(NoSQL = Not Only SQL )，意即“不仅仅是SQL”，是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。</p>

<h3 id="分类">分类</h3>

<ul>
<li><p>键值存储数据库
键值数据库就类似传统语言中使用的哈希表。可以通过key来添加、查询或者删除数据库，因为使用key主键访问，所以会获得很高的性能及扩展性。
键值数据库主要使用一个哈希表，这个表中有一个特定的键和一个指针指向特定的数据。Key/value模型对于IT系统来说的优势在于简单、易部署、高并发。
典型产品：Memcached、Redis</p></li>

<li><p>文档存储数据库
文档型数据库的灵感是来自于Lotus Notes办公软件，而且它同第一种键值数据库类似。该类型的数据模型是版本化的文档，半结构化的文档以特定的格式存储，比如JSON。文档型数据库可以看作是键值数据库的升级版，允许之间嵌套键值。而且文档型数据库比键值数据库的查询效率更高。
面向文档数据库会将数据以文档形式存储。每个文档都是自包含的数据单元，是一系列数据项的集合。每个数据项都有一个名词与对应值，值既可以是简单的数据类型，如字符串、数字和日期等；也可以是复杂的类型，如有序列表和关联对象。数据存储的最小单位是文档，同一个表中存储的文档属性可以是不同的，数据可以使用XML、JSON或JSONB等多种形式存储。
典型产品：MongoDB、CouchDB</p></li>

<li><p>列存储数据库
列存储数据库将数据存储在列族中，一个列族存储经常被一起查询的相关数据，比如人类，我们经常会查询某个人的姓名和年龄，而不是薪资。这种情况下姓名和年龄会被放到一个列族中，薪资会被放到另一个列族中。
这种数据库通常用来应对分布式存储海量数据。
典型产品：Cassandra、HBase</p></li>

<li><p>图型数据库
图形数据库允许我们将数据以图的方式存储。实体会被作为顶点，而实体之间的关系则会被作为边。比如我们有三个实体，Steve Jobs、Apple和Next，则会有两个“Founded by”的边将Apple和Next连接到Steve Jobs。
典型产品：Neo4J、InforGrid</p></li>
</ul>

<h2 id="学习计划">学习计划</h2>

<ul>
<li>关系型数据库以Mysql为代表</li>
<li>非关系型数据库中键值存储型以Redis为代表</li>
<li>非关系型数据库中文档存储型以MongoDB为代表</li>
<li>非关系型数据库中列存储型以Hbase为代表</li>
</ul>

<h2 id="本文参考文章">本文参考文章</h2>

<p><a href="https://www.jianshu.com/p/107c6b045245" target="_blank">https://www.jianshu.com/p/107c6b045245</a></p>

<h2 id="学习过程参考书籍">学习过程参考书籍</h2>

<ul>
<li>《Redis实战》</li>
<li>《MongoDB权威指南》</li>
<li>《大数据存储MongoDB实战指南》</li>
<li>《高性能Mysql》</li>
<li>《深入浅出Mysql》</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/database/" term="database" label="database" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/database/" term="database" label="database" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">计算机网络学习-页面的请求过程</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</id>
            <updated>2018-03-08T14:39:52+00:00</updated>
            <published>2018-03-08T13:42:29+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[我们在学校上网时一次网页请求的过程是什么呢?]]></summary>
            
                <content type="html"><![CDATA[<p>我们在学校上网时一次网页请求的过程是什么呢?</p>

<p>首先将电脑用一条以太网网线连到以太网交换机, 这个交换机连到学校的路由器,该路由器再连到ISP(Internet Service Provider), 就是电信等公司, 电信会提供DNS域名解析服务.</p>

<p>当电脑刚刚连上网络的时候, 需要运行DHCP协议从本地的DHCP服务器来得到一个IP地址。</p>

<p>电脑创建一个DHCP request message, 放到一个UDP段里面, 这个段还包含目标端口(DHCP server)和来源端口(DHCP client). 这个UDP段会放到一个IP数据报里面, 这个包的目标IP地址是广播地址(255.255.255.255), 来源地址是0.0.0.0.</p>

<p>IP数据报放在一个Ethernet frame里, 这个以太网帧的目标地址是FF:FF:FF:FF:FF:FF所以该帧会被广播到所有连接在该交换机的设备,该帧的来源MAC地址是电脑的物理地址.</p>

<p>当DHCP服务器收到这个IP数据报后,就会分配一个IP地址. 创建一个包含该IP地址和DNS地址的DHCP ACK message, 发回到我们的电脑.</p>

<p>有了IP地址后就可以上网了。在浏览器上输入URL www.google.com, 浏览器会首先创建一个TCP socket, 然后通过TCP socket发送HTTP请求。 为了创建TCP socket我们首先要知道 www.google.com的IP地址， 该地址由DNS协议得到。</p>

<p>操作系统创建了一个DNS query message, 放进一个目标端口为53（DNS服务器）的UDP段里面， 这个UDP段放进以DNS server IP的为目标的IP数据报里。</p>

<p>包含该IP数据报的Ethernet frame会发往学校的网关路由器。尽管我们的电脑知道学校网关的IP地址，但是它不知道网关路由器的MAC地址， 这个时候就需要用到 ARP 协议。</p>

<p>电脑创建一个包含网关IP地址的ARP query message， 把它放进目标地址为广播地址FF:FF:FF:FF:FF:FF的以太网帧里面。 交换机会把这个帧发送到所有连接的设备，包括网关路由器。</p>

<p>网关路由器发现这个DNS query message的目标IP是自己，则创建一个ARP reply, 把自己的MAC地址发送回去。 操作系统得到网关的MAC地址后， 就可以发送DNS query了。</p>

<p>网关路由器拿到DNS query, 查看它的目标地址，根据forwading table决定传递到哪一个路由器去。IP数据报被放进链接层的帧里面。</p>

<p>拿到该链接层帧的路由器再根据它的forwading table转发，该forwarding table由Internet&rsquo;s intera-domain protocal(如 RIP, OSPF, IS-IS, BGP)维护。</p>

<p>最后DNS server查询DNS query里的网址，得到对应的IP， 发送回我们的电脑。</p>

<p>得到www.google.com的IP地址后，我们就可以创建TCP socket了。 首先TCP要进行三次握手连接到80端口， 然后发送HTTP GET。</p>

<p>Google的服务器读取HTTP GET讯息，返回包含网页内容的HTTP response. 我们的电脑就可以展示其中的内容了。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" term="计算机网络" label="计算机网络" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" term="计算机网络" label="计算机网络" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">计算机网络学习-socket套接字分析</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-socket%E5%A5%97%E6%8E%A5%E5%AD%97%E5%88%86%E6%9E%90/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-socket%E5%A5%97%E6%8E%A5%E5%AD%97%E5%88%86%E6%9E%90/</id>
            <updated>2018-03-08T14:39:52+00:00</updated>
            <published>2018-03-08T13:42:05+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[TCP TCP状态 !tcp状态转移
 CLOSED LISTEN SYN_SENT SYN_REVD ESTABLISHED FIN_WAIT1 CLOSE_WAIT CLOSING FIN_WAIT2 LAST_ACK TIME_WAIT  TCP 计时器  超时重传计时器 持续计时器  TCP 可靠数据传输  流量控制  滑动窗口协议  拥塞控制  慢开始 拥塞避免 快重传 快恢复   TCP客户端套接字程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  import java.io.<em>; import java.net.</em>; class TCPClient{ public static void main(String argv[]) throws Exception { String sentence; String modifiedSentence; BufferedReader inFromUser = new BufferedReader( new InputStreamReader(System.in)); Socket ClientSocket = new Socket("222.194.1.36",6789); DataOutputStream outToServer = new DataOutputStream( ClientSocket.getOutputStream()); BufferedReader inFromServer = new BufferedReader(new InputStreamReader( ClientSocket.getInputStream())); sentence =inFromUser.readLine(); outToServer.writeBytes(sentence + '\n'); modifiedSentence = inFromServer.readLine(); System.out.println("FROM SERVER:"+ modifiedSentence); ClientSocket.close(); } }]]></summary>
            
                <content type="html"><![CDATA[<h2 id="tcp">TCP</h2>

<h3 id="tcp状态">TCP状态</h3>

<p><a href="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1560918640995&amp;di=25856014d97833f5ccf321c5e36f1de2&amp;imgtype=0&amp;src=http%3A%2F%2Faliyunzixunbucket.oss-cn-beijing.aliyuncs.com%2Fjpg%2F823a7efe419f312ed95b33a15c50dbc1.jpg%3Fx-oss-process%3Dimage%2Fresize%2Cp_100%2Fauto-orient%2C1%2Fquality%2Cq_90%2Fformat%2Cjpg%2Fwatermark%2Cimage_eXVuY2VzaGk%3D%2Ct_100" target="_blank">!tcp状态转移</a></p>

<ul>
<li>CLOSED</li>
<li>LISTEN</li>
<li>SYN_SENT</li>
<li>SYN_REVD</li>
<li>ESTABLISHED</li>
<li>FIN_WAIT1</li>
<li>CLOSE_WAIT</li>
<li>CLOSING</li>
<li>FIN_WAIT2</li>
<li>LAST_ACK</li>
<li>TIME_WAIT</li>
</ul>

<h3 id="tcp-计时器">TCP 计时器</h3>

<ul>
<li>超时重传计时器</li>
<li>持续计时器</li>
</ul>

<h3 id="tcp-可靠数据传输">TCP 可靠数据传输</h3>

<ul>
<li>流量控制

<ul>
<li>滑动窗口协议</li>
</ul></li>
<li>拥塞控制

<ul>
<li>慢开始</li>
<li>拥塞避免</li>
<li>快重传</li>
<li>快恢复</li>
</ul></li>
</ul>

<h3 id="tcp客户端套接字程序">TCP客户端套接字程序</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">import java.io.*;
import java.net.*;
class TCPClient{
  public static void main(String argv[]) throws Exception
  {
     String sentence;
     String modifiedSentence;
     BufferedReader inFromUser =
        new BufferedReader(
              new InputStreamReader(System.in));
     Socket ClientSocket = new Socket(&#34;222.194.1.36&#34;,6789);
     DataOutputStream outToServer =
        new DataOutputStream(
              ClientSocket.getOutputStream());
     BufferedReader inFromServer =
        new BufferedReader(new InputStreamReader(
               ClientSocket.getInputStream()));
     sentence =inFromUser.readLine();
     outToServer.writeBytes(sentence + &#39;\n&#39;);
     modifiedSentence = inFromServer.readLine();
     System.out.println(&#34;FROM SERVER:&#34;+
                           modifiedSentence);
     ClientSocket.close();
   }
}</code></pre></td></tr></table>
</div>
</div>
<h3 id="tcp服务器端套接字程序">TCP服务器端套接字程序</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">import java.io.*;
import java.net.*;
class TCPServer{
  public static void main(String argv[]) throws Exception
  {
     String ClientSentence;
     String capitalizedSentence;
     ServerSocket welcomeSocket = new ServerSocket(6789);
 
     while(true){
        Socket connectionSocket = welcomeSocket.accept();
        BufferedReader inFromClient =
          new BufferedReader(new InputStreamReader(
              connectionSocket.getInputStream()));
        DataOutputStream outToClient =
          new DataOutputStream(
              connectionSocket.getOutputStream());
        ClientSentence = inFromClient.readLine();
        capitalizedSentence =
              ClientSentence.toUpperCase() + &#39;\n&#39;;
     outToClient.writeBytes(capitalizedSentence);
   }
}
}</code></pre></td></tr></table>
</div>
</div>
<p><img src="/计算机网络学习-socket套接字分析/tcp1.png" alt="tcp" />
<img src="/计算机网络学习-socket套接字分析/tcp2.png" alt="tcp" /></p>

<h3 id="tcp连接分析">TCP连接分析</h3>

<ul>
<li><p>1、 客户端：握手请求seq=0,len=0，syn=1<br>
syn=1，标志着这是一次握手请求，且客户端设置初始seq=0，发送数据len=0</p></li>

<li><p>2、 服务器端：握手应答 seq=0 ,ack =1, len=0，syn=1<br>
syn=1,ack=1, 标志着这是属于握手应答，且服务端初始seq=0，ack=（客户端的）seq+len+1，发送数据len=0</p></li>

<li><p>3、 客户端：接收到应答 seq =1, ack =1, len=0<br>
seq=（客户端上次的）seq+len+1, ack=（服务端的）seq+len+1</p></li>

<li><p>4、 客户端：发送数据请求 seq =1 ,ack = 1 ,len =1<br>
seq=（客户端上次的）seq+len, ack=（服务端的）seq+len</p></li>

<li><p>5、 服务器端：接收请求 seq =1 ,ack =2 ,len =0<br>
seq=（服务端上次的）seq+len, ack=（客户端的）seq+len 注：下同</p></li>

<li><p>6、 客户端：发送数据 seq =2, ack =1, len =14</p></li>

<li><p>7、 服务器端:接收数据并请求发送数据 seq =1 ,ack =16 ,len =1</p></li>

<li><p>8、 客户端:接收请求 seq =16 , ack =2 , len=0</p></li>

<li><p>9、 服务器端：发送数据 seq =2 ,ack =16 ,len =14</p></li>

<li><p>10、客户端:接收数据并请求关闭连接 seq = 16 ,ack = 16 ,len =0</p></li>

<li><p>11、服务器端:接收请求 seq = 16 ,ack =17 ,len =0</p></li>
</ul>

<p>客户端关闭连接，但服务器端仍保持监听，则服务器端没有进行请求关闭连接的请求。</p>

<h2 id="udp">UDP</h2>

<h3 id="udp客户端套接字程序">UDP客户端套接字程序</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">import java.io.*;
import java.net.*;
class UDPClient {
  public static void main(String args[]) throws Exception
  {
     BufferedReader inFromUser =
        new BufferedReader(new InputStreamReader(System.in));
     DatagramSocket clientSocket = new DatagramSocket();
     InetAddress IPAddress = InetAddress.getByName(&#34;222.194.1.36&#34;);
     byte[] sendData = new byte[1024];
byte[] receiveData = new byte[1024];
String sentence = inFromUser.readLine();
sendData = sentence.getBytes();
DatagramPacket sendPacket =
   new DatagramPacket(sendData, sendData.length,
IPAddress,9876);
clientSocket.send(sendPacket);
DatagramPacket receivePacket =
   new DatagramPacket(receiveData, receiveData.length);
clientSocket.receive(receivePacket);
String modifiedSentence=
   new String(receivePacket.getData());
System.out.println(&#34;FROM SERVER:&#34; + modifiedSentence);
clientSocket.close();
      }
}</code></pre></td></tr></table>
</div>
</div>
<h3 id="udp服务器端套接字程序">UDP服务器端套接字程序</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">import java.io.*;
import java.net.*;
class UDPServer {
  public static void main(String args[]) throws Exception
  {
    DatagramSocket serverSocket = new DatagramSocket(9876);
     byte[] receiveData = new byte[1024];
     byte[] sendData = new byte[1024];
     while(true)
      {
  DatagramPacket receivePacket =
   new DatagramPacket(receiveData, receiveData.length);
  serverSocket.receive(receivePacket);
       String sentence = new String(receivePacket.getData());
       InetAddress IPAddress = receivePacket.getAddress();
       int port = receivePacket.getPort();
       String capitalizedSentence = sentence.toUpperCase();
       sendData = capitalizedSentence.getBytes();
  DatagramPacket sendPacket =
new DatagramPacket(sendData, sendData.length,
IPAddress,port);
      serverSocket.send(sendPacket);
     }
  }
}</code></pre></td></tr></table>
</div>
</div>
<p><img src="/计算机网络学习-socket套接字分析/udp1.png" alt="udp" />
<img src="/计算机网络学习-socket套接字分析/udp2.png" alt="udp" /></p>

<h3 id="udp连接分析">UDP连接分析：</h3>

<p>1、客户端：向服务器端发送长度为60的数据段
2、服务器端 :向客户端发送长度为1066的数据段
 </p>

<h2 id="总结-与tcp连接相比-udp显然更快捷-它不需要进行握手请求-也不用进行关闭请求-但是-很明显的是-少了这些以后-没法保证数据是否正常的传输到目的地-没法保证数据传输的可靠性">总结：与TCP连接相比，UDP显然更快捷，它不需要进行握手请求，也不用进行关闭请求。但是，很明显的是，少了这些以后，没法保证数据是否正常的传输到目的地，没法保证数据传输的可靠性。</h2>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" term="计算机网络" label="计算机网络" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" term="计算机网络" label="计算机网络" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">计算机网络学习-协议分析</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/</id>
            <updated>2018-04-10T14:39:52+00:00</updated>
            <published>2018-03-08T13:40:56+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[计算机网络分类  按分布范围分类：广域网、城域网、局域网、个人区域网 按拓扑结构分类：星形网络、总线形网络、环形网络、网状形网络 按传输技术分类：广播式网络、点对点网络 按使用者分类：公用网、专用网 按数据交换技术分类：电路交换网、报文交换网、分级交换网]]></summary>
            
                <content type="html"><![CDATA[<h2 id="计算机网络分类">计算机网络分类</h2>

<ul>
<li>按分布范围分类：广域网、城域网、局域网、个人区域网</li>
<li>按拓扑结构分类：星形网络、总线形网络、环形网络、网状形网络</li>
<li>按传输技术分类：广播式网络、点对点网络</li>
<li>按使用者分类：公用网、专用网</li>
<li>按数据交换技术分类：电路交换网、报文交换网、分级交换网</li>
</ul>

<h2 id="协议分层">协议分层</h2>

<p>互联网协议分为五层，各层的所有协议被称为协议栈。一般采用自顶向下的方法，首先处理应用层，然后向下进行处理</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">应用层
运输层
网络层
链路层
物理层</code></pre></td></tr></table>
</div>
</div>
<p>国际标准化组织（ISO）提出了计算机网络的七层模型，即开放式互连模型（OSI），并未被使用。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">应用层
表示层
会话层
运输层
网络层
链路层
物理层</code></pre></td></tr></table>
</div>
</div>
<h2 id="各层中间设备">各层中间设备</h2>

<ul>
<li>物理层使用的中间设备叫 <strong>转发器（中继器）</strong>(repeater)，用于放大信号，扩展传输距离。

<ul>
<li><strong>集线器</strong>(hub)，是一种多端口转发器，采用广播方式发送数据，所有端口共用一个信道带宽</li>
</ul></li>
<li>数据链路层使用的中间设备叫 <strong>网桥或桥接器</strong>(bridge)

<ul>
<li><strong>交换机</strong>(switch)，是一种多端口网桥，可以提供点对点的连接，数据包只会发送到目的端口，则不会向所有端口发送</li>
</ul></li>
<li>网络层使用的中间设备叫 <strong>路由器</strong>(router)</li>
<li>在网络层以上使用的中间设备叫 <strong>网关</strong>(gateway)</li>
</ul>

<h2 id="传输层协议分析">传输层协议分析</h2>

<p><a href="http://www.cnblogs.com/skynet/archive/2010/12/12/1903949.html" target="_blank">socket与tcp</a></p>

<p><a href="https://www.jianshu.com/p/ef892323e68f" target="_blank">tcp可参考文章</a></p>

<h3 id="tcp">tcp</h3>

<p><img src="/计算机网络学习-协议分析/tcp.jpg" alt="tcp报文结构" />
6位标志域。表示为：紧急标志、有意义的应答标志、推、重置连接标志、同步序列号标志、完成发送数据标志。按照顺序排列是：URG、ACK、PSH、RST、SYN、FIN。
tcp的具体分析可见下篇，<a href="/post/计算机网络学习-socket套接字分析/">socket套接字分析</a></p>

<h4 id="三次握手">三次握手</h4>

<ul>
<li>客户端向服务器发送一个SEQ J,SYN 1</li>
<li>服务器向客户端响应一个SEQ K，SYN 1, 并进行确认ACK J+1</li>

<li><p>客户端再想服务器发一个确认ACK K+1</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">A: 请求连接，我这次连接代号是Q1
B：好，收到了，可以连了，我这次连接代码是P1
A：好，我知道你准备好了</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h4 id="四次挥手">四次挥手</h4>

<ul>
<li>A发送 FIN 1 和SEQ M，仅代表不会再发送数据报文了，但仍可以接收数据</li>
<li>B发送 ACK M+1 和 SEQ x(B上次的SEQ+len)，进行确认</li>
<li>B发送 FIN 1, SEQ N，代表处理完成，对方可以进行关闭了</li>

<li><p>A发送 ACK N+1 和SEQ y(A上次的SEQ+len)，代表关闭确认</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">A: 请求关闭，我不会再发数据了，你要发就快发
B：好，我知道你不会再发了，我需要再处理一下数据（可能会或者说可以接着发数据）
B: 好了，我处理完了，可以关闭连接了
A：好，那就关闭吧</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h3 id="udp">udp</h3>

<p><img src="/计算机网络学习-协议分析/udp.jpg" alt="udp报文结构" /></p>

<h3 id="tcp是一种流模式的协议">TCP是一种流模式的协议</h3>

<p>write -&gt; cache -&gt; read
数据流入 cache，再从cache流出，而入口和出口的大小并不一定相等。
可能有个桶大的入口，但只有一个碗大的出口</p>

<ul>
<li>tcp协议是有序的</li>
<li>read的大小和write的大小没有关系</li>
<li>write的数据量 &lt; 接收缓存大小，如果多了的话，就会自动丢弃</li>
</ul>

<p>其主要特点是稳定</p>

<h3 id="udp是一种数据报模式的协议">UDP是一种数据报模式的协议</h3>

<p>write -&gt; read
数据流入多少，就得接收多少
一次读取一段报文 ，报文之间不进行合并</p>

<p>其主要特点是速度快</p>

<h3 id="对传输层协议tcp-udp进行捕包分析">对传输层协议TCP/UDP进行捕包分析</h3>

<p><img src="/计算机网络学习-协议分析/tcp2.jpg" alt="tcp包分析" /></p>

<p>(1) 向gaia.cs.umass.edu服务器传送文件的客户端主机的IP地址和TCP端口号是多少？
答：IP地址是：128.119.245.12
    端口号是：80
(2) 客户服务器之间用于初始化TCP连接的TCP SYN报文段的序号（sequence number）是多少？在该报文段中，是用什么来标示该报文段是SYN报文段的？
    答：seq为0， 用flags相应位置1来标示SYN报文段
     
TCP第二次握手协议图如下：
<img src="/计算机网络学习-协议分析/tcp3.jpg" alt="tcp包分析" /></p>

<p>(3) 服务器向客户端发送的SYNACK报文段序号是多少？该报文段中，ACKnowledgement字段的值是多少？Gaia.cs.umass.edu服务器是如何决定此值的？在该报文段中，是用什么来标示该报文段是SYNACK报文段的？
答：SYNACK报文段的seq = 0 ， ACK = 1, 服务器计算方法是ACK = seq(SYN的) + 1， 在这个报文段中，用flags = 0x012来标示</p>

<p>(4) 前六个TCP报文段的长度各是多少？
答：由图可知，前六个TCP报文段长度为66 bytes、66 bytes、54 bytes、1462 bytes、1462 bytes、1462 bytes</p>

<p>(5) 在跟踪文件中是否有重传的报文段？进行判断的依据是什么？
答：没有重传的报文段，判断的依据是，如果有重传的报文段的话，那么服务器端向客户端 发送的TCP报文段里，就会出现大量的重复ACK。
<img src="/计算机网络学习-协议分析/tcp4.jpg" alt="tcp包分析" /></p>

<h2 id="应用层协议分析">应用层协议分析</h2>

<h3 id="dns分析">dns分析</h3>

<p>DNS（域名系统）：Domain Name System  因特网的目录服务
DNS协议属于应用层协议
DNS通常是由其它应用层协议来使用的。
DNS是一个在因特网上实现分布式数据库的精彩范例。</p>

<p>DNS服务器的种类：
- 根DNS服务器：用来引导查询获取顶级域名称服务器的域名及对应的顶级域服务器的IP地址。
- 顶级域（DNS）服务器：负责顶级域名如：com、org、net、edu、gov，以及所有国家的顶级域名如uk、fr、ca、jp等。
- 权威DNS服务器：在因特网上具有公共可访问主机的每个组织机构都必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。权威名称服务器对这些DNS记录进行收藏。
- 本地DNS服务器：不属于服务器的层次结构，但对DNS层次结构非常重要。</p>

<p><img src="/计算机网络学习-协议分析/dns.png" alt="dns分类" /></p>

<h3 id="http分析">http分析</h3>

<p>HTTP（超文本传输协议）：Hyper Text Transfer Protocol
HTTP协议永远都是客户端发起请求，服务器回送响应。
HTTP协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。</p>

<h4 id="http-header">http header</h4>

<ul>
<li><p>Host
指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。HTTP/1.1请求必须包含host，否则系统会以400状态码返回。</p></li>

<li><p>Range
Range头域可以请求实体的一个或者多个子范围。
一般用于<a href="http://blog.csdn.net/lv18092081172/article/details/51457525" target="_blank">断点续传</a></p></li>

<li><p>User-Agent
包含发出请求的用户信息，可根据此来判断浏览器类型或爬虫类型。
github page 就是根据此屏蔽百度爬虫</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Mozilla/5.0 (compatible; Baiduspider/2.0; +http://www.baidu.com/search/spider.html)</code></pre></td></tr></table>
</div>
</div></li>

<li><p>Cache-Control
指定请求和响应遵循的缓存机制,请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。
性能提升相关</p></li>
</ul>

<h4 id="http长连接">http长连接</h4>

<p>http长连接本质是就是tcp长连接，即用于传输http数据的tcp连接，不发送FIN和RST，使连接保持不断开，使得客户端下一次访问服务端，还可以使用同一个tcp连接，从而避免了建立tcp连接的消耗。
对于频繁请求资源的客户来说，较适合使用长连接。但如果连接不断开，随着客户端的增长，保持的长连接也会越来越多，对服务器的压力反而会更大。
长连接适用于，操作频繁，点对点的通讯，且连接数不适合太多
短连接适用于，连接数较多且不会频繁操作的通讯
<a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank">长连接和短连接的理解</a></p>

<h4 id="http重定向-301和302">http重定向，301和302</h4>

<p>重定向(Redirect)就是通过各种方法将各种网络请求重新定个方向转到其它位置</p>

<ul>
<li>301 代表的是永久性的重定向，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</li>
<li>302 代表的是暂时性的重定向，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</li>
</ul>

<h3 id="https">https</h3>

<h4 id="简述">简述</h4>

<p>在http之上多了一层SSL/TLS，在http开始时，服务端会先向客户端发送ssl证书，
ssl证书中会包含网站基本信息，ca机构，证书编号，服务器的公钥。
客户端收到证书后，会使用hash对照证书编号验证一致性与完整性，验证的过程就是查找本地维护的证书中指定的ca机构的公钥，对编号进行解密从而得到编号1，然后用证书中指定的编号生成方式生成一个编号2，如果两个编号相同，则证书验证通过。
然后客户端取出服务端的公钥，结合随机数生成一个对称加密的密钥再用服务器的公钥加密后，发回给服务端，服务端用自己的私钥解密之后双方就可以使用对称加密密钥进行通信了。</p>

<h4 id="七次握手">七次握手</h4>

<p>https的握手过程，包含两部分，一共七次</p>

<ul>
<li>tcp三次握手</li>
<li>ssl/tls 四次握手</li>
</ul>

<p>其中SSL/TLS 握手过程包括</p>

<p><img src="/计算机网络学习-协议分析/https握手过程.png" alt="握手过程" /></p>

<ul>
<li>Client Hello
握手第一步是客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 Random1、客户端支持的加密套件（Support Ciphers）和 SSL Version 等信息。</li>
<li>Server Hello
第二步是服务端向客户端发送 Server Hello 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 Random2。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。</li>
<li>Certificate
这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。</li>
<li>Server Key Exchange
如果是DH算法，这里发送服务器使用的DH参数。RSA算法不需要这一步。</li>
<li>Certificate Request
Certificate Request 是服务端要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到。</li>
<li>Server Hello Done
Server Hello Done 通知客户端 Server Hello 过程结束。</li>
<li>Certificate Verify
客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 Random3，再用服务端公钥非对称加密 Random3 生成 PreMaster Key。</li>
<li>Client Key Exchange
上面客户端根据服务器传来的公钥生成了 PreMaster Key，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 PreMaster Key 得到客户端生成的 Random3。至此，客户端和服务端都拥有 Random1 + Random2 + Random3，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。</li>
<li>Change Cipher Spec(Client)
这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息。</li>
<li>Encrypted Handshake Message(Client)
这一步对应的是 Client Finish 消息，客户端将前面的握手消息生成摘要再用协商好的秘钥加密，这是客户端发出的第一条加密消息。服务端接收后会用秘钥解密，能解出来说明前面协商出来的秘钥是一致的。</li>
<li>Change Cipher Spec(Server)
这一步是服务端通知客户端后面再发送的消息都会使用加密，也是一条事件消息。</li>
<li>Encrypted Handshake Message(Server)
这一步对应的是 Server Finish 消息，服务端也会将握手过程的消息生成摘要再用秘钥加密，这是服务端发出的第一条加密消息。客户端接收后会用秘钥解密，能解出来说明协商的秘钥是一致的。</li>
<li>Application Data
到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。</li>
</ul>

<h4 id="安全验证">安全验证</h4>

<p>可以在配置好https后，在<a href="https://myssl.com/" target="_blank">myssl</a>上验证是否安全
一切配置完成后，基本都可以达到A+的评级，下面是对 <a href="https://blog.vgmdj.cn" target="_blank">https://blog.vgmdj.cn</a> 的安全测试
<a href="https://myssl.com/blog.vgmdj.cn?domain=blog.vgmdj.cn&amp;status=success" target="_blank">https://myssl.com/blog.vgmdj.cn?domain=blog.vgmdj.cn&amp;status=success</a></p>

<h4 id="参考资料">参考资料</h4>

<p><a href="http://www.admin10000.com/document/12524.html" target="_blank">https讲解</a>
<a href="http://www.cnblogs.com/zhuqil/archive/2012/07/23/2604572.html" target="_blank">https交互图解</a>
<a href="https://www.jianshu.com/p/7158568e4867" target="_blank">SSL/TLS 握手过程详解</a>
<a href="http://blog.csdn.net/sunmenggmail/article/details/11994013" target="_blank">rsa加密原理</a>
<a href="https://www.zhihu.com/question/33645891?sort=created" target="_blank">rsa加密原理2</a></p>

<h3 id="利用ethereal观察分析协议http和dns">利用ethereal观察分析协议HTTP和DNS</h3>

<p><img src="/计算机网络学习-协议分析/http1.jpg" alt="http抓包1" />
<img src="/计算机网络学习-协议分析/http2.jpg" alt="http抓包2" />
<img src="/计算机网络学习-协议分析/http3.jpg" alt="http抓包3" />
<img src="/计算机网络学习-协议分析/http4.jpg" alt="http抓包4" /></p>

<h4 id="浏览器运行的是http1-0-还是http1-1-所访问的服务器所运行的http版本号是多少">浏览器运行的是HTTP1.0，还是HTTP1.1？所访问的服务器所运行的HTTP版本号是多少？</h4>

<p>运行的都是HTTP Version 1.1
 </p>

<h4 id="浏览器向服务器指出它能接收何种语言版本的对象">浏览器向服务器指出它能接收何种语言版本的对象？</h4>

<p>指出了能接收汉语，英语</p>

<p> </p>

<h4 id="计算机的ip地址是多少-服务器gaia-cs-umass-edu的ip地址是多少">计算机的IP地址是多少？服务器gaia.cs.umass.edu的IP地址是多少？</h4>

<p>本机IP：172.30.164.86，目标IP：128.119.245.12
 
 </p>

<h4 id="从服务器上所获取的html文件的最后修改时间是多少">从服务器上所获取的HTML文件的最后修改时间是多少？ </h4>

<p>最后的修改时间为Tue , 30 Oct 2007 17：00：02
 </p>

<h4 id="一共发出了多少个http-get请求">一共发出了多少个HTTP GET请求？</h4>

<p>发出了一个GET请求
 </p>

<h4 id="承载这一个http响应报文一共需要多少个data-containing-tcp报文段">承载这一个HTTP响应报文一共需要多少个data-containing TCP报文段？</h4>

<p>4个报文段
 </p>

<h4 id="这个http-get请求相对应的响应报文的状态代码和状态短语是什么">这个HTTP GET请求相对应的响应报文的状态代码和状态短语是什么？</h4>

<p>状态码200，短语OK ，意思为请求成功
 
 </p>

<h4 id="定位到dns查询报文和查询响应报文-这两种报文的发送是基于udp还是基于tcp的">定位到DNS查询报文和查询响应报文，这两种报文的发送是基于UDP还是基于TCP的？</h4>

<p>能看出，这两种报文都是基于UDP发送的
 </p>

<h4 id="查询报文的目的端口号是多少-dns查询响应报文的源端口号是多少">查询报文的目的端口号是多少？DNS查询响应报文的源端口号是多少？</h4>

<p>查询报文:
<img src="/计算机网络学习-协议分析/dns2.jpg" alt="dns查询" />
查询响应报文：
<img src="/计算机网络学习-协议分析/dns3.jpg" alt="dns查询" />
由图可以看出，两个端口号都是一致的，是53号端口</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" term="计算机网络" label="计算机网络" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" term="计算机网络" label="计算机网络" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">计算机网络学习-测试通信</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E6%B5%8B%E8%AF%95%E9%80%9A%E4%BF%A1/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0-%E6%B5%8B%E8%AF%95%E9%80%9A%E4%BF%A1/</id>
            <updated>2018-03-08T14:39:52+00:00</updated>
            <published>2018-03-08T13:39:52+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[之前学习网络的时候做的一些总结，现在正好整理一下，再加深一下记忆
测试连接通信主要有命令  ping arp ipconfig tracert netstat]]></summary>
            
                <content type="html"><![CDATA[<p>之前学习网络的时候做的一些总结，现在正好整理一下，再加深一下记忆</p>

<h1 id="测试连接通信主要有命令">测试连接通信主要有命令</h1>

<ul>
<li>ping</li>
<li>arp</li>
<li>ipconfig</li>
<li>tracert</li>
<li>netstat</li>
</ul>

<h2 id="ipconfig-命令-windows-ifconfig命令-linux">ipconfig 命令（windows）/ ifconfig命令（linux）</h2>

<p>利用ipconfig命令显示所有当前的TCP/IP网络配置值、刷新动态主机配置协议 (DHCP) 和域名系统 (DNS) 设置。 使用不带参数的IPCONFIG显示所有适配器的 IP 地址、子网掩码、默认网关。
利用ifconfig命令可以在linux系统下显示所有适配器的 IP 地址、子网掩码、默认网关。
<img src="/计算机网络学习-测试通信/ipconfig.png" alt="ipconfig" /></p>

<h2 id="ping-命令">ping 命令</h2>

<p>Ping向目标主机(地址)发送一个回送请求数据包，要求目标主机收到请求后给予答复，从而判断网络的响应时间和本机是否与目标主机(地址)联通。
如果执行Ping不成功，则可以预测故障出现在以下几个方面：网线故障，网络适配器配置不正确，IP地址不正确。如果执行Ping成功而网络仍无法使用，那么问题很可能出在网络系统的软件配置方面，Ping成功只能保证本机与目标主机间存在一条连通的物理路径。
命令格式：
ping IP地址或主机名 [-t] [-a] [-n count] [-l size]
常用参数含义：</p>

<ul>
<li>-t不停地向目标主机发送数据；</li>
<li>-a 以IP地址格式来显示目标主机的网络地址 ；</li>
<li>-n count 指定要Ping多少次，具体次数由count来指定 ；</li>
<li>-l size 指定发送到目标主机的数据包的大小。
<img src="/计算机网络学习-测试通信/ping.png" alt="ping" /></li>
</ul>

<h2 id="tracert-命令-windows-traceroute命令-linux">tracert 命令(windows) / traceroute命令（linux）</h2>

<p>Tracert命令用来显示数据包到达目标主机所经过的路径，并显示到达每个节点的时间，分析网络延时产生的原因。
Tracert命令用来显示数据包到达目标主机所经过的路径，并显示到达每个节点的时间。命令功能同Ping类似，但它所获得的信息要比Ping命令详细得多，它把数据包所走的全部路径、节点的IP以及花费的时间都显示出来。该命令比较适用于大型网络。
命令格式：
tracert IP地址或主机名 [-d][-h maximumhops][-j host_list] [-w timeout]
参数含义：</p>

<ul>
<li>-d 不解析目标主机的名字；</li>
<li>-h maximum_hops 指定搜索到目标地址的最大跳跃数；</li>
<li>-j host_list 按照主机列表中的地址释放源路由；</li>
<li>-w timeout 指定超时时间间隔，程序默认的时间单位是毫秒。</li>
</ul>

<p><img src="/计算机网络学习-测试通信/tracert.png" alt="tracert" /></p>

<p>ps: 很实用的一个命令，在使用京东的云主机的时候，出现访问腾讯地图延时过长的问题，使用命令分析后发现是京东云主机默认的主dns服务器对腾讯地图的地址解析过慢（10s以上），更换dns为8.8.8.8后解决问题</p>

<h2 id="netstat-命令">netstat 命令</h2>

<p>Netstat命令了解网络的整体使用情况。显示当前正在活动的网络连接的详细信息，例如显示网络连接、路由表和网络接口信息，统计目前总共有哪些网络连接正在运行。
参数含义：</p>

<ul>
<li>-a  显示所有连接和侦听端口。</li>
<li>-b  显示在创建每个连接或侦听端口时涉及的可执行程序。在某些情况下，已知可执行程序承载多个独立的组件，这些情况下，显示创建连接或侦听端口时涉及的组件序列。此情况下，可执行程序的名称位于底部[]中，它调用的组件位于顶部，直至达到 TCP/IP。注意，此选项可能很耗时，并且在没有足够权限时可能失败。</li>
<li>-e   显示以太网统计。此选项可以与 -s 选项结合使用。</li>
<li>-f   显示外部地址的完全限定域名(FQDN)。</li>
<li>-n   以数字形式显示地址和端口号。</li>
<li>-o   显示拥有的与每个连接关联的进程 ID。</li>
<li>-p proto  显示 proto 指定的协议的连接；proto 可以是下列任何一个: TCP、UDP、TCPv6 或 UDPv6。如果与 -s 选项一起用来显示每个协议的统计，proto 可以是下列任何一个: IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP或 UDPv6。</li>
<li>-r    显示路由表。</li>
<li>-s    显示每个协议的统计。默认情况下，显示IP、IPv6、ICMP、ICMPv6、TCP、TCPv6、UDP 和 UDPv6的统计；-p 选项可用于指定默认的子网。</li>
<li>-t    显示当前连接卸载状态。
<img src="/计算机网络学习-测试通信/netstat.png" alt="netstat" /></li>
</ul>

<h2 id="arp-命令">arp 命令</h2>

<p>利用ARP确定对应IP地址的网卡物理地址。查看本地计算机或另一台计算机的ARP高速缓存中的当前内容。
<img src="/计算机网络学习-测试通信/arp.png" alt="arp" /></p>

<h1 id="测试dns服务器与smtp服务器">测试dns服务器与smtp服务器</h1>

<h2 id="nslookup-命令使用">nslookup 命令使用</h2>

<p>先从13个根名称服务器中任选一个（本次选择 198.41.0.4）去查找能解析.com的顶级域的域名
<img src="/计算机网络学习-测试通信/nslookup1.png" alt="nslookup" /></p>

<p>再任选一个（本次选择a.gtld-servers.net）上步给出的顶级域的域名，去查找能解析 baidu.com 的权威名称服务器的域名
<img src="/计算机网络学习-测试通信/nslookup2.png" alt="nslookup" /></p>

<p>再去上步给出的权威名称服务器中去查找 yun.baidu.com ，最终得到结果
<img src="/计算机网络学习-测试通信/nslookup3.png" alt="nslookup" /></p>

<h2 id="telnet-命令">telnet 命令</h2>

<p>远程连接命令</p>

<h3 id="smtp">Smtp:</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Telnet smtp.163.com  25
Helo wang
Auth login
dzMyMTEwNDE4QDE2My5jb20=
d2FuZ3J1aQ==
MAIL FROM:&lt;w32110418@163.com&gt;
RCPT TO:&lt;32110418@qq.com&gt;
Data
TO: 32110418@qq.com
FROM: w32110418@163.com
Subject :test mail
Hahaha
Hahahah
Heheheh
Hehehe
.
Quit</code></pre></td></tr></table>
</div>
</div>
<p><img src="/计算机网络学习-测试通信/telnet.png" alt="telnet" /></p>

<h3 id="pop3">Pop3:</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">Telnet pop.163.com 110
User w32110418
Pass 120410228
Stat
List 3
Retr 4
Quit</code></pre></td></tr></table>
</div>
</div>
<p><img src="/计算机网络学习-测试通信/pop3.png" alt="telnet" /></p>

<p><img src="/计算机网络学习-测试通信/pop3-2.png" alt="telnet" /></p>

<p>两种方法都可以实现dos环境下，对邮件的一些操作。但是在操作的过程中，一但输入错误，就必须重新输入，有点烦琐。
smtp下，向目标发送的必须是base64转换后的内容。而pop3下就不需要这步。
有的邮箱必须是得开启选项后，才能使用这种方法。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" term="计算机网络" label="计算机网络" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" term="计算机网络" label="计算机网络" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">linux 常用命令</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" />
            <id>https://blog.vgmdj.cn/posts/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</id>
            <updated>2018-05-01T09:53:17+00:00</updated>
            <published>2018-03-07T15:23:50+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[记录一下时不时就会遇到，但总是会忘记的几个命令，用到了再来翻一下就好了
bash 篇 多条件匹配  -eq = -ne != -gt > -lt < -ge >= -le <=  以上适用于数字]]></summary>
            
                <content type="html"><![CDATA[<p>记录一下时不时就会遇到，但总是会忘记的几个命令，用到了再来翻一下就好了</p>

<h1 id="bash-篇">bash 篇</h1>

<h2 id="多条件匹配">多条件匹配</h2>

<ul>
<li>-eq  =</li>
<li>-ne  !=</li>
<li>-gt  &gt;</li>
<li>-lt  &lt;</li>
<li>-ge  &gt;=</li>
<li>-le  &lt;=</li>
</ul>

<p><strong>以上适用于数字</strong></p>

<ul>
<li>-a  &amp;&amp;</li>

<li><p>-o  ||</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">例： 设a=3,b=4,c=5, if (a + b &gt; c &amp;&amp;  b-a &lt; c ) print (&#34;yes&#34;)

if [a+b -gt c  -a b-a -lt c  ]; then
echo &#34;yes&#34;
fi</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h2 id="查看端口占用">查看端口占用</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  sudo netstat -apn | grep port</code></pre></td></tr></table>
</div>
</div>
<h2 id="卸载">卸载</h2>

<ul>
<li><p>apt purge / apt –purge remove
删除已安装包（不保留配置文件)。
如软件包a，依赖软件包b，则执行该命令会删除a，而且不保留配置文</p></li>

<li><p>apt autoremove
删除为了满足依赖而安装的，但现在不再需要的软件包（包括已安装包），保留配置文件。</p></li>

<li><p>apt remove
删除已安装的软件包（保留配置文件），不会删除依赖软件包，且保留配置文件。</p></li>

<li><p>apt autoclean
APT的底层包是dpkg, 而dpkg 安装Package时, 会将 *.deb 放在 /var/cache/apt/archives/中，apt-get autoclean 只会删除 /var/cache/apt/archives/ 已经过期的deb</p></li>

<li><p>apt clean
使用 apt-get clean 会将 /var/cache/apt/archives/ 的 所有 deb 删掉，可以理解为 rm /var/cache/apt/archives/*.deb。</p></li>
</ul>

<h2 id="查看存储空间">查看存储空间</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">free 查看内存使用情况
df -h 查看各挂载点所占用和可用空间
du -sh * 查看当前目录下所有文件和文件夹所占空间</code></pre></td></tr></table>
</div>
</div>
<h2 id="生成ssh密钥">生成ssh密钥</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ssh-keygen -t rsa</code></pre></td></tr></table>
</div>
</div>
<h2 id="进程查看">进程查看</h2>

<ul>
<li>-e 显示所有的进程</li>

<li><p>-f 显示全格式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">ps -ef | grep nginx
可以查看nginx的运行情况</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h2 id="进程结束-kill">进程结束 kill</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">kill -15 pid = kill pid , SIGTERM,  通知程序正常退出
kill -9 pid , SIGKILL， 使程序强制退出</code></pre></td></tr></table>
</div>
</div>
<h1 id="vim-篇">vim 篇</h1>

<h2 id="显示行号">显示行号</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">：set number</code></pre></td></tr></table>
</div>
</div>
<h2 id="替换">替换</h2>

<ul>
<li><p>当前行替换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">:s/src/dst/g</code></pre></td></tr></table>
</div>
</div></li>

<li><p>全文替换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">:%s/src/dst/g</code></pre></td></tr></table>
</div>
</div></li>

<li><p>全文确认替换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">:%s/src/dst/gc</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h1 id="git篇">git篇</h1>

<h2 id="设置代理">设置代理</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">增加
git config --global http.proxy &#39;socks5://127.0.0.1:1080&#39;
git config --global https.proxy &#39;socks5://127.0.0.1:1080&#39;

删除
git config --global --unset http.proxy
git config --global --unset https.proxy</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/linux/" term="linux" label="linux" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/linux/" term="linux" label="linux" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%91%BD%E4%BB%A4/" term="命令" label="命令" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">go语言学习-sync</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-sync/" />
            <id>https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-sync/</id>
            <updated>2018-04-06T15:23:58+00:00</updated>
            <published>2017-08-02T13:23:51+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[sync包介绍 sync包是go提供的实现锁机制的集合]]></summary>
            
                <content type="html"><![CDATA[<h2 id="sync包介绍">sync包介绍</h2>

<p>sync包是go提供的实现锁机制的集合</p>

<h2 id="sync-mutex">sync.Mutex</h2>

<p>sync.Mutex是互斥锁，它的作用是守护在临界区入口来确保同一时间只能有一个线程进入临界区。</p>

<h2 id="sync-rwmutex">sync.RWMutex</h2>

<p>sync.RWMutex是读写锁，它的作用是允许同一时间多个线程对变量进行读操作，但是只能一个线程进行写操作，常用于读操作远远多于写操作的场景下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"> l := new(sync.RWMutex)</code></pre></td></tr></table>
</div>
</div>
<ul>
<li><p>l.RLock 读锁
当有写锁时，无法加载读锁，当只有读锁或者没有锁时，可以加载多个读锁，所有适合读多写少的场景</p></li>

<li><p>l.RUnlock 读解锁
对之前加的读锁进行解锁，需要注意的是，一旦没有读锁，而进行解锁，就会引发一个运行时错误</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">// RUnlock undoes a single RLock call;
// it does not affect other simultaneous readers.
// It is a run-time error if rw is not locked for reading
// on entry to RUnlock.
func (rw *RWMutex) RUnlock() {
	if race.Enabled {
		_ = rw.w.state
		race.ReleaseMerge(unsafe.Pointer(&amp;rw.writerSem))
		race.Disable()
	}
	if r := atomic.AddInt32(&amp;rw.readerCount, -1); r &lt; 0 {
		if r+1 == 0 || r+1 == -rwmutexMaxReaders {
			race.Enable()
			throw(&#34;sync: RUnlock of unlocked RWMutex&#34;)
		}
		// A writer is pending.
		if atomic.AddInt32(&amp;rw.readerWait, -1) == 0 {
			// The last reader unblocks the writer.
			runtime_Semrelease(&amp;rw.writerSem, false)
		}
	}
	if race.Enabled {
		race.Enable()
	}
}</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<p>readerCount是读锁的计数，一旦读解锁比加锁多，则readerCount小于0，会抛出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">throw(&#34;sync: RUnlock of unlocked RWMutex&#34;)</code></pre></td></tr></table>
</div>
</div>
<ul>
<li><p>l.Lock 写锁
当有读锁时，写锁会等待读锁解锁后，再进行加锁，即同一变量加读锁后再加写锁，写锁会阻塞</p></li>

<li><p>死锁
写锁等待读锁解锁，读锁解锁等待加写锁，引发死锁。当然，go的并发编程里还有别的情况会引发死锁，比如channel, WaitGroup等</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">l := new(sync.RWMutex)
	l.RLock()
	l.Lock()
	l.RUnlock()
	l.Unlock()</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h2 id="sync-waitgroup">sync.WaitGroup</h2>

<p>WaitGroup用于等待一组goroutine执行完成，主线程调用Add方法来设置要等待的goroutine数量，每个goroutine运行后会调用Done方法，同时Wait方法会一直堵塞直到所有goroutine执行完成。包含三个函数Add(), Done(), Wait()
- Add(delta int)<br />
  使计数器加delta</p>

<ul>
<li><p>Done()
使计数器减1</p></li>

<li><p>Wait()
等待计数器变为0</p></li>

<li><p>并发的输出0-4</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;log&#34;</span>
	<span class="s">&#34;sync&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">wg</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">{</span><span class="p">}</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">defer</span> <span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">(</span><span class="p">)</span>
			<span class="nx">log</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;i:%d&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="p">}</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">(</span><span class="p">)</span>

	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;exit&#34;</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h2 id="sync-cond">sync.Cond</h2>

<p>sync.Cond是用来控制某个条件下，goroutine进入等待时期，等待信号到来，然后重新启动。比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;sync&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">locker</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">)</span>
    <span class="nx">cond</span> <span class="o">:=</span> <span class="nx">sync</span><span class="p">.</span><span class="nf">NewCond</span><span class="p">(</span><span class="nx">locker</span><span class="p">)</span>
    <span class="nx">done</span> <span class="o">:=</span> <span class="kc">false</span>

    <span class="nx">cond</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Lock</span><span class="p">(</span><span class="p">)</span>

    <span class="k">go</span> <span class="kd">func</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mf">2e9</span><span class="p">)</span>
        <span class="nx">done</span> <span class="p">=</span> <span class="kc">true</span>
        <span class="nx">cond</span><span class="p">.</span><span class="nf">Signal</span><span class="p">(</span><span class="p">)</span>
    <span class="p">}</span><span class="p">(</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="p">!</span><span class="nx">done</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">cond</span><span class="p">.</span><span class="nf">Wait</span><span class="p">(</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;now done is &#34;</span><span class="p">,</span> <span class="nx">done</span><span class="p">)</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里当主goroutine进入cond.Wait的时候，就会进入等待，当从goroutine发出信号之后，主goroutine才会继续往下面走。</p>

<p>sync.Cond还有一个BroadCast方法，用来通知唤醒所有等待的gouroutine。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">&#34;fmt&#34;</span>
    <span class="s">&#34;sync&#34;</span>
    <span class="s">&#34;time&#34;</span>
<span class="p">)</span>

<span class="kd">var</span> <span class="nx">locker</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span><span class="p">)</span>
<span class="kd">var</span> <span class="nx">cond</span> <span class="p">=</span> <span class="nx">sync</span><span class="p">.</span><span class="nf">NewCond</span><span class="p">(</span><span class="nx">locker</span><span class="p">)</span>

<span class="kd">func</span> <span class="nf">test</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>

    <span class="nx">cond</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Lock</span><span class="p">(</span><span class="p">)</span> <span class="c1">// 获取锁
</span><span class="c1"></span>    <span class="nx">cond</span><span class="p">.</span><span class="nf">Wait</span><span class="p">(</span><span class="p">)</span>   <span class="c1">// 等待通知  暂时阻塞
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span>
    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">cond</span><span class="p">.</span><span class="nx">L</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">(</span><span class="p">)</span> <span class="c1">// 释放锁，不释放的话将只会有一次输出
</span><span class="c1"></span><span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">(</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">40</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="k">go</span> <span class="nf">test</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;start all&#34;</span><span class="p">)</span>
    <span class="nx">cond</span><span class="p">.</span><span class="nf">Broadcast</span><span class="p">(</span><span class="p">)</span> <span class="c1">//  下发广播给所有等待的goroutine
</span><span class="c1"></span>    <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>主gouroutine开启后，可以创建多个从gouroutine，从gouroutine获取锁后，进入cond.Wait状态，当主gouroutine执行完任务后，通过BroadCast广播信号。
处于cond.Wait状态的所有gouroutine收到信号后将全部被唤醒并往下执行。需要注意的是，从gouroutine执行完任务后，需要通过cond.L.Unlock释放锁， 否则其它被唤醒的gouroutine将没法继续执行。
通过查看cond.Wait 的源码就明白为什么需要需要释放锁了</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func (c *Cond) Wait() {
    c.checker.check()
    if raceenabled {
        raceDisable()
    }
    atomic.AddUint32(&amp;c.waiters, 1)
    if raceenabled {
        raceEnable()
    }
    c.L.Unlock()
    runtime_Syncsemacquire(&amp;c.sema)
    c.L.Lock()
}</code></pre></td></tr></table>
</div>
</div>
<p>Cond.Wait会自动释放锁等待信号的到来，当信号到来后，第一个获取到信号的Wait将继续往下执行并从新上锁，如果不释放锁， 其它收到信号的gouroutine将阻塞无法继续执行。
由于各个Wait收到信号的时间是不确定的，因此每次的输出顺序也都是随机的。</p>

<h2 id="sync-once">sync.Once</h2>

<p>可用此函数实现单例模式
详情可见于 <a href="https://blog.vgmdj.cn/tags/设计模式/" target="_blank">https://blog.vgmdj.cn/tags/设计模式/</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  // Once is an object that will perform exactly one action.
  type Once struct {
  m    Mutex
  done uint32
  }

  func (o *Once) Do(f func()) {
	if atomic.LoadUint32(&amp;o.done) == 1 {
		return
	}
	// Slow-path.
	o.m.Lock()
	defer o.m.Unlock()
	if o.done == 0 {
		defer atomic.StoreUint32(&amp;o.done, 1)
		f()
	}
}</code></pre></td></tr></table>
</div>
</div>
<p>对于Once的实例 o ，如果其done为1，即已经完成do操作，则直接返回，否则加锁更新为1，并执行函数f</p>

<h2 id="sync-pool">sync.Pool</h2>

<p>临时对象池，当多个goroutine都需要创建同一个对象的时候，如果goroutine过多，可能导致对象的创建数目剧增。 而对象又是占用内存的，进而导致的就是内存回收的GC压力徒增。造成“并发大－占用内存大－GC缓慢－处理并发能力降低－并发更大”这样的恶性循环。 在这个时候，我们非常迫切需要有一个对象池，每个goroutine不再自己单独创建对象，而是从对象池中获取出一个对象（如果池中已经有的话）。 这就是sync.Pool出现的目的了。
sync.Pool的使用非常简单，提供两个方法:Get和Put 和一个初始化回调函数New。
需要注意的是，因为sync.Pool 没有关于容量的限制，所以其中保存的任何项都可能随时不做通知的释放掉，所以不适合用于像socket长连接或数据库连接池。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/golang/" term="Golang" label="Golang" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/golang/" term="Golang" label="Golang" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">go语言学习-总览</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/" />
            <id>https://blog.vgmdj.cn/posts/go%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/</id>
            <updated>2017-08-01T15:23:58+00:00</updated>
            <published>2017-08-01T13:23:51+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[前言 本文主要是记录go语言学习过程中遇到的一些难点，在此用于分享和备忘，如有错误或更好的见解，请留言]]></summary>
            
                <content type="html"><![CDATA[<h2 id="前言">前言</h2>

<p>本文主要是记录go语言学习过程中遇到的一些难点，在此用于分享和备忘，如有错误或更好的见解，请留言</p>

<h2 id="目录">目录</h2>

<p><a href="https://blog.vgmdj.cn/tags/Golang" target="_blank">https://blog.vgmdj.cn/tags/Golang</a></p>

<h2 id="安装和编译">安装和编译</h2>

<h2 id="机制">机制</h2>

<ul>
<li>并发</li>
</ul>

<h2 id="特性">特性</h2>

<h2 id="源码解析">源码解析</h2>

<ul>
<li>map</li>
<li>sync</li>
<li>interface</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/golang/" term="Golang" label="Golang" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/golang/" term="Golang" label="Golang" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">设计模式学习-单例模式</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</id>
            <updated>2018-09-13T14:10:12+08:00</updated>
            <published>2017-07-05T16:25:23+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[单例模式(Singleton) 保证同一个类全局只有一个实例对象 在第一次实例化后会使用静态变量保存实例，后续全局使用此静态变量 在多线程时应该考虑并发问题，防止两次调用都被判定为实例未初始化而重复初始化对象
PS： 虽然单例简单，我们还是不能任性的用，因为这样做实例会一直存在内存中，一些我们用的不是那么频繁的东西使用了单例是不是就造成了内存的浪费？大家在用单例的时候还是要多思考思考，这个模块适不适合用单例！]]></summary>
            
                <content type="html"><![CDATA[<h2 id="单例模式-singleton">单例模式(Singleton)</h2>

<p>保证同一个类全局只有一个实例对象
在第一次实例化后会使用静态变量保存实例，后续全局使用此静态变量
在多线程时应该考虑并发问题，防止两次调用都被判定为实例未初始化而重复初始化对象</p>

<p>PS： 虽然单例简单，我们还是不能任性的用，因为这样做实例会一直存在内存中，一些我们用的不是那么频繁的东西使用了单例是不是就造成了内存的浪费？大家在用单例的时候还是要多思考思考，这个模块适不适合用单例！</p>

<h2 id="资料推荐">资料推荐</h2>

<p>书籍：《大话设计模式》，《设计模式之禅》
golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p>

<h2 id="优势">优势</h2>

<p>保证在整个系统中存在唯一的实例，在并发的环境中依旧好用</p>

<h2 id="场景">场景</h2>

<p>全局共享同一个实例对象（数据库连接等）
某一处对此对象的更新全局可见</p>

<h2 id="golang-实现">golang 实现</h2>

<p>在go中可以使用这么一种机制来保证代码只执行一次，而且不需要我们手工去加锁解锁。
那就是sync包里的Once函数，它有一个Do方法，在它中的函数go会只保证仅仅调用一次</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  import (
    &#34;sync&#34;
  )

  type singleton struct {
  }

  var instance *singleton
  var once sync.Once

  func GetInstance() *singleton {
    once.Do(func() {
        instance = &amp;singleton{}
    })
    return instance
  }</code></pre></td></tr></table>
</div>
</div>
<h2 id="sync-once解析">sync.Once解析</h2>

<p>可见于 <a href="/post/go语言学习-sync"><strong>go语言学习-sync包</strong></a></p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">设计模式学习-策略模式</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</id>
            <updated>2017-07-04T16:30:50+00:00</updated>
            <published>2017-07-04T16:25:23+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[策略模式(Strategy) 策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户]]></summary>
            
                <content type="html"><![CDATA[<h2 id="策略模式-strategy">策略模式(Strategy)</h2>

<p>策略模式定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户</p>

<h2 id="资料推荐">资料推荐</h2>

<p>书籍：《大话设计模式》，《设计模式之禅》
golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p>

<h2 id="使用场景">使用场景</h2>

<p>需要有一系列不同的算法，这些算法完成的工作是同样的，只是实现不同，强调以相同的方式调用所有的算法，减少算法类和使用算法类之间的耦合</p>

<h2 id="优势">优势</h2>

<p>使代码结构清晰，便于维护，简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试
每个算法的修改都不会影响到其他的算法</p>

<h2 id="实际应用场景">实际应用场景</h2>

<p>商场商品价格计算，其中涉及到的有商品的单价，个数，折扣
折扣的策略有：</p>

<ul>
<li>固定折扣</li>
<li>满减</li>
</ul>

<h2 id="例子">例子</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  type CashSuper interface {
  	Accept(float64) float64
  }

  //CashNormal normal strategy
  type CashNormal struct{}

  func (normal CashNormal) Accept(money float64) float64 {
  	return money
  }

  //CashRebate
  type CashRebate struct {
  	moneyRebate float64
  }

  func (re CashRebate) Accept(money float64) float64 {
  	return money * re.moneyRebate
  }

  //CashReturn
  type CashReturn struct {
  	moneyCondition float64
  	moneyReturn    float64
  }

  func (re CashReturn) Accept(money float64) float64 {
  	if money &gt;= re.moneyCondition {
  		return money - re.moneyReturn
  	}
  	return money
  }

  //use simple factory optimize strategy
  type CashContext struct {
  	strategy CashSuper
  }

  func NewCashContext(acceptType string) (cashFactory CashContext) {
  	switch acceptType {
  	default:
  		fmt.Println(&#34;wrong type&#34;)

  	case &#34;normal&#34;:
  		cashFactory.strategy = CashNormal{}

  	case &#34;0.8rebate&#34;:
  		cashFactory.strategy = CashRebate{moneyRebate: 0.8}

  	case &#34;300return100&#34;:
  		cashFactory.strategy = CashReturn{300, 100}

  	}
  	return
  }

  func (cashFactory CashContext) Accept(money float64) float64 {
  	return cashFactory.strategy.Accept(money)
  }</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">设计模式学习-抽象工厂模式</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
            <updated>2017-07-03T16:30:50+00:00</updated>
            <published>2017-07-03T16:25:23+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[抽象工厂模式(Abstract Factory) 工厂模式是对象的生产器，解耦用户对具体对象的依赖。 提供一个创建一系列相关或相互依赖的接口，而无需指定它们具体的类]]></summary>
            
                <content type="html"><![CDATA[<h2 id="抽象工厂模式-abstract-factory">抽象工厂模式(Abstract Factory)</h2>

<p>工厂模式是对象的生产器，解耦用户对具体对象的依赖。
提供一个创建一系列相关或相互依赖的接口，而无需指定它们具体的类</p>

<h2 id="资料推荐">资料推荐</h2>

<p>书籍：《大话设计模式》，《设计模式之禅》
golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p>

<h2 id="应用场景">应用场景</h2>

<p>多使用于产品系列的交换，与工厂方法模式相比，区别在于，工厂方法一般只是一个工厂只产出一个产品，而抽象工厂的工厂可以产出不同的产品
类比汽车</p>

<ul>
<li><p>工厂方法</p>

<ul>
<li>A工厂  A轿车</li>
<li>B工厂  B轿车</li>
</ul></li>

<li><p>抽象工厂</p>

<ul>
<li>A工厂  A轿车， A客车， A卡车</li>
<li>B工厂  B轿车， B客车， B卡车</li>
</ul></li>
</ul>

<h2 id="优势">优势</h2>

<p>易于交换产品系列，只需要改变具体工厂即可使用不同的产品配置
让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操纵实例，产品的具体类名也被具体工厂的实现分离，不会出现在客户代码中</p>

<h2 id="实际应用场景">实际应用场景</h2>

<p>多数据库处理用户，部分的增删改查</p>

<h2 id="例子">例子</h2>

<p>代码是根据大话设计模式里的需求编写，但没有找到go中类似C++里System.Reflection的方法，所以只实现到结合简单工厂来对抽象工厂实现</p>

<ul>
<li><p>user相关</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">type User struct{}

type IUser interface {
	Insert(user User)
	Delete(user User)
}

type AccessUser struct{}

func (au AccessUser) Insert(user User) {

}

func (au AccessUser) Delete(user User) {

}

type MysqlUser struct{}

func (mu MysqlUser) Insert(user User) {

}

func (mu MysqlUser) Delete(user User) {

}</code></pre></td></tr></table>
</div>
</div></li>

<li><p>department相关</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">type Department struct {
}

type IDepartment interface {
	Insert(department Department)
	Delete(department Department)
}

type AccessDepartment struct{}

func (ad AccessDepartment) Insert(department Department) {

}

func (ad AccessDepartment) Delete(department Department) {

}

type MysqlDepartment struct{}

func (md MysqlDepartment) Insert(department Department) {

}

func (md MysqlDepartment) Delete(department Department) {

}</code></pre></td></tr></table>
</div>
</div></li>

<li><p>抽象工厂</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">const (
	Mysql  = &#34;mysql&#34;
	Access = &#34;access&#34;
)

type DatabaseFactory struct {
	DB string
}

func (df DatabaseFactory) CreateUser() IUser {
	switch df.DB {
	default:
		fmt.Println(&#34;unknown database return default mysql&#34;)
		return new(MysqlUser)

	case Mysql:
		return new(MysqlUser)

	case Access:
		return new(AccessUser)
	}

}

func (df DatabaseFactory) CreateDepartment() IDepartment {
	switch df.DB {
	default:
		fmt.Println(&#34;unknown database return default mysql&#34;)
		return new(MysqlDepartment)

	case Mysql:
		return new(MysqlDepartment)

	case Access:
		return new(AccessDepartment)
	}

}</code></pre></td></tr></table>
</div>
</div></li>

<li><p>调用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func TestDatabaseFactory(t *testing.T) {
	user := User{}
	mysqlUser := DatabaseFactory{&#34;mysql&#34;}.CreateUser()
	mysqlUser.Insert(user)

	deppartment := Department{}
	accessDepartment := DatabaseFactory{&#34;access&#34;}.CreateDepartment()
	accessDepartment.Delete(deppartment)

}</code></pre></td></tr></table>
</div>
</div></li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">设计模式学习-工厂方法模式</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</id>
            <updated>2017-07-02T16:30:50+00:00</updated>
            <published>2017-07-02T16:25:23+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[工厂方法模式(Factory Method) 工厂模式是对象的生产器，解耦用户对具体对象的依赖。 定义了一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。
资料推荐 书籍：《大话设计模式》，《设计模式之禅》 golang相关实现例子: <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a>]]></summary>
            
                <content type="html"><![CDATA[<h2 id="工厂方法模式-factory-method">工厂方法模式(Factory Method)</h2>

<p>工厂模式是对象的生产器，解耦用户对具体对象的依赖。
定义了一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类。</p>

<h2 id="资料推荐">资料推荐</h2>

<p>书籍：《大话设计模式》，《设计模式之禅》
golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p>

<h2 id="主要类">主要类</h2>

<ul>
<li>base - interface</li>
<li>concreteA - concrete class A</li>
<li>concreteB - concrete class B</li>
<li>factory - interface</li>
<li>factoryA - factory return class A</li>
<li>factoryB - factory return class B</li>
</ul>

<h2 id="优势">优势</h2>

<p>简单工厂模式虽然实现了对象依赖的解耦，但是每次扩展都要在switch case里添加相应的选择，会修改原有的类，也就是说，违背了开放-封闭原则，而工厂方法模式则解决了这个问题。
工厂方法模式实现时，客户端需要决定实例化哪一个具体的工厂，选择问题仍然存在，但是工厂方法把简单工厂的内部逻辑判断转移到了客户端代码上来，如果要进行扩展，就不用再去修改原来的类了，只需要在客户端进行修改即可。</p>

<h2 id="实际应用场景">实际应用场景</h2>

<ul>
<li>计算器的编写
如果用简单工厂模式，一旦要实例化多个计算器，就需要连续创建多次工厂，使代码变的累赘。同时，在新增功能的时候，仍需要对之前的选择部分进行修改，没法完全使模块成为一个易扩展的独立部分</li>

<li><p>多数据库处理
使用多种数据库对用户表操作，这里应该尽量解除对具体的数据的依赖
如果不使用工厂模式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">user := new(User)
su := new(MysqlUser)
su.Insert(user)
su.Select(user)

这里的su被框死了，只能是Mysql的实现，如果要换数据库的话，所有涉及到su的地方都需要修改</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h2 id="例子-计算器">例子-计算器</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  //Operation 操作接口
  type Operation interface {
  	SetNumber(float64, float64)
  	GetResult() float64
  }

  //BaseOperation 基础类
  type BaseOperation struct {
  	Operation
  	NumberA float64
  	NumberB float64
  }

  func (bo *BaseOperation) SetNumber(numberA, numberB float64) {
  	bo.NumberA = numberA
  	bo.NumberB = numberB
  }

  //OperationAdd 加法运算
  type OperationAdd struct {
  	BaseOperation
  }

  func (oa OperationAdd) GetResult() float64 {
  	return oa.NumberA + oa.NumberB
  }

  //OperationSub 减法运算类
  type OperationSub struct {
  	BaseOperation
  }

  func (os OperationSub) GetResult() float64 {
  	return os.NumberA - os.NumberB
  }

  //OperationSubII 工厂接口
  type IFactory interface {
  	CreateOperation() Operation
  }

  type FactoryAdd struct{}

  func (fa FactoryAdd) CreateOperation() Operation {
  	return new(OperationAdd)
  }</code></pre></td></tr></table>
</div>
</div>
<h2 id="多数据库">多数据库</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  type user struct{}

  type UserDB interface {
  	Insert(u user) error
  	Select(u user) error
  }

  type MysqlUserDB struct {
  	UserDB
  }

  func (mysql MysqlUserDB) Insert(u user) error {
  	return nil
  }
  func (mysql MysqlUserDB) Select(u user) error {
  	return nil
  }

  type SqlServerUserDB struct {
  	UserDB
  }

  func (sqlServer SqlServerUserDB) Insert(u user) error {
  	return nil
  }
  func (sqlServer SqlServerUserDB) Select(u user) error {
  	return nil
  }

  type DBFactory interface {
  	CreateFactory() UserDB
  }

  type MysqlUserFactory struct{}

  func (mf MysqlUserFactory) CreateFactory() UserDB {
  	return new(MysqlUserDB)
  }

  type SqlServerFactory struct{}

  func (sf SqlServerFactory) CreateFactory() UserDB {
  	return new(SqlServerUserDB)
  }</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">设计模式学习-简单工厂模式</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
            <updated>2018-07-01T20:39:52+00:00</updated>
            <published>2017-07-01T18:39:52+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[简单工厂模式(Simple Factory) 工厂模式是对象的生产器，解耦用户对具体对象的依赖。 通过封闭、继承、多态把程序的耦合度降低，使程序更加的灵活，容易修改，并易于复用。 简单工厂模式中，各种运算方法类实现了运算接口，在业务上如果想添加一种运算方法，只需要增加一个实现运算接口的类，并且在工厂类中添加一个类型判断。 这种设计适合于业务类型并不是很多的情况，如果业务类型非常多，那么在工作类中就会有一个很长的switch…case结构，这时候使用工厂方法模式会比较合适。]]></summary>
            
                <content type="html"><![CDATA[<h2 id="简单工厂模式-simple-factory">简单工厂模式(Simple Factory)</h2>

<p>工厂模式是对象的生产器，解耦用户对具体对象的依赖。
通过封闭、继承、多态把程序的耦合度降低，使程序更加的灵活，容易修改，并易于复用。
简单工厂模式中，各种运算方法类实现了运算接口，在业务上如果想添加一种运算方法，只需要增加一个实现运算接口的类，并且在工厂类中添加一个类型判断。
这种设计适合于业务类型并不是很多的情况，如果业务类型非常多，那么在工作类中就会有一个很长的switch&hellip;case结构，这时候使用工厂方法模式会比较合适。</p>

<h2 id="主要类">主要类</h2>

<ul>
<li>base - interface</li>
<li>concreteA - concrete class A</li>
<li>concreteB - concrete class B</li>
<li>factory - in: choice; out: base</li>
</ul>

<h2 id="资料推荐">资料推荐</h2>

<p>书籍：《大话设计模式》，《设计模式之禅》
golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p>

<h2 id="优势">优势</h2>

<p>工厂类中包含了必要的逻辑判断，根据客户端的选择条件实例化相应的类，对于客户端来说，去除了与具产品的依赖</p>

<h2 id="实际应用场景">实际应用场景</h2>

<ul>
<li>计算器的编写
如果不使用工厂模式，使用面向过程的思想编写，就会出现每次扩展都需要修改原已经写好的代码，可能会使原来已经实现的功能受到影响，同时不利于阅读和理解</li>
</ul>

<h2 id="例子-计算器">例子 - 计算器</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">/*
设计一个计算器
*/

//Operation 操作接口
type Operation interface {
	SetNumber(float64, float64)
	GetResult() float64
}

//BaseOperation 基础类
type BaseOperation struct {
	Operation
	NumberA float64
	NumberB float64
}

func (bo *BaseOperation) SetNumber(numberA, numberB float64) {
	bo.NumberA = numberA
	bo.NumberB = numberB
}

//OperationAdd 加法运算
type OperationAdd struct {
	BaseOperation
}

func (oa OperationAdd) GetResult() float64 {
	return oa.NumberA + oa.NumberB
}

//OperationSub 减法运算类
type OperationSub struct {
	BaseOperation
}

func (os OperationSub) GetResult() float64 {
	return os.NumberA - os.NumberB
}

//OperationFactory 工厂类
type OperationFactory struct{}

func (of OperationFactory) CreateOperation(oper string) Operation {
	switch oper {
	default:
		return nil
	case &#34;+&#34;:
		return new(OperationAdd)
	case &#34;-&#34;:
		return new(OperationSub)

	}
}

//OperationUsage 工厂操作
func OperationUsage() {
factory := new(OperationFactory)
operation := factory.CreateOperation(&#34;+&#34;)
operation.SetNumber(1, 2)
fmt.Printf(&#34;this is add operation, 1+2=%v\n&#34;, operation.GetResult())

operation = factory.CreateOperation(&#34;-&#34;)
operation.SetNumber(2, 1)
fmt.Printf(&#34;this is sub operation, 2-1=%v\n&#34;, operation.GetResult())

}</code></pre></td></tr></table>
</div>
</div>
<h2 id="例子-手机厂商">例子 - 手机厂商</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">/*
设计一个工厂来生产各种厂商的手机
其中初始的厂商有小米，苹果，华为

*/

//Phone interface
type Phone interface {
	ShowBrand()
}

//IPhone apple
type IPhone struct {
}

func (phone IPhone) ShowBrand() {
	fmt.Println(&#34;[Phone Brand]: Apple&#34;)
}

//HPhone huawei
type HPhone struct {
}

func (phone HPhone) ShowBrand() {
	fmt.Println(&#34;[Phone Brand]: Huawei&#34;)
}

//XPhone xiaomi
type XPhone struct {
}

func (phone XPhone) ShowBrand() {
	fmt.Println(&#34;[Phone Brand]: Xiaomi&#34;)
}

type PhoneFactory struct{}

func (factory PhoneFactory) CreatePhone(brand string) Phone {
	switch brand {
	default:
		return nil
	case &#34;HW&#34;:
		return new(HPhone)
	case &#34;XM&#34;:
		return new(XPhone)
	case &#34;PG&#34;:
		return new(IPhone)

	}
}

func PhoneUsage() {
	factory := PhoneFactory{}
	phone := factory.CreatePhone(&#34;HW&#34;)
	phone.ShowBrand()

}</code></pre></td></tr></table>
</div>
</div>
<h2 id="调用及运行结果">调用及运行结果</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func main() {
	OperationUsage()
	PhoneUsage()
}

result :

this is add operation, 1+2=3
this is sub operation, 2-1=1
[Phone Brand]: Huawei</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">设计模式学习-设计原则</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0-%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</id>
            <updated>2017-07-25T21:02:53+00:00</updated>
            <published>2017-07-01T14:50:28+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[设计模式原则 每个设计模式的都是为了解决一些实际开发中的问题而被设计出来，在设计的过程中，一般都会遵循以下这些原则]]></summary>
            
                <content type="html"><![CDATA[<h1 id="设计模式原则">设计模式原则</h1>

<p>每个设计模式的都是为了解决一些实际开发中的问题而被设计出来，在设计的过程中，一般都会遵循以下这些原则</p>

<h1 id="单一职责原则-srp-single-responsibility-principle">单一职责原则(SRP，Single Responsibility Principle)</h1>

<p>定义：就一个类而言，应该仅有一个引起它变化的原因。</p>

<p>从这句定义我们很难理解它的含义，通俗讲就是我们不要让一个类承担过多的职责。如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到破坏。</p>

<p>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分享。</p>

<p>如果能想到多于一个动机去改变一个类，那么这个类就具有多于一个职责，就应该考虑职责分离。</p>

<h1 id="开放封闭原则-ocp-the-open-closed-principle">开放封闭原则(OCP，The Open-Closed Principle)</h1>

<p>定义：类、模块、函数等等等应该是可以拓展的，但是不可修改。</p>

<p>开放封闭有两个含义，一个是对于拓展是开放的 (open for extension)，另一个是对于修改是封闭的 (closed for modification)。对于开发来说需求肯定是要变化的，但是新需求一来，我们就要把类重新改一遍这显然是令人头疼的，所以我们设计程序时面对需求的改变要尽可能的保证相对的稳定，尽量用新代码实现拓展来修改需求，而不是通过修改原有的代码来实现。</p>

<p>但是，无论模块是多么的封闭，都会有一些无法对之封闭的变化。既然不可能完全封闭，那么设计人员必须对他设计的模块应该对哪种变化封闭做出选择。必须无猜测出最有可能发生的变化种类，然后构造抽象来隔离这些变化。</p>

<p>我们在最初编写程序时，可以假设变化不会发生。变化发生时，我们就需要创建抽象来隔离以后发生的同类变化。</p>

<p>面对需求，对程序的改动是通过添加新代码进行的，而不是更改现有的代码。
例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">客户端类 -&gt; 加法类

                             - 加法类（GetResult）
客户端类 -&gt; 运算类（GetResult） - 减法类（GetResult）
                             - 乘法类（GetResult）
                             - 除法类（GetResult）</code></pre></td></tr></table>
</div>
</div>
<p>我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难，成本会越来越高。</p>

<p>开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。</p>

<h1 id="依赖倒置原则-dip-dependance-inversion-principle">依赖倒置原则(DIP, Dependance Inversion Principle)</h1>

<p>定义：高层模块不应该依赖低层模块，两个都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p>

<p>其本质就是要针对接口编程，而不是对实现编程。</p>

<p>依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。</p>

<p>在面向过程的开发时，为了使得常用代码可以复用，一般都会把这些常用代码写成许许多多函数的程序库，这样我们在做新项目时，去调用这些低层的函数就可以了。比如我们做的项目大多要访问数据库，所以我们就把访问数据库的代码写成了函数，每次做新项目时去调用这些函数。这也就叫做高层模块依赖低层模块。</p>

<p>如果高层模块的业务逻辑一致，但用到的低层模块却不一样，由于高层和低层的绑定耦合，就会造成没法复用高层模块。</p>

<p>而如果高层和低层都依赖于抽象，也就是依赖于接口或抽象类，那么只要接口稳定，任何一个更改都不用担心其他受到影响，这就能使得无论高层还是低层都可以很容易被复用。</p>

<h1 id="里氏替换原则-lsp-liskov-substitution-principle">里氏替换原则(LSP, Liskov Substitution Principle)</h1>

<p>定义：所有引用基类（父类）的地方必须能透明地使用其子类的对象
里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。</p>

<p>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。
在使用里氏代换原则时需要注意如下几个问题：</p>

<p>子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</p>

<p>我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。</p>

<h1 id="迪米特原则-lod-law-of-demeter">迪米特原则(LoD, Law of Demeter)</h1>

<p>定义：一个软件实体应当尽可能少地与其他实体发生相互作用,也称为最少知识原则。</p>

<p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。</p>

<p>迪米特潜规则其根本思想，是强调了类的松耦合。类之间的耦合越弱，越有利于复用，一个处于弱耦合的类被修改，不会对有关系的类造成波及。</p>

<p>如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。</p>

<p>迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</p>

<p>在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</p>

<h1 id="接口隔离原则-isp-interface-isolation-principle">接口隔离原则(ISP, Interface Isolation Principle)</h1>

<p>定义：客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。
建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。
采用接口隔离原则对接口进行约束时，要注意以下几点：</p>

<p>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。
为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。
提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p>

<p>这六个原则，可以使我们在应用的迭代维护中更加方便、轻松的应对，让我们的软件更加灵活。在后续的文章中我会给大家介绍其他的设计模式。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">设计模式学习-总览</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E8%A7%88/" />
            <id>https://blog.vgmdj.cn/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%80%BB%E8%A7%88/</id>
            <updated>2017-07-01T16:39:52+00:00</updated>
            <published>2017-07-01T14:39:52+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[前言 本文主要是将书中资源整理总结，用于分享和回顾复习，如有错误或更好见解，请留言
目录 <a href="https://blog.vgmdj.cn/tags/设计模式/" target="_blank">https://blog.vgmdj.cn/tags/设计模式/</a>
资料推荐 书籍：《大话设计模式》，《设计模式之禅》 golang相关实现例子: <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a>]]></summary>
            
                <content type="html"><![CDATA[<h2 id="前言">前言</h2>

<p>本文主要是将书中资源整理总结，用于分享和回顾复习，如有错误或更好见解，请留言</p>

<h2 id="目录">目录</h2>

<p><a href="https://blog.vgmdj.cn/tags/设计模式/" target="_blank">https://blog.vgmdj.cn/tags/设计模式/</a></p>

<h2 id="资料推荐">资料推荐</h2>

<p>书籍：《大话设计模式》，《设计模式之禅》
golang相关实现例子:  <a href="https://github.com/vgmdj/go_practice/tree/master/design_pattern" target="_blank">https://github.com/vgmdj/go_practice/tree/master/design_pattern</a></p>

<h2 id="面向对象的优点">面向对象的优点</h2>

<ul>
<li>可维护</li>
<li>可扩展</li>
<li>可复用</li>
<li>灵活性好</li>
</ul>

<h2 id="设计模式的特点">设计模式的特点</h2>

<p>可最大化的实现面向对象的优点</p>

<h2 id="设计模式原则">设计模式原则</h2>

<ul>
<li>单一职责原则</li>
<li>开放-封闭原则</li>
<li>依赖倒转原则</li>
</ul>

<h2 id="分类">分类</h2>

<h3 id="创建型模式">创建型模式</h3>

<ul>
<li>简单工厂模式（Simple Factory）</li>
<li>工厂方法模式（Factory Method）</li>
<li>抽象工厂模式（Abstract Factory）</li>
<li>创建者模式（Builder）</li>
<li>原型模式（Prototype）</li>
<li>单例模式（Singleton）</li>
</ul>

<h3 id="结构型模式">结构型模式</h3>

<ul>
<li>外观模式（Facade）</li>
<li>适配器模式（Adapter）</li>
<li>代理模式（Proxy）</li>
<li>组合模式（Composite）</li>
<li>享元模式（Flyweight）</li>
<li>装饰模式（Decorator）</li>
<li>桥模式（Bridge）</li>
</ul>

<h3 id="行为型模式">行为型模式</h3>

<ul>
<li>中介者模式（Mediator）</li>
<li>观察者模式（Observer）</li>
<li>命令模式（Command）</li>
<li>迭代器模式（Iterator）</li>
<li>模板方法模式（Template Method）</li>
<li>策略模式（Strategy）</li>
<li>状态模式（State）</li>
<li>备忘录模式（Memento）</li>
<li>解释器模式（Interpreter）</li>
<li>职责链模式（Chain of Responsibility）</li>
<li>访问者模式（Visitor）</li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" term="设计模式" label="设计模式" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">算法学习-排序</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/" />
            <id>https://blog.vgmdj.cn/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%8E%92%E5%BA%8F/</id>
            <updated>2019-05-18T16:23:50+00:00</updated>
            <published>2017-03-18T16:23:50+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[总述 算法的排序，一方面作为其他算法的基础，一方面也体现了一些重要的算法的思想，需要我们好好掌握。 排序是根据某种标准将一组记录重排的过程，是最常见的计算任务之一。
设有一个序列{a1, a2, a3,… an},对于序列中任意两个元素ai,aj，若iaj，则说明ai和aj是一对逆序对。 实际上，排序过程就是调整记录的初始序列中逆序对的过程。 本章代码的go语言实现都可见于： <a href="https://github.com/vgmdj/go_practice/tree/master/algorithm/sort" target="_blank">https://github.com/vgmdj/go_practice/tree/master/algorithm/sort</a>]]></summary>
            
                <content type="html"><![CDATA[<h2 id="总述">总述</h2>

<p>算法的排序，一方面作为其他算法的基础，一方面也体现了一些重要的算法的思想，需要我们好好掌握。
排序是根据某种标准将一组记录重排的过程，是最常见的计算任务之一。</p>

<p>设有一个序列{a1, a2, a3,&hellip; an},对于序列中任意两个元素ai,aj，若i<j,ai>aj，则说明ai和aj是一对逆序对。
实际上，排序过程就是调整记录的初始序列中逆序对的过程。
本章代码的go语言实现都可见于： <a href="https://github.com/vgmdj/go_practice/tree/master/algorithm/sort" target="_blank">https://github.com/vgmdj/go_practice/tree/master/algorithm/sort</a></p>

<h2 id="排序的稳定性">排序的稳定性</h2>

<p>若对于关键字值 Ki = Kj (0&lt;=i, j &lt;= n-1,i!=j)，在排序前记录序列中的 Ri 位于 Rj 之前 ，在排序后的序列中Ri 仍位于 Rj 之前，那么称所用的排序方法是稳定的。</p>

<h2 id="复杂度">复杂度</h2>

<p>关键字值的比较次数与记录的移动次数决定着排序算法的时间复杂度。排序算法的时间复杂度又细分为最优时间复杂度、平均时间复杂度和最差时间复杂度。
排序过程中除待排序记录所占空间外分配的工作空间为其空间复杂度。</p>

<h2 id="分类">分类</h2>

<p>根据排序记录的数量多少，又可以把排序分为内部排序和外部排序。</p>

<p>内部排序是指待排序的记录能够全部存储在计算机内存中并能完成排序的过程。</p>

<p>外部排序是指记录数量过大，不能全部保存在内存中而需要借助于外存才能完成的排序是外部排序，简称为外排序。</p>

<h2 id="冒泡排序-选择排序">冒泡排序、选择排序</h2>

<p>很基础和经典的算法，现在的作用多是为了体现算法的思想，熟悉排序的操作，在实际工作中一般是使用其中的一部分或是借用其思想解决一些问题。</p>

<ul>
<li>时间复杂度： O(n^2)</li>
<li>空间复杂度： O(1)</li>
<li>稳定性： 稳定</li>
</ul>

<h2 id="插入排序">插入排序</h2>

<p>将一个记录插入到已排好序的有序表中，从而得到一个新的，记录数加1的有序表。即：先将序列的第1个记录看成是一个有序的子序列，然后 从第2个记录逐个进行插入操作，直到整个序列有序为止。
要点是，设立一个临界点，让左边的有序区推着临界点向后，直到临界点到达最后。
对于相等的元素，会把想插入的值放在后面，临界点右移，所以，相等的元素的前后顺序也没有变化，所以插入排序是稳定的</p>

<ul>
<li>时间复杂度： O(n^2)</li>
<li>空间复杂度： O(1)</li>
<li>稳定性： 稳定</li>
</ul>

<p>代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">//插入排序
func insertSort(nums []int) {
	for i := 1; i &lt; len(nums)-1; i++ {
		for j := i; j &gt; 0 &amp;&amp; nums[j] &lt; nums[j-1]; j-- {
			nums[j], nums[j-1] = nums[j-1], nums[j]
		}
	}
}</code></pre></td></tr></table>
</div>
</div>
<h2 id="快速排序">快速排序</h2>

<p>快排是对冒泡排序的一种改进，使用范围很广，同时也是很很多语言的sort包中使用的其中一种方式（一般根据输入数据的情况选择插入排序、快速排序、堆排序中较为合适的一种）
它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列
可以根据荷兰国旗问题进行改进，使中间部分的值先排好，再对中间部分两边的进行递归</p>

<ul>
<li>时间复杂度： O(nlogn) ~ O(n^2)</li>
<li>平均时间复杂度： O(nlogn)</li>
<li>空间复杂度： O(1)</li>

<li><p>稳定性： 不稳定</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">//快速排序
func quickSort(values []int) {
	if len(values) &lt;= 1 {
		return
	}
	mid, i := values[0], 1
	head, tail := 0, len(values)-1
	for head &lt; tail {
		if values[i] &gt; mid {
			values[i], values[tail] = values[tail], values[i]
			tail--
		} else {
			values[i], values[head] = values[head], values[i]
			head++
			i++
		}
	}
	values[i-1] = mid
	quickSort(values[:i-1])
	quickSort(values[i:])

}</code></pre></td></tr></table>
</div>
</div></li>
</ul>

<h2 id="归并排序">归并排序</h2>

<p>分治法的一个典型应用，把整个序列分为左右两个有序序列，再对有序的序列归并成一个有序的序列
可有效的解决小和问题和逆序对的问题</p>

<ul>
<li>时间复杂度： O(nlogn)</li>
<li>空间复杂度： O(n)</li>
<li>稳定性： 不稳定</li>
</ul>

<p>时间复杂度的计算：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">根据master公式： T(n) = aT(n/b)+O(n^c)
a=2,b=2,c=1
则 log(2,2) == c
时间复杂度为：
O(n^1*logn)，即 O(nlogn)</code></pre></td></tr></table>
</div>
</div>
<p>代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func mergeSort(nums []int) []int {
	if len(nums) &lt;= 1 {
		return nums
	}

	mid := len(nums) / 2
	nums1 := mergeSort(nums[:mid])
	nums2 := mergeSort(nums[mid:])

	return merge(nums1, nums2)
}

func merge(nums1 []int, nums2 []int) []int {
	var nums3 []int
	var position1, position2 int

	for position1 &lt; len(nums1) &amp;&amp; position2 &lt; len(nums2) {
		if nums1[position1] &lt; nums2[position2] {
			nums3 = append(nums3, nums1[position1])
			position1++
		} else {
			nums3 = append(nums3, nums2[position2])
			position2++
		}
	}

	nums3 = append(nums3, nums1[position1:]...)
	nums3 = append(nums3, nums2[position2:]...)

	return nums3
}</code></pre></td></tr></table>
</div>
</div>
<h2 id="堆排序">堆排序</h2>

<p>利用堆的特性，父结点的值会比左右孩子结点的值大或小，那么每次将根结点取出，再对余下的结点堆化，重复这一过程，即可完成排序。</p>

<p>完全二叉树和数组的对应：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">对于数组而言，以0开始，若用数组来存储堆，因堆是一个完全二叉树，所以可以表示为：
root : i
root-&gt;left : 2*i+1
root-&gt;right: 2*i+2</code></pre></td></tr></table>
</div>
</div>
<ul>
<li>时间复杂度： O(nlogn)</li>
<li>空间复杂度： O(1)</li>
<li>稳定性： 不稳定</li>
</ul>

<p>代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">/*
堆排序分为两个部分，第一个部分是初始化，第二个部分是堆恢复

初始化：
	从最后一个非叶子结点开始进行调整，每次调整后，如果以当前结点为根结点，则这个结点也是以这个结点为根的堆的根结点

调整：
	将根结点与最后一个结点进行互换，同时，将除最后一个结点外的部分进行堆调整恢复

之所以和最后一个结点进行进行互换，是因为，这样和初始化的最后一步类似，可以复用过程

*/

func HeapSort(values []int) {
	heapInit(values)
	//for i := len(values) - 1; i &gt; 0; i-- {
	//	values[0], values[i] = values[i], values[0]
	//	minHeapify(values, 0, i-1)
	//}

	for i := len(values) - 1; i &gt; 0; i-- {
		values[0], values[i] = values[i], values[0]
		maxHeapify(values, 0, i-1)
	}

}

func heapInit(values []int) {
	for i := len(values)/2 - 1; i &gt;= 0; i-- {
		//minHeapify(values, i, len(values)-1)
		maxHeapify(values, i, len(values)-1)
	}
}

func maxHeapify(nums []int, start, end int) {
	father := start
	child := 2*father + 1

	for child &lt;= end {
		if child+1 &lt;= end &amp;&amp; nums[child] &lt; nums[child+1] {
			child++
		}

		if nums[father] &gt;= nums[child] {
			return
		}

		nums[father], nums[child] = nums[child], nums[father]
		father = child
		child = 2*father + 1

	}

}

func minHeapify(nums []int, start, end int) {
	root := start
	node := 2*root + 1

	for node &lt;= end {
		if node+1 &lt;= end &amp;&amp; nums[node+1] &lt; nums[node] {
			node++
		}

		if nums[root] &lt;= nums[node] {
			return
		}

		nums[root], nums[node] = nums[node], nums[root]
		root = node
		node = 2*root + 1

	}

}</code></pre></td></tr></table>
</div>
</div>
<h2 id="基数排序">基数排序</h2>

<p>基数排序不同于其他的通过关键字间比较和移动来实现排序的算法，基数排序主要是借助多关键字排序的思想对单逻辑关键字进行排序的方法。
为实现多关键字排序，可分为最高位优先法(Most Significant Digit first)，简称 MSD 法，和最低位优先法(Least Sigificant Digit first)，简称 LSD 法。</p>

<p>若实现的方式不同，则时间复杂度和空间复杂度也不相同，若设 d 为关键字个数，则
- 时间复杂度： O(d*n)
- 空间复杂度： O(n)
- 稳定性： 稳定</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">func RadixSort(nums []int) {
	base, length := 1, getLen(nums)

	for i := 1; i &lt;= length; i++ {
		radixSort(nums, base)
		base *= 10
	}

}

func getLen(nums []int) int {
	max, length := math.MinInt32, 0

	for _, v := range nums {
		if v &gt; max {
			max = v
		}
	}

	for max != 0 {
		max /= 10
		length++
	}

	return length
}

func radixSort(nums []int, base int) {
	bucket := make([][]int, 10)

	for _, v := range nums {
		k := v / base % 10
		bucket[k] = append(bucket[k], v)

	}

	index := 0
	for _, group := range bucket {
		for _, v := range group {
			nums[index] = v
			index++
		}
	}

}</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E7%AE%97%E6%B3%95/" term="算法" label="算法" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E7%AE%97%E6%B3%95/" term="算法" label="算法" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">我的职业发展之路</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E6%88%91%E7%9A%84%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E4%B9%8B%E8%B7%AF/" />
            <id>https://blog.vgmdj.cn/posts/%E6%88%91%E7%9A%84%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95%E4%B9%8B%E8%B7%AF/</id>
            <updated>2017-07-01T16:23:58+00:00</updated>
            <published>2017-03-05T16:23:51+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[毕业选择 随着毕业的临近，每天都会一次又一次的问自己，到底想干什么？ - 程序员 使用大学里学到的技能，为自己赚点饭钱，不停挑战自己的极限，最终成为一个在计算机领域专家 优点：各方面还算熟悉，总归是一直在计算机专业环境下，无论是想学哪块，相信都不会太难 缺点：方面不明确，行业前景看不清，没有领路人 - 公务员 就在老家，房价便宜，生活没有压力，富不起来，但也不可能饿着，身边朋友多，生活自在悠闲 优点：安逸，没必要为了生存一天到晚的忙碌和委屈求全 缺点：有上限，从性格、资源等各个方面都不相信自己有官场升职的潜力 - 转行干土木 依靠家里的资源，不停的学习，最终自己出来单独接项目，成为光荣的包工头 优点：与当程序员正相反，家里大多是这一行，发展会很顺利，基本不会走弯路 缺点：各方面都不熟悉，最开始无论是想学哪一块，都会很费劲]]></summary>
            
                <content type="html"><![CDATA[<h2 id="毕业选择">毕业选择</h2>

<p>随着毕业的临近，每天都会一次又一次的问自己，到底想干什么？
- 程序员
  使用大学里学到的技能，为自己赚点饭钱，不停挑战自己的极限，最终成为一个在计算机领域专家
  优点：各方面还算熟悉，总归是一直在计算机专业环境下，无论是想学哪块，相信都不会太难
  缺点：方面不明确，行业前景看不清，没有领路人
- 公务员
  就在老家，房价便宜，生活没有压力，富不起来，但也不可能饿着，身边朋友多，生活自在悠闲
  优点：安逸，没必要为了生存一天到晚的忙碌和委屈求全
  缺点：有上限，从性格、资源等各个方面都不相信自己有官场升职的潜力
- 转行干土木
  依靠家里的资源，不停的学习，最终自己出来单独接项目，成为光荣的包工头
  优点：与当程序员正相反，家里大多是这一行，发展会很顺利，基本不会走弯路
  缺点：各方面都不熟悉，最开始无论是想学哪一块，都会很费劲</p>

<h2 id="最终抉择">最终抉择</h2>

<p>年轻就是最大的本钱，虽说刚毕业后的三五年是人生最为关键的时期，每一年都很关键，但我本身也没有一个很明确的目标，同时我也相信自己无论选择哪一方面，最终都不会说没人要，或者是穷到吃不上饭，所以更多的是顺应自己内心的一点偏向，走上码农之路，去领略计算机职业世界的精彩。哪怕最终真的证明没这方面的天赋，行业没有自己想象的那么有趣，也可以再作出改变，我们一生可以做很多的发展选择，我相信无论哪一条路，只要能再次沉下心，去学习去锻炼，都是可以达到行业中等水平，至于能不能达到顶点，那就需要运气和悟性了。</p>

<h2 id="校招选择">校招选择</h2>

<p>春招没有参加，秋招来的公司并不算多，也没有什么大厂，最好的选择反而是亚信了，但是笔试题都跪的一塌糊涂，最终的选择是大连的外包头子-东软
最初的想法很简单，东软有大公司的制度和培训，各种外包项目也很容易让人更加了解整个计算机行业的情况，稍稍锻炼个一两年，基本就可以看清自己应该怎么选择了。
一年后再来回顾，还是觉着自己当时的选择并没有什么明显的错误，也可能直接去北京找互联网公司更好，但主要还是看个人，差距不会太大。</p>

<h2 id="东软生活">东软生活</h2>

<p>平稳，安逸的一年，各路领导都很好，很照顾我们，同学也多，老乡也多，生活也渐渐丰富起来。每天下班后，健个身或者是去旁边的大学里跑步，每个周六都可以在公司里打网球，周日一群单身狗约着一块吃自助，看电影，确实是一段很美好的经历。很多时候，我都在想，如果没有改变，就一直这样下去，可能也能活成别人眼中的潇洒人生。
但终归是年轻，总想着让生活更丰富一些，接触到更接近这个时代前沿的东西，参与到推动整个世界发展的技术研发中来，毕竟每个程序员的梦想都是去改变世界，一年期的调整已经足够，是时候开始重新进行人生规划，做一些自己想去做的事情了。</p>

<h2 id="目标北京">目标北京</h2>

<p>祝自己好运</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E5%B7%A5%E4%BD%9C/" term="工作" label="工作" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/" term="职业发展" label="职业发展" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%B7%A5%E4%BD%9C/" term="工作" label="工作" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E8%81%8C%E4%B8%9A%E5%8F%91%E5%B1%95/" term="职业发展" label="职业发展" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">算法学习-总览</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/" />
            <id>https://blog.vgmdj.cn/posts/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0-%E6%80%BB%E8%A7%88/</id>
            <updated>2017-03-05T16:23:50+00:00</updated>
            <published>2017-03-04T16:23:50+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[总结 算法是程序员实力体现的一部分，在日常工作中，不停寻求最优算法，应该是程序员的基本修奍了 下面先做一些总结，留着以后复习使用]]></summary>
            
                <content type="html"><![CDATA[<h2 id="总结">总结</h2>

<p>算法是程序员实力体现的一部分，在日常工作中，不停寻求最优算法，应该是程序员的基本修奍了
下面先做一些总结，留着以后复习使用</p>

<h2 id="基本策略">基本策略</h2>

<ul>
<li>蛮力算法</li>
<li>分治算法</li>
<li>贪心算法</li>
<li>动态规划</li>
<li>回溯算法</li>
</ul>

<h2 id="关键点">关键点</h2>

<ul>
<li>蛮力法, 在不考虑效率的情况下,找到能穷举出所有情况的通式</li>
<li>贪心法, 在于找到每一步的最优解</li>
<li>动态规划, 在于找到状态转移方程</li>
<li>回溯法, 在于能够抽出多叉树模型</li>
</ul>

<h2 id="基本概念">基本概念</h2>

<h3 id="评价标准">评价标准</h3>

<ul>
<li><p>时间复杂度</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">递归master公式
T(n) = aT(n/b)+O(n^c)
- O(n*log(b,a))         log(b,a)&gt;c
- O(n^c*logn)           log(b,a)=c
- O(n^d)                log(b,a)&lt;c</code></pre></td></tr></table>
</div>
</div></li>

<li><p>空间复杂度</p></li>
</ul>

<h2 id="算法练习">算法练习</h2>

<p>oj：</p>

<ul>
<li><a href="http://www.lintcode.com" target="_blank">http://www.lintcode.com</a></li>
<li><a href="http://www.leetcode.com" target="_blank">http://www.leetcode.com</a></li>
</ul>

<p>golang算法代码库：</p>

<ul>
<li><a href="http://github.com/vgmdj/go_practice" target="_blank">http://github.com/vgmdj/go_practice</a></li>
</ul>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E7%AE%97%E6%B3%95/" term="算法" label="算法" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E5%AD%A6%E4%B9%A0/" term="学习" label="学习" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/%E7%AE%97%E6%B3%95/" term="算法" label="算法" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">github&#43;hexo blog 搭建过程-配置</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/github-hexo-blog-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B-%E9%85%8D%E7%BD%AE/" />
            <id>https://blog.vgmdj.cn/posts/github-hexo-blog-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B-%E9%85%8D%E7%BD%AE/</id>
            <updated>2018-03-06T16:23:50+00:00</updated>
            <published>2017-03-04T02:34:39+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[站点配置文件_config.yml修改 主体可参考hexo next使用文档，下面对其进行补充。]]></summary>
            
                <content type="html"><![CDATA[<h2 id="站点配置文件-config-yml修改">站点配置文件_config.yml修改</h2>

<p>主体可参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank">hexo next使用文档</a>，下面对其进行补充。</p>

<h3 id="主题配置">主题配置</h3>

<p>推荐注释而不是删除新增</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  # Extensions
  ## Plugins: https://hexo.io/plugins/
  ## Themes: https://hexo.io/themes/
  #theme: landscape
  theme: next</code></pre></td></tr></table>
</div>
</div>
<h3 id="语言配置">语言配置</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  # Site
  language: zh-Hans

  修改为：
  language: zh-CN</code></pre></td></tr></table>
</div>
</div>
<h3 id="新增sitemap">新增sitemap</h3>

<h4 id="使用sitemap生成工具">使用sitemap生成工具</h4>

<p>配置站点地图可以将站点添加进百度收录，之后就可以在百度里搜索到站点的内容了。
在blog根目录执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  npm install hexo-generator-sitemap --save
  npm install hexo-generator-baidu-sitemap --save</code></pre></td></tr></table>
</div>
</div>
<h4 id="修改站点-config-yml配置文件">修改站点_config.yml配置文件</h4>

<p>新增内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  # sitemap
  sitemap:
    path: sitemap.xml
  baidusitemap:
    path: baidusitemap.xml</code></pre></td></tr></table>
</div>
</div>
<p>修改内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  # URL
  ## If your site is put in a subdirectory, set url as &#39;http://yoursite.com/child&#39; and root as &#39;/child/&#39;
  url: http://blog.vgmdj.cn/
  root: /
  permalink: :year/:month/:day/:title/
  permalink_defaults:

  其中url改为自己的域名</code></pre></td></tr></table>
</div>
</div>
<h4 id="向百度或谷歌提交网站">向百度或谷歌提交网站</h4>

<p>可以参考内容 <a href="https://www.cnblogs.com/tengj/p/5357879.html" target="_blank">主动提交</a>
如果使用next主题，可以简化这一过程
<a href="#jump">next 向百度站长提交内容</a></p>

<h3 id="开启本地图片存放">开启本地图片存放</h3>

<p>可查看链接，但是只有新生成的才有，如果是操作前生成的文章，则不会生成文件夹，需要自己手动创建
<a href="https://www.jianshu.com/p/c2ba9533088a" target="_blank">hexo博客图片问题</a></p>

<h3 id="hexo-deploy配置">hexo deploy配置</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  # Deployment
  ## Docs: https://hexo.io/docs/deployment.html
  deploy:
  type: git
  repository: git@github.com:vgmdj/vgmdj.github.io.git
  branch: master</code></pre></td></tr></table>
</div>
</div>
<p><a href="https://hexo.io/docs/deployment.html" target="_blank">其他配置</a></p>

<p>注意：hexo d的使用需要先配置好</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  npm install hexo-deployer-git --save</code></pre></td></tr></table>
</div>
</div>
<p>ssh免密登录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback"># 返回用户根目录 /c/Users/`whoami`
cd
ssh-keygen -t rsa -C &#34;your_email@example.com&#34;

---- 一顿回车 ----

cat ~/.ssh/id_rsa.pub</code></pre></td></tr></table>
</div>
</div>
<p>将cat 输出的内容添加到github ssh key中
打开<a href="https://github.com/settings/ssh" target="_blank">new SSH key</a> 添加密钥，title随便写，key为刚刚cat输出的内容</p>

<h3 id="github-cname文件被覆盖的问题">github cname文件被覆盖的问题</h3>

<p>cname文件注意要放在根目录下的source里，这样才不会每次部署的时候，将cname文件覆盖掉</p>

<h2 id="主题配置文件-config-yml修改">主题配置文件_config.yml修改</h2>

<p>主体可参考<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank">hexo next使用文档</a>，下面对其进行补充。</p>

<h3 id="菜单设置">菜单设置</h3>

<p>当前next主题使用的是新的指定icon的方式，即 “||” 前是page地址，后面是想要显示的icon
next使用的是<a href="https://fontawesome.com/icons?d=gallery" target="_blank">fontawesome</a>里的图标，配置文件里的图标都可以进行替换</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">menu:
  home: / || home  
  about: /about/ || user
  tags: /tags/ || tags
  categories: /categories/ || th
  archives: /archives/ || archive  </code></pre></td></tr></table>
</div>
</div>
<p>菜单中每项的意义都可以在语言配置文件中查看 /theme/next/language/zh-CN
同时，自己新增的菜单也需要在对应的语言配置文件中设置</p>

<h3 id="字数统计">字数统计</h3>

<p>需要注意的是，如果开启了leancloud_visitors，会和busuanzi里的post_views冲突，结果会是在文章里出现两个阅读量统计，所以需要将busuanzi里的post_views置为false</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  # Show number of visitors to each article.
  # You can visit https://leancloud.cn get AppID and AppKey.
  leancloud_visitors:
  enable: true
  app_id: your appid
  app_key: your app_key

  # Show Views/Visitors of the website/page with busuanzi.
  # Get more information on http://ibruce.info/2015/04/04/busuanzi/
  busuanzi_count:
    enable: true
    total_visitors: true
    total_visitors_icon: user
    total_views: true
    total_views_icon: eye
    post_views: false
    post_views_icon: eye</code></pre></td></tr></table>
</div>
</div>
<h3 id="span-id-jump-sitemap配置-span"><span id="jump">sitemap配置</span></h3>

<p>next主题对配置过程作了简化，只需要在主题配置文件里修改即可实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  seo: false
  baidu_push: false

  改为
  seo: true
  baidu_push: true</code></pre></td></tr></table>
</div>
</div>
<p>查看/theme/next/layout/_third-party/seo/baidu-push.swig文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  {% if theme.baidu_push %}
  &lt;script&gt;
  (function(){
    var bp = document.createElement(&#39;script&#39;);
    var curProtocol = window.location.protocol.split(&#39;:&#39;)[0];
    if (curProtocol === &#39;https&#39;) {
        bp.src = &#39;https://zz.bdstatic.com/linksubmit/push.js&#39;;        
    }
    else {
        bp.src = &#39;http://push.zhanzhang.baidu.com/push.js&#39;;
    }
    var s = document.getElementsByTagName(&#34;script&#34;)[0];
    s.parentNode.insertBefore(bp, s);
  })();
  &lt;/script&gt;
  {% endif %}</code></pre></td></tr></table>
</div>
</div>
<p>发现和主动推送的实现过程一致</p>

<h3 id="gitment-评论">gitment 评论</h3>

<p>使用畅言作为评论系统，首页也能显示评论数，还能使用第三方如qq等的登录，但是缺点也很明显，新用户评论，需要绑定手机号等一系列操作，有点麻烦。
考虑到受众，使用github 的issues显然更好一点。但是这个gitment的问题也比较多，其中关键的一点是标题起的稍稍长一点，都会导致无法正常初始化评论。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">修改/theme/next/layout/_third-party/comments/gitment.swig

id: window.location.pathname,
改为：
id: &#39;{{ page.date }}&#39;,</code></pre></td></tr></table>
</div>
</div>
<p>这种方式下，只要注意每篇博文的data不要乱改，导致时间一致冲突，就不会有问题
方法来源于作者君的<a href="https://github.com/imsun/gitment/issues" target="_blank">issues</a></p>

<h3 id="其他">其他</h3>

<p>百度统计、腾讯分析、畅言等都只是去各自的官网注册账号，然后在主题配置文件里填好相应的配置即可</p>

<h2 id="修改页脚">修改页脚</h2>

<p>这里只是一些我看着不太统一的地方，将其小小的修改一下</p>

<h3 id="添加总访客量-总访问量文字">添加总访客量、总访问量文字</h3>

<p>开启busuanzi后，页面最下方会生成一个访客量与访问量的统计，但只有图标与数字，而没有相应的文字
修改/theme/next/layout/_partials/analytics/busuanzi-counter.swig文件，在相应位置添加“总访客量：”与“总访问量：”的文字解释即可</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  {% if theme.busuanzi_count.enable %}
  &lt;div class=&#34;busuanzi-count&#34;&gt;
    &lt;script async src=&#34;https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js&#34;&gt;&lt;/script&gt;

    {% if theme.busuanzi_count.total_visitors %}
      &lt;span class=&#34;site-uv&#34; title=&#34;{{ __(&#39;footer.total_visitors&#39;) }}&#34;&gt;
        &lt;i class=&#34;fa fa-{{ theme.busuanzi_count.total_visitors_icon }}&#34;&gt; 总访客量：&lt;/i&gt;
        &lt;span class=&#34;busuanzi-value&#34; id=&#34;busuanzi_value_site_uv&#34;&gt;&lt;/span&gt;
      &lt;/span&gt;
    {% endif %}

    {% if theme.busuanzi_count.total_views %}
      &lt;span class=&#34;site-pv&#34; title=&#34;{{ __(&#39;footer.total_views&#39;) }}&#34;&gt;
        &lt;i class=&#34;fa fa-{{ theme.busuanzi_count.total_views_icon }}&#34;&gt; 总访问量：&lt;/i&gt;
        &lt;span class=&#34;busuanzi-value&#34; id=&#34;busuanzi_value_site_pv&#34;&gt;&lt;/span&gt;
      &lt;/span&gt;
    {% endif %}
  &lt;/div&gt;
  {% endif %}</code></pre></td></tr></table>
</div>
</div>
<h3 id="添加网站备案号">添加网站备案号</h3>

<p>打开/theme/next/layout/_partials/footer.swig
在copyright后，添加代码即可</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  &lt;div class=&#34;copyright&#34;&gt;{#
  #}{% set current = date(Date.now(), &#34;YYYY&#34;) %}{#
  #}&amp;copy; {% if theme.footer.since and theme.footer.since != current %}{{ theme.footer.since }} &amp;mdash; {% endif %}{#
  #}&lt;span itemprop=&#34;copyrightYear&#34;&gt;{{ current }}&lt;/span&gt;
  &lt;span class=&#34;with-love&#34;&gt;
    &lt;i class=&#34;fa fa-{{ theme.footer.icon }}&#34;&gt;&lt;/i&gt;
  &lt;/span&gt;
  &lt;span class=&#34;author&#34; itemprop=&#34;copyrightHolder&#34;&gt;{{ theme.footer.copyright || config.author }}&lt;/span&gt;

  !!!这里就是添加位置！！！</code></pre></td></tr></table>
</div>
</div>
<p>添加内容</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">   &lt;a href=&#34;http://www.miitbeian.gov.cn/&#34;&gt;京ICP备xxxxxx号&lt;/a&gt;</code></pre></td></tr></table>
</div>
</div>
<h3 id="完成">完成</h3>

<p>至此，一个人个博客已基本完成，其实next已经把很多的东西都简化到一个配置参数，我们需要做的，只是看懂这个参数代表的意义，然后填上他，接着运行hexo命令，即可轻松的调试部署</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">  hexo clean
  hexo g
  hexo s

  check http://localhost:4000, 发现无误后

  hexo d</code></pre></td></tr></table>
</div>
</div>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E7%AB%99%E7%82%B9%E5%BB%BA%E8%AE%BE/" term="站点建设" label="站点建设" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/github/" term="github" label="github" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/blog/" term="blog" label="blog" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/hexo/" term="hexo" label="hexo" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">github&#43;hexo blog 搭建过程-准备</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/github-blog-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B-%E5%87%86%E5%A4%87/" />
            <id>https://blog.vgmdj.cn/posts/github-blog-%E6%90%AD%E5%BB%BA%E8%BF%87%E7%A8%8B-%E5%87%86%E5%A4%87/</id>
            <updated>2018-03-05T16:23:50+00:00</updated>
            <published>2017-03-03T16:23:50+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[前言 一直都有记录的习惯，但内容大多都分散在各个网站，现结合github，使用hexo来搭建一个个人博客，将点滴的记录都聚合在一起，下面是一些关键的搭建过程，一方面作为分享，一方面作为备忘，仅供参考，如有问题请留言通知，谢谢支持！ ps: 准备过程和搜索内容没多少变化，不过多记录]]></summary>
            
                <content type="html"><![CDATA[<h1 id="前言">前言</h1>

<p>一直都有记录的习惯，但内容大多都分散在各个网站，现结合github，使用hexo来搭建一个个人博客，将点滴的记录都聚合在一起，下面是一些关键的搭建过程，一方面作为分享，一方面作为备忘，仅供参考，如有问题请留言通知，谢谢支持！
ps: 准备过程和搜索内容没多少变化，不过多记录</p>

<h1 id="基本环境准备">基本环境准备</h1>

<p>下载安装nodejs和git，我的搭建环境win10 64，可在git bash下运行如下命令测试环境：
- node -v
- npm -v
- git &ndash;version</p>

<h1 id="安装hexo">安装Hexo</h1>

<p>安装过程不再叙述，hexo的安装与使用一直没有什么变化，可自行搜索，安装成功可运行测试命令：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    hexo -v</code></pre></td></tr></table>
</div>
</div>
<p>大致命令集如下：</p>

<ul>
<li>npm -g hexo-cli</li>
<li>cd /c/Users/`whoami`</li>
<li>mkdir blog</li>
<li>cd blog</li>
<li>hexo init</li>
<li>npm install</li>
<li>hexo g</li>
<li>hexo s</li>
</ul>

<p>如果一切顺利的话，打开浏览器，访问 <a href="http://localhost:4000/" target="_blank">http://localhost:4000/</a> 便可看到hexo生成的默认主题页面</p>

<h1 id="准备主题">准备主题</h1>

<p>以next主题为例，<a href="https://github.com/theme-next/hexo-theme-next" target="_blank">github地址</a><br>
在blog根目录执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    git clone https://github.com/theme-next/hexo-theme-next themes/next</code></pre></td></tr></table>
</div>
</div>
<p>现在我们的blog文件夹内就有了三个配置文件
- 站点配置文件$addr/blog/_config.yml
- next主题配置文件$addr/blog/themes/next/_config.yml
- default主题配置文件$addr/blog/themes/landscape/_config.yml</p>

<p>修改站点配置文件，即可更换主题，后面我们再详细介绍</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    #theme: landscape
    theme: next</code></pre></td></tr></table>
</div>
</div>
<h1 id="hexo-指南">hexo 指南</h1>

<p>hexo 常用操作可见于：
<a href="http://blog.vgmdj.cn/2018/03/02/Hexo-introduction/" target="_blank">Hexo 使用指南</a></p>

<p>hexo next主题教程：
<a href="http://theme-next.iissnan.com" target="_blank">next 官网</a>
ps: 最好的教程都来源于代码和注释，其次是官网，本篇只是作为补充。</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E7%AB%99%E7%82%B9%E5%BB%BA%E8%AE%BE/" term="站点建设" label="站点建设" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/github/" term="github" label="github" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/blog/" term="blog" label="blog" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/hexo/" term="hexo" label="hexo" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Hexo 使用指南</title>
            <link rel="alternate" type="text/html" href="https://blog.vgmdj.cn/posts/hexo-introduction/" />
            <id>https://blog.vgmdj.cn/posts/hexo-introduction/</id>
            <updated>2017-03-05T16:23:50+00:00</updated>
            <published>2017-03-02T16:23:50+00:00</published>
            <author>
                    <name>VGMDJ</name>
                    <uri>https://blog.vgmdj.cn/</uri>
                    <email>vgmdj.wr@gmail.com</email>
                    </author>
            <rights>[VGMDJ.WR](https://blog.vgmdj.cn)</rights><summary type="html"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.]]></summary>
            
                <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank">GitHub</a>.</p>

<h2 id="quick-start">Quick Start</h2>

<h3 id="create-a-new-post">Create a new post</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ hexo new <span class="s2">&#34;My New Post&#34;</span></code></pre></td></tr></table>
</div>
</div>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank">Writing</a></p>

<h3 id="run-server">Run server</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ hexo server</code></pre></td></tr></table>
</div>
</div>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank">Server</a></p>

<h3 id="generate-static-files">Generate static files</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ hexo generate</code></pre></td></tr></table>
</div>
</div>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank">Generating</a></p>

<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-bash" data-lang="bash">$ hexo deploy</code></pre></td></tr></table>
</div>
</div>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank">Deployment</a></p>

<h2 id="trouble-shooting">Trouble Shooting</h2>

<h3 id="首页显示排版混乱">首页显示排版混乱</h3>

<p>在每个需要的地方，加上</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    &lt;!--more--&gt;</code></pre></td></tr></table>
</div>
</div>
<p>例如，在一级标题和二级标题间截断</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">    # 一级标题
    xxxxxxx
    &lt;!--more--&gt;

    ## 二级标题
    xxxxxxxx
    &lt;!--more--&gt;

    ## 二级标题
    xxxxxxxx
    &lt;!--more--&gt;</code></pre></td></tr></table>
</div>
</div>
<h3 id="标签和分类数量不正确">标签和分类数量不正确</h3>

<p>删除.deploy_git文件夹和db.json，再删除public文件夹</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">hexo clean
hexo g
hexo g
hexo s
hexo d</code></pre></td></tr></table>
</div>
</div>
<p>这里g执行两次是为了防止小机率的页面渲染不充分的问题
s是预览，可以先查看一下有没有什么问题
再次部署后，问题解决</p>]]></content>
            
            
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/categories/%E7%AB%99%E7%82%B9%E5%BB%BA%E8%AE%BE/" term="站点建设" label="站点建设" />
                            
                        
                    
                
                    
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/github/" term="github" label="github" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/blog/" term="blog" label="blog" />
                            
                        
                            
                            
                            
                                <category scheme="https://blog.vgmdj.cn/tags/hexo/" term="hexo" label="hexo" />
                            
                        
                    
                
            
        </entry>
    
</feed>